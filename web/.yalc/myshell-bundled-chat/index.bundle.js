'use strict';

var jsxRuntime = require('react/jsx-runtime');
var lucideReact = require('lucide-react');
var nextIntl = require('next-intl');
var React = require('react');
var RewardSuccessBg = require('@/components/rewards-center/reward-redemption/components/redemption-success-modal/assets/images/reward-success-bg.png');
var zustand = require('zustand');
var computed = require('zustand-computed');
var classVarianceAuthority = require('class-variance-authority');
var dayjs = require('dayjs');
var DialogPrimitive = require('@radix-ui/react-dialog');
var duration = require('dayjs/plugin/duration');
var clsx = require('clsx');
var nextThemes = require('next-themes');
var dynamic = require('next/dynamic');
var reactUse = require('react-use');
var navigation = require('next/navigation');
var react = require('@chakra-ui/react');
var Image$4 = require('next/image');
var TextareaAutosize = require('react-textarea-autosize');
var framerMotion = require('framer-motion');
var usehooksTs = require('usehooks-ts');
require('swiper/css');
var messageList = require('@virtuoso.dev/message-list');
var lodashEs = require('lodash-es');
var CheckboxPrimitive = require('@radix-ui/react-checkbox');
require('@/styles/md-viewer.scss');
var isomorphicDompurify = require('isomorphic-dompurify');
var ReactMarkdown = require('react-markdown');
var RehypeExternalLinks = require('rehype-external-links');
var RehypeKatex = require('rehype-katex');
var RehypeRaw = require('rehype-raw');
var RemarkBreaks = require('remark-breaks');
var RemarkGfm = require('remark-gfm');
var RemarkMath = require('remark-math');
var mermaid = require('mermaid');
var SyntaxHighlighter = require('react-syntax-highlighter');
require('katex/dist/katex.min.css');
var ContextMenuPrimitive = require('@radix-ui/react-context-menu');
var resolvers = require('@hookform/resolvers');
var reactHookForm = require('react-hook-form');
var zod = require('zod');
var reactSlot = require('@radix-ui/react-slot');
var LabelPrimitive = require('@radix-ui/react-label');
var reactSwipeable = require('react-swipeable');
var isEqual = require('react-fast-compare');
require('file-saver');
var isMobile = require('ismobilejs');
var uuid = require('uuid');
require('viem');
var reactDropzone = require('react-dropzone');
var Hammer = require('hammerjs');
var Select = require('react-select');
var rxjs = require('rxjs');
var LinkComponent = require('next/link');
var DropdownMenuPrimitive = require('@radix-ui/react-dropdown-menu');
var Compressor = require('compressorjs');
var BotDetailBg = require('@/common/assets/images/workshop/BotDetailBg.png');
var Cropper = require('react-cropper');
require('cropperjs/dist/cropper.css');
var Lottie = require('lottie-web');
var Editor$1 = require('@monaco-editor/react');
var jsonSourceMap = require('json-source-map');
var JSON5 = require('json5');
var jsonpathPlus = require('jsonpath-plus');
var RCImage = require('rc-image');
var SeparatorPrimitive = require('@radix-ui/react-separator');
require('react-dom');
var vaul = require('vaul');
var axios = require('axios');
var chains = require('viem/chains');
var tailwindMerge = require('tailwind-merge');
var TooltipPrimitive = require('@radix-ui/react-tooltip');
var immer$1 = require('immer');
var PopoverPrimitive = require('@radix-ui/react-popover');
var QRCode = require('qrcode');
var reactHotToast = require('react-hot-toast');
var Script = require('next/script');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);
var RewardSuccessBg__default = /*#__PURE__*/_interopDefault(RewardSuccessBg);
var computed__default = /*#__PURE__*/_interopDefault(computed);
var dayjs__default = /*#__PURE__*/_interopDefault(dayjs);
var DialogPrimitive__namespace = /*#__PURE__*/_interopNamespace(DialogPrimitive);
var duration__default = /*#__PURE__*/_interopDefault(duration);
var clsx__default = /*#__PURE__*/_interopDefault(clsx);
var dynamic__default = /*#__PURE__*/_interopDefault(dynamic);
var Image__default = /*#__PURE__*/_interopDefault(Image$4);
var TextareaAutosize__default = /*#__PURE__*/_interopDefault(TextareaAutosize);
var CheckboxPrimitive__namespace = /*#__PURE__*/_interopNamespace(CheckboxPrimitive);
var ReactMarkdown__default = /*#__PURE__*/_interopDefault(ReactMarkdown);
var RehypeExternalLinks__default = /*#__PURE__*/_interopDefault(RehypeExternalLinks);
var RehypeKatex__default = /*#__PURE__*/_interopDefault(RehypeKatex);
var RehypeRaw__default = /*#__PURE__*/_interopDefault(RehypeRaw);
var RemarkBreaks__default = /*#__PURE__*/_interopDefault(RemarkBreaks);
var RemarkGfm__default = /*#__PURE__*/_interopDefault(RemarkGfm);
var RemarkMath__default = /*#__PURE__*/_interopDefault(RemarkMath);
var mermaid__default = /*#__PURE__*/_interopDefault(mermaid);
var SyntaxHighlighter__default = /*#__PURE__*/_interopDefault(SyntaxHighlighter);
var ContextMenuPrimitive__namespace = /*#__PURE__*/_interopNamespace(ContextMenuPrimitive);
var LabelPrimitive__namespace = /*#__PURE__*/_interopNamespace(LabelPrimitive);
var isEqual__default = /*#__PURE__*/_interopDefault(isEqual);
var isMobile__default = /*#__PURE__*/_interopDefault(isMobile);
var Hammer__default = /*#__PURE__*/_interopDefault(Hammer);
var Select__default = /*#__PURE__*/_interopDefault(Select);
var LinkComponent__default = /*#__PURE__*/_interopDefault(LinkComponent);
var DropdownMenuPrimitive__namespace = /*#__PURE__*/_interopNamespace(DropdownMenuPrimitive);
var Compressor__default = /*#__PURE__*/_interopDefault(Compressor);
var BotDetailBg__default = /*#__PURE__*/_interopDefault(BotDetailBg);
var Cropper__default = /*#__PURE__*/_interopDefault(Cropper);
var Lottie__default = /*#__PURE__*/_interopDefault(Lottie);
var Editor__default = /*#__PURE__*/_interopDefault(Editor$1);
var jsonSourceMap__default = /*#__PURE__*/_interopDefault(jsonSourceMap);
var JSON5__default = /*#__PURE__*/_interopDefault(JSON5);
var RCImage__default = /*#__PURE__*/_interopDefault(RCImage);
var SeparatorPrimitive__namespace = /*#__PURE__*/_interopNamespace(SeparatorPrimitive);
var axios__default = /*#__PURE__*/_interopDefault(axios);
var TooltipPrimitive__namespace = /*#__PURE__*/_interopNamespace(TooltipPrimitive);
var PopoverPrimitive__namespace = /*#__PURE__*/_interopNamespace(PopoverPrimitive);
var QRCode__default = /*#__PURE__*/_interopDefault(QRCode);
var Script__default = /*#__PURE__*/_interopDefault(Script);

var ConversationScenario;
(function (ConversationScenario) {
    ConversationScenario[ConversationScenario["CONVERSATION_SCENARIO_UNSPECIFIED"] = 0] = "CONVERSATION_SCENARIO_UNSPECIFIED";
    ConversationScenario[ConversationScenario["CONVERSATION_SCENARIO_WEB_FOR_TESTS"] = 2] = "CONVERSATION_SCENARIO_WEB_FOR_TESTS";
    ConversationScenario[ConversationScenario["CONVERSATION_SCENARIO_IMMERSION_WEB_CHAT"] = 3] = "CONVERSATION_SCENARIO_IMMERSION_WEB_CHAT";
    ConversationScenario[ConversationScenario["CONVERSATION_SCENARIO_WEB_CHAT_NORMAL"] = 4] = "CONVERSATION_SCENARIO_WEB_CHAT_NORMAL";
    ConversationScenario[ConversationScenario["CONVERSATION_SCENARIO_BOT_GENERATION"] = 9] = "CONVERSATION_SCENARIO_BOT_GENERATION";
})(ConversationScenario || (ConversationScenario = {}));
var JobTypeEnum;
(function (JobTypeEnum) {
    JobTypeEnum["UNSPECIFIED"] = "JOB_TYPE_UNSPECIFIED";
    JobTypeEnum["BOT_CREATE"] = "JOB_TYPE_BOT_CREATE";
    JobTypeEnum["BOT_UPDATE_PROMPT"] = "JOB_TYPE_BOT_UPDATE_PROMPT";
    JobTypeEnum["IMAGE_GEN_REQUEST"] = "JOB_TYPE_GENERATION_IMAGE_REQUEST";
    JobTypeEnum["COMP_GEN_REQUEST"] = "JOB_TYPE_GENERATION_COMPONENT_REQUEST";
    JobTypeEnum["LEPTON_INNER_GEN_QUEUE"] = "JOB_TYPE_GENERATION_LEPTON_INNER_QUEUE";
    JobTypeEnum["WIDGET_AUTO_PROMPT"] = "JOB_TYPE_WIDGET_AUTO_PROMPT";
    JobTypeEnum["WIDGET_VOICE_CLONE"] = "JOB_TYPE_WIDGET_VOICE_CLONE";
    JobTypeEnum["RUNNING_ASYNC_STATE_MACHINE"] = "JOB_TYPE_RUNNING_ASYNC_STATE_MACHINE";
})(JobTypeEnum || (JobTypeEnum = {}));
var JobStatusEnum;
(function (JobStatusEnum) {
    JobStatusEnum["WAITING"] = "JOB_STATUS_WAITING";
    JobStatusEnum["DOING"] = "JOB_STATUS_DOING";
    JobStatusEnum["DONE"] = "JOB_STATUS_DONE";
    JobStatusEnum["FAILED"] = "JOB_STATUS_FAILED";
    JobStatusEnum["CANCELED"] = "JOB_STATUS_CANCELED";
})(JobStatusEnum || (JobStatusEnum = {}));
var EmbedObjStatus$1;
(function (EmbedObjStatus) {
    EmbedObjStatus["UNKNOWN"] = "EMBED_OBJ_STATUS_UNSPECIFIED";
    EmbedObjStatus["PENDING"] = "EMBED_OBJ_STATUS_PENDING";
    EmbedObjStatus["PROCESSING"] = "EMBED_OBJ_STATUS_PROCESSING";
    EmbedObjStatus["DONE"] = "EMBED_OBJ_STATUS_DONE";
    EmbedObjStatus["ERROR"] = "EMBED_OBJ_STATUS_ERROR";
    EmbedObjStatus["DELETED"] = "EMBED_OBJ_STATUS_DELETED";
    EmbedObjStatus["QUEUEING"] = "EMBED_OBJ_STATUS_QUEUEING";
})(EmbedObjStatus$1 || (EmbedObjStatus$1 = {}));
var EmbedObjType$1;
(function (EmbedObjType) {
    EmbedObjType["UNKNOWN"] = "MESSAGE_METADATA_TYPE_UNSPECIFIED";
    EmbedObjType["IMAGE"] = "MESSAGE_METADATA_TYPE_IMAGE_FILE";
    EmbedObjType["DOC"] = "MESSAGE_METADATA_TYPE_TEXT_FILE";
    EmbedObjType["AUDIO"] = "MESSAGE_METADATA_TYPE_AUDIO_FILE";
    EmbedObjType["VIDEO"] = "MESSAGE_METADATA_TYPE_VIDEO_FILE";
    EmbedObjType["TEXT_CONTENT"] = "MESSAGE_METADATA_TYPE_TEXT_CONTENT";
    EmbedObjType["AUDIO_CONTENT"] = "MESSAGE_METADATA_TYPE_USER_AUDIO";
    EmbedObjType["ALL"] = "MESSAGE_METADATA_TYPE_ALL_FILE";
})(EmbedObjType$1 || (EmbedObjType$1 = {}));
var FeedbackState;
(function (FeedbackState) {
    FeedbackState["NORMAL"] = "Normal";
    FeedbackState["LIKED"] = "Liked";
    FeedbackState["DISLIKE"] = "Dislike";
})(FeedbackState || (FeedbackState = {}));
var ChatSettingSpeakingLangEnum$1;
(function (ChatSettingSpeakingLangEnum) {
    ChatSettingSpeakingLangEnum["UNSPECIFIED"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_UNSPECIFIED";
    ChatSettingSpeakingLangEnum["AUTO"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_AUTO";
    ChatSettingSpeakingLangEnum["EN"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_EN";
    ChatSettingSpeakingLangEnum["ZH"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_ZH";
    ChatSettingSpeakingLangEnum["JA"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_JA";
    ChatSettingSpeakingLangEnum["RU"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_RU";
    ChatSettingSpeakingLangEnum["ES"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_ES";
    ChatSettingSpeakingLangEnum["KO"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_KO";
})(ChatSettingSpeakingLangEnum$1 || (ChatSettingSpeakingLangEnum$1 = {}));
var ChatSettingAudioSpeed;
(function (ChatSettingAudioSpeed) {
    ChatSettingAudioSpeed["UNSPECIFIED"] = "BOT_CHAT_SETTING_AUDIO_SPEED_UNSPECIFIED";
    ChatSettingAudioSpeed["ZERO_POINT_FIVE"] = "BOT_CHAT_SETTING_AUDIO_SPEED_ZERO_POINT_FIVE";
    ChatSettingAudioSpeed["ZERO_POINT_SEVEN_FIVE"] = "BOT_CHAT_SETTING_AUDIO_SPEED_ZERO_POINT_SEVEN_FIVE";
    ChatSettingAudioSpeed["ONE"] = "BOT_CHAT_SETTING_AUDIO_SPEED_ONE";
    ChatSettingAudioSpeed["ONE_POINT_TWENTY_FIVE"] = "BOT_CHAT_SETTING_AUDIO_SPEED_ONE_POINT_TWENTY_FIVE";
    ChatSettingAudioSpeed["ONE_POINT_FIVE"] = "BOT_CHAT_SETTING_AUDIO_SPEED_ONE_POINT_FIVE";
})(ChatSettingAudioSpeed || (ChatSettingAudioSpeed = {}));
exports.MenuFunctionEnum = void 0;
(function (MenuFunctionEnum) {
    MenuFunctionEnum[MenuFunctionEnum["REMOVE_FROM_LIST"] = 0] = "REMOVE_FROM_LIST";
    MenuFunctionEnum[MenuFunctionEnum["SHARE"] = 1] = "SHARE";
    MenuFunctionEnum[MenuFunctionEnum["CLEAR_MEMORY"] = 2] = "CLEAR_MEMORY";
    MenuFunctionEnum[MenuFunctionEnum["CLEAR_HISTORY"] = 3] = "CLEAR_HISTORY";
})(exports.MenuFunctionEnum || (exports.MenuFunctionEnum = {}));
var MenuActionType;
(function (MenuActionType) {
    MenuActionType["Like"] = "Like";
    MenuActionType["Dislike"] = "Dislike";
    MenuActionType["Copy_Message"] = "Copy Message";
    MenuActionType["Select_Text"] = "Select Text";
    MenuActionType["Stop_Generating"] = "Stop Generating";
    MenuActionType["Regenerate"] = "Regenerate";
    MenuActionType["Edit"] = "Edit";
    MenuActionType["Translate"] = "Translate";
    MenuActionType["Show_Text"] = "Show Text";
    MenuActionType["Download_Voice"] = "Download Voice";
    MenuActionType["Share"] = "Share";
    MenuActionType["Delete"] = "Delete";
    MenuActionType["Remove_Dislike"] = "Remove Dislike";
    MenuActionType["Regenerate_Voice"] = "Regenerate Voice";
    MenuActionType["Feedback"] = "Feedback";
    MenuActionType["Save_Image"] = "Save Image";
    MenuActionType["Copy_Image"] = "Copy Image";
    MenuActionType["Copy_Image_Link"] = "Copy Image Link";
    MenuActionType["Publish_To_Gallery"] = "Publish to Gallery";
    MenuActionType["Divider"] = "Divider";
})(MenuActionType || (MenuActionType = {}));
var RunningErrorEnum;
(function (RunningErrorEnum) {
    RunningErrorEnum["UNSPECIFIED"] = "RUNNING_ERROR_TYPE_UNSPECIFIED";
    RunningErrorEnum["ENGINE_ERROR"] = "RUNNING_ERROR_TYPE_ENGINE_ERROR";
    RunningErrorEnum["INNER_COMPONENT_ERROR"] = "RUNNING_ERROR_TYPE_INNER_COMPONENT_ERROR";
    RunningErrorEnum["ENERGY_INSUFFICIANT"] = "RUNNING_ERROR_TYPE_ENERGY_INSUFFICIANT";
    RunningErrorEnum["LLM_TOKEN_TOO_LONG"] = "RUNNING_ERROR_TYPE_LLM_TOKEN_TOO_LONG";
})(RunningErrorEnum || (RunningErrorEnum = {}));
var ImageGenStatus;
(function (ImageGenStatus) {
    ImageGenStatus["UNSPECIFIED"] = "MESSAGE_STATUS_UNSPECIFIED";
    ImageGenStatus["PENDING"] = "PENDING";
    ImageGenStatus["PROCESSING"] = "PROCESSING";
    ImageGenStatus["DONE"] = "DONE";
    ImageGenStatus["ERROR"] = "ERROR";
    ImageGenStatus["DELETED"] = "DELETED";
    ImageGenStatus["CANCELED"] = "CANCELED";
})(ImageGenStatus || (ImageGenStatus = {}));
var ImageGenType;
(function (ImageGenType) {
    ImageGenType["UNSPECIFIED"] = "IMAGE_GEN_MESSAGE_TYPE_UNSPECIFIED";
    ImageGenType["SIMPLE"] = "IMAGE_GEN_MESSAGE_TYPE_SIMPLE_MESSAGE";
    ImageGenType["COMMAND"] = "IMAGE_GEN_MESSAGE_TYPE_COMMAND_MESSAGE";
    ImageGenType["PANEL"] = "IMAGE_GEN_MESSAGE_TYPE_PANEL_MESSAGE";
    ImageGenType["REGEN"] = "IMAGE_GEN_MESSAGE_TYPE_REGENERATE_MESSAGE";
    ImageGenType["VARIATION"] = "IMAGE_GEN_MESSAGE_TYPE_VARIATION_MESSAGE";
    ImageGenType["UPSCALE"] = "IMAGE_GEN_MESSAGE_TYPE_UPSCALE_MESSAGE";
    ImageGenType["GIF"] = "IMAGE_GEN_MESSAGE_TYPE_SIMPLE_GIF";
})(ImageGenType || (ImageGenType = {}));
var ButtonActionTypeEnum;
(function (ButtonActionTypeEnum) {
    ButtonActionTypeEnum["JUMP_LINK"] = "MESSAGE_COMPONENTS_BUTTON_ACTION_TYPE_JUMP_LINK";
    ButtonActionTypeEnum["POP_UP_FORM"] = "MESSAGE_COMPONENTS_BUTTON_ACTION_TYPE_POP_UP_FORM";
    ButtonActionTypeEnum["INTERACTION"] = "MESSAGE_COMPONENTS_BUTTON_ACTION_TYPE_INTERACTION";
    ButtonActionTypeEnum["CLIPBOARD"] = "MESSAGE_COMPONENTS_BUTTON_ACTION_TYPE_CLIPBOARD";
})(ButtonActionTypeEnum || (ButtonActionTypeEnum = {}));
var ServerFileTypes;
(function (ServerFileTypes) {
    ServerFileTypes["AUDIO"] = "MESSAGE_METADATA_TYPE_AUDIO_FILE";
    ServerFileTypes["IMAGE"] = "MESSAGE_METADATA_TYPE_IMAGE_FILE";
    ServerFileTypes["APPLICATION"] = "MESSAGE_METADATA_TYPE_TEXT_FILE";
    ServerFileTypes["VIDEO"] = "MESSAGE_METADATA_TYPE_VIDEO_FILE";
    ServerFileTypes["ALL"] = "MESSAGE_METADATA_TYPE_ALL_FILE";
})(ServerFileTypes || (ServerFileTypes = {}));
var MessageComponentsTypeEnum;
(function (MessageComponentsTypeEnum) {
    MessageComponentsTypeEnum["ROW"] = "BOT_MESSAGE_COMPONENTS_TYPE_ROW";
    MessageComponentsTypeEnum["BUTTON"] = "BOT_MESSAGE_COMPONENTS_TYPE_BUTTON";
    MessageComponentsTypeEnum["CONTAINER"] = "BOT_MESSAGE_COMPONENTS_TYPE_CONTAINER";
})(MessageComponentsTypeEnum || (MessageComponentsTypeEnum = {}));
var MessageComponentsButtonContentDirectionEnum;
(function (MessageComponentsButtonContentDirectionEnum) {
    MessageComponentsButtonContentDirectionEnum["LEFT"] = "BOT_MESSAGE_COMPONENTS_BUTTON_CONTENT_DIRECTION_LEFT";
    MessageComponentsButtonContentDirectionEnum["RIGHT"] = "BOT_MESSAGE_COMPONENTS_BUTTON_CONTENT_DIRECTION_RIGHT";
})(MessageComponentsButtonContentDirectionEnum || (MessageComponentsButtonContentDirectionEnum = {}));
var MessageComponentsButtonActionTypeEnum;
(function (MessageComponentsButtonActionTypeEnum) {
    MessageComponentsButtonActionTypeEnum["JUMP_LINK"] = "MESSAGE_COMPONENTS_BUTTON_ACTION_TYPE_JUMP_LINK";
    MessageComponentsButtonActionTypeEnum["POP_UP_FORM"] = "MESSAGE_COMPONENTS_BUTTON_ACTION_TYPE_POP_UP_FORM";
    MessageComponentsButtonActionTypeEnum["INTERACTION"] = "MESSAGE_COMPONENTS_BUTTON_ACTION_TYPE_INTERACTION";
    MessageComponentsButtonActionTypeEnum["CLIPBOARD"] = "MESSAGE_COMPONENTS_BUTTON_ACTION_TYPE_CLIPBOARD";
})(MessageComponentsButtonActionTypeEnum || (MessageComponentsButtonActionTypeEnum = {}));
var MessageComponentsButtonActionInteractionInputDisplayTypeEnum;
(function (MessageComponentsButtonActionInteractionInputDisplayTypeEnum) {
    MessageComponentsButtonActionInteractionInputDisplayTypeEnum["TEXT"] = "BOT_MESSAGE_COMPONENTS_BUTTON_ACTION_INTERACTION_INPUT_DISPLAY_TYPE_TEXT";
    MessageComponentsButtonActionInteractionInputDisplayTypeEnum["SLASH_COMMAND"] = "BOT_MESSAGE_COMPONENTS_BUTTON_ACTION_INTERACTION_INPUT_DISPLAY_TYPE_SLASH_COMMAND";
    MessageComponentsButtonActionInteractionInputDisplayTypeEnum["NOTHING"] = "BOT_MESSAGE_COMPONENTS_BUTTON_ACTION_INTERACTION_INPUT_DISPLAY_TYPE_NOTHING";
})(MessageComponentsButtonActionInteractionInputDisplayTypeEnum || (MessageComponentsButtonActionInteractionInputDisplayTypeEnum = {}));
var ImComponentsInputTypeEnum$1;
(function (ImComponentsInputTypeEnum) {
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_UNSPECIFIED"] = "BOT_IM_COMPONENT_INPUT_TYPE_UNSPECIFIED";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_FILE_UPLOAD"] = "BOT_IM_COMPONENT_INPUT_TYPE_FILE_UPLOAD";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_VIDEO_UPLOAD"] = "BOT_IM_COMPONENT_INPUT_TYPE_VIDEO_UPLOAD";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_IMAGE_UPLOAD"] = "BOT_IM_COMPONENT_INPUT_TYPE_IMAGE_UPLOAD";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_TEXT_UPLOAD"] = "BOT_IM_COMPONENT_INPUT_TYPE_TEXT_UPLOAD";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_TEXT_INPUT"] = "BOT_IM_COMPONENT_INPUT_TYPE_TEXT_INPUT";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_TEXT_SELECTOR"] = "BOT_IM_COMPONENT_INPUT_TYPE_TEXT_SELECTOR";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_INPUT"] = "BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_INPUT";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_INTEGER_INPUT"] = "BOT_IM_COMPONENT_INPUT_TYPE_INTEGER_INPUT";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_CHECKBOX"] = "BOT_IM_COMPONENT_INPUT_TYPE_CHECKBOX";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_SELECTOR"] = "BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_SELECTOR";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_CODE_EDITOR"] = "BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_SELECTOR";
})(ImComponentsInputTypeEnum$1 || (ImComponentsInputTypeEnum$1 = {}));
var SupportedEmbedTypesEnum;
(function (SupportedEmbedTypesEnum) {
    SupportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_UNSPECIFIED"] = "MESSAGE_METADATA_TYPE_UNSPECIFIED";
    SupportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_IMAGE_FILE"] = "MESSAGE_METADATA_TYPE_IMAGE_FILE";
    SupportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_TEXT_FILE"] = "MESSAGE_METADATA_TYPE_TEXT_FILE";
    SupportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_ALL_FILE"] = "MESSAGE_METADATA_TYPE_ALL_FILE";
    SupportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_AUDIO_FILE"] = "MESSAGE_METADATA_TYPE_AUDIO_FILE";
    SupportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_VIDEO_FILE"] = "MESSAGE_METADATA_TYPE_VIDEO_FILE";
    SupportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_TEXT_CONTENT"] = "MESSAGE_METADATA_TYPE_TEXT_CONTENT";
    SupportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_USER_AUDIO"] = "MESSAGE_METADATA_TYPE_USER_AUDIO";
    SupportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_COMPONENT_INPUT"] = "MESSAGE_METADATA_TYPE_COMPONENT_INPUT";
    SupportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_ASYNC_JOB_INFO"] = "MESSAGE_METADATA_TYPE_ASYNC_JOB_INFO";
})(SupportedEmbedTypesEnum || (SupportedEmbedTypesEnum = {}));

const defaultFn$1 = () => { };
const StaticContext = React.createContext({
    type: 'bot',
    entityInfo: {
        id: '',
        name: '',
        energyPerChat: 0,
        pinned: false
    },
    readonly: false,
    interactionDisabled: false,
    textDisabled: false,
    audioDisabled: false,
    uploadDisabled: false,
    visitorInteroperable: true,
    showInteractionCostEnergy: true,
    showChatSetting: true,
    chatSettingDisabled: true,
    menuDisabled: false,
    menuFunctions: [],
    getList: async () => {
        return [];
    },
    updateChatSetting: defaultFn$1,
    partialUpdateDetail: defaultFn$1,
    setEnergyInfo: defaultFn$1,
    showPin: true,
    atBottom: false,
    setAtBottom: defaultFn$1,
    imgGenerator: false,
    showReplyName: false,
    forceToLogin: false,
    terminatable: true,
    messageShareAvailable: true,
    feedbackAvailable: true,
    showMockReply: true
});

const defaultFn = () => { };
const defaultAsyncFn = async () => { };
const MessageContext = React.createContext({
    messageList: [],
    messageToDisplay: defaultFn,
    exceptionsForTextDisplay: {},
    addTextDisplayException: defaultFn,
    sending: false,
    interacting: false,
    showTerminate: false,
    scrollToBottom: 0,
    setDraftMessage: defaultFn,
    sendTextMessage: defaultFn,
    sendAudioMessage: defaultAsyncFn,
    sendButtonInteractionMessage: defaultAsyncFn,
    errorMessageRetry: defaultAsyncFn,
    terminate: defaultFn,
    hasMore: false,
    gettingHistory: false,
    initializingHistory: false,
    messageInited: false,
    getHistoryMessage: async () => [],
    markAsRead: defaultAsyncFn,
    appendMessages: defaultFn,
    mixMessages: defaultFn,
    updateMessage: defaultFn,
    deleteSpecifiedMessageId: defaultFn,
    partialUpdateMessage: defaultFn,
    translate: defaultFn,
    playingAudio: '',
    playNext: defaultFn,
    enQueue: defaultFn,
    clearQueue: defaultFn,
    dragMaskVisible: false,
    editorMode: 'NORMAL',
    setEditorMode: defaultFn,
    inputMode: 'TEXT',
    setInputMode: defaultFn,
    share: {
        idSet: new Set(),
        add: defaultFn,
        remove: defaultFn,
        clear: defaultFn,
        allChecked: false,
        checkAllHandler: defaultFn
    },
    file: {
        uploadedFiles: [],
        uploadFiles: defaultFn,
        deleteFile: defaultFn,
    },
    questions: [],
    scrolled: true,
    setScrolled: defaultFn
});

function CheckCircleIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12Zm13.36-1.814a.75.75 0 1 0-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 0 0-1.06 1.06l2.25 2.25a.75.75 0 0 0 1.14-.094l3.75-5.25Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$W = /*#__PURE__*/ React__namespace.forwardRef(CheckCircleIcon$1);

function XCircleIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25Zm-1.72 6.97a.75.75 0 1 0-1.06 1.06L10.94 12l-1.72 1.72a.75.75 0 1 0 1.06 1.06L12 13.06l1.72 1.72a.75.75 0 1 0 1.06-1.06L13.06 12l1.72-1.72a.75.75 0 1 0-1.06-1.06L12 10.94l-1.72-1.72Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$V = /*#__PURE__*/ React__namespace.forwardRef(XCircleIcon$1);

function InformationCircleIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m11.25 11.25.041-.02a.75.75 0 0 1 1.063.852l-.708 2.836a.75.75 0 0 0 1.063.853l.041-.021M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9-3.75h.008v.008H12V8.25Z"
  }));
}
const ForwardRef$U = /*#__PURE__*/ React__namespace.forwardRef(InformationCircleIcon$1);

var UserSettingEnum;
(function (UserSettingEnum) {
    UserSettingEnum["LAST_SEASON"] = "lastSeason";
    UserSettingEnum["LANGUAGE"] = "language";
    UserSettingEnum["SHOW_NSFW"] = "showNsfw";
    UserSettingEnum["FLAG_ICON_REWARD"] = "flagIconReward";
    UserSettingEnum["FLAG_ICON_FORUM"] = "flagIconForum";
    UserSettingEnum["FLAG_LLM_MODEL_CONFIG"] = "flagLlmModelConfig";
    UserSettingEnum["FLAG_NSFW_CONFIRMED"] = "flagNsfwConfirmed";
    UserSettingEnum["FLAG_ETH_LINEA_TRANSFERRED"] = "flagEthLineaTransferred";
    UserSettingEnum["DEDUCTION_CONFIRMED"] = "flagDeductionConfirmed";
    UserSettingEnum["FLAG_COMPLETED_OPBNB_CHAIN_TASK"] = "flagCompletedOpBnbChainTask";
    UserSettingEnum["FLAG_SILENT_PERIOD_CONFIRMED"] = "flagSilentPeriodConfirmed";
    UserSettingEnum["FLAG_stake_earn_VIEWED"] = "flagSubscribingEarnViewed";
    UserSettingEnum["FLAG_SHARE_KEY_EARN_POPUP_CONFIRMED"] = "flagShareKeyEarnPopupConfirmed";
    UserSettingEnum["TIME_ZONE"] = "timezone";
    UserSettingEnum["NOTIFICATION"] = "receiveAutoPush";
    UserSettingEnum["FLAG_TAG_NOTICE"] = "flagTagNotice";
    UserSettingEnum["FLAG_USET_FIRST_PUBLISH_GALLERY"] = "flagUserFirstPublishGallery";
    UserSettingEnum["FLAG_USET_FIRST_VISIT_GALLERY"] = "flagUserFirstVisitGallery";
})(UserSettingEnum || (UserSettingEnum = {}));
var VisitorEnum;
(function (VisitorEnum) {
    VisitorEnum[VisitorEnum["YES"] = 1] = "YES";
    VisitorEnum[VisitorEnum["NO"] = 2] = "NO";
})(VisitorEnum || (VisitorEnum = {}));
var NsfwEnum;
(function (NsfwEnum) {
    NsfwEnum[NsfwEnum["INIT"] = 0] = "INIT";
    NsfwEnum[NsfwEnum["OPEN"] = 1] = "OPEN";
    NsfwEnum[NsfwEnum["CLOSE"] = 2] = "CLOSE";
})(NsfwEnum || (NsfwEnum = {}));
const ALL_LANG_OPTIONS = {
    zh: '简体中文',
    'zh-tw': '繁體中文',
    en: 'English',
    jp: '日本語',
    es: 'Español',
    ru: 'Русский',
    ko: '한국어'
};
const ALL_LANG_KEYS = Object.keys(ALL_LANG_OPTIONS);
var UserMembershipTypeEnum;
(function (UserMembershipTypeEnum) {
    UserMembershipTypeEnum["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
    UserMembershipTypeEnum["TYPE_NORMAL"] = "TYPE_NORMAL";
    UserMembershipTypeEnum["TYPE_PREMIUM"] = "TYPE_PREMIUM";
    UserMembershipTypeEnum["TYPE_GENESIS_WITH_GENESIS_CARD"] = "TYPE_GENESIS_WITH_GENESIS_CARD";
    UserMembershipTypeEnum["TYPE_GENESIS_WITH_PASS_CARD"] = "TYPE_GENESIS_WITH_PASS_CARD";
})(UserMembershipTypeEnum || (UserMembershipTypeEnum = {}));
exports.UserSourceEnum = void 0;
(function (UserSourceEnum) {
    UserSourceEnum["APKPURE_BANNER"] = "apkpure_banner";
    UserSourceEnum["MYSHELL"] = "myshell";
    UserSourceEnum["VISITOR"] = "visitor";
})(exports.UserSourceEnum || (exports.UserSourceEnum = {}));
exports.FollowStatus = void 0;
(function (FollowStatus) {
    FollowStatus["FOLLOW_STATUS_UNSPECIFIED"] = "FOLLOW_STATUS_UNSPECIFIED";
    FollowStatus["FOLLOWED"] = "FOLLOWED";
    FollowStatus["NOT_FOLLOWED"] = "NOT_FOLLOWED";
    FollowStatus["NOT_AVAILABLE"] = "NOT_AVAILABLE";
})(exports.FollowStatus || (exports.FollowStatus = {}));
exports.LoginType = void 0;
(function (LoginType) {
    LoginType["LOGIN_TYPE_UNSPECIFIED"] = "LOGIN_TYPE_UNSPECIFIED";
    LoginType["LOGIN_TYPE_EMAIL"] = "LOGIN_TYPE_EMAIL";
    LoginType["LOGIN_TYPE_GOOGLE"] = "LOGIN_TYPE_GOOGLE";
    LoginType["LOGIN_TYPE_APPLE"] = "LOGIN_TYPE_APPLE";
    LoginType["LOGIN_TYPE_FACEBOOK"] = "LOGIN_TYPE_FACEBOOK";
    LoginType["LOGIN_TYPE_PUBLIC_ADDRESS"] = "LOGIN_TYPE_PUBLIC_ADDRESS";
})(exports.LoginType || (exports.LoginType = {}));
var BindType;
(function (BindType) {
    BindType["BIND_TYPE_UNSPECIFIED"] = "BIND_TYPE_UNSPECIFIED";
    BindType["BIND_TYPE_EVM_ADDRESS"] = "BIND_TYPE_EVM_ADDRESS";
    BindType["BIND_TYPE_TWITTER"] = "BIND_TYPE_TWITTER";
    BindType["BIND_TYPE_DISCORD"] = "BIND_TYPE_DISCORD";
    BindType["BIND_TYPE_TG"] = "BIND_TYPE_TG";
})(BindType || (BindType = {}));
var WalletType;
(function (WalletType) {
    WalletType["Privy"] = "Privy";
    WalletType["Particle"] = "Particle";
    WalletType["Other"] = "Other";
})(WalletType || (WalletType = {}));
var WalletAssetType;
(function (WalletAssetType) {
    WalletAssetType["CreatorPass"] = "CreatorPass";
    WalletAssetType["MYSOUL"] = "MYSOUL";
    WalletAssetType["ETH"] = "ETH_MAINNET";
    WalletAssetType["ETH_MYSHELL"] = "ETH_MYSHELL";
    WalletAssetType["BNB_OP"] = "BNB_OP";
    WalletAssetType["BNB_BSC"] = "BNB_BSC";
    WalletAssetType["testETH"] = "testETH";
    WalletAssetType["HER"] = "HER";
    WalletAssetType["PIC"] = "PIC";
    WalletAssetType["LLM"] = "LLM";
    WalletAssetType["SD"] = "SD";
    WalletAssetType["TTS"] = "TTS";
    WalletAssetType["USDC"] = "USDC";
    WalletAssetType["USDT"] = "USDT";
    WalletAssetType["BNB_USDC"] = "BNB_USDC";
})(WalletAssetType || (WalletAssetType = {}));

const API_URL = process.env.NEXT_PUBLIC_API_URL;
process.env.NEXT_PUBLIC_WS_API_URL;
process.env.NEXT_PUBLIC_PARTICLE_PROJECT_ID;
process.env.NEXT_PUBLIC_PARTICLE_APP_ID;
process.env.NEXT_PUBLIC_PARTICLE_CLIENT_ID;
process.env.NEXT_PUBLIC_WC_PROJECT_ID;
process.env.NEXT_PUBLIC_PRIVY_APP_ID;
const CDN_URL = 'https://www.myshellstatic.com/';
process.env.NEXT_PUBLIC_HTML2IMAGE_URL;
process.env.NEXT_PUBLIC_TG_BOT_NAME;
process.env.NEXT_PUBLIC_DISCORD_CLIENT_ID;
process.env.NEXT_PUBLIC_DISCORD_REDIRECT_URL;
process.env.NEXT_PUBLIC_TWITTER_CLIENT_ID;
process.env.NEXT_PUBLIC_TWITTER_REDIRECT_URL;
process.env.NEXT_PUBLIC_TWITTER_CODE_CHALLENGE;
process.env.NEXT_PUBLIC_DISABLE_GA;
process.env.NEXT_PUBLIC_DISABLE_ADS;
process.env.NEXT_PUBLIC_DATAFLUX_RUM_ID;
process.env.NEXT_PUBLIC_DISABLE_DATAFLUX_RUM;
process.env.NEXT_PUBLIC_DATAFLUX_RUM_ORIGIN;
process.env.NEXT_PUBLIC_CAPTCHA_ID;
process.env.NEXT_PUBLIC_UPDATE_REPORT_ADDRESS;
process.env.NEXT_PUBLIC_DISABLE_SENSORS_TRACK;
process.env.NEXT_PUBLIC_DISABLE_ANALYTICS;
process.env.NEXT_PUBLIC_SALT;
process.env.NEXT_PUBLIC_APP_URL;
process.env.NEXT_PUBLIC_SENSORS_URL;
const NETEASE_ENGINE_APP_ID = process.env.NEXT_PUBLIC_NETEASE_ENGINE_APP_ID;
process.env.NEXT_PUBLIC_WEB3_API_URL;
process.env.NEXT_PUBLIC_CONTRACT_ADDRESS_STAKING;
process.env.NEXT_PUBLIC_SENSORS_ABTEST;
process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_VAPID_KEY;
process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_APIKEY;
process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_AUTHDOMAIN;
process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_PROJECTID;
process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_STORAGEBUCKET;
process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_MESSAGINGSENDERID;
process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_APPID;
process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_MEASUREMENTID;
const TRANSLATOR_BOT_ID = process.env.NEXT_PUBLIC_TRANSLATOR_BOT_ID;
const VIRTUOSO_MESSAGE_LIST_LICENSE = process.env.NEXT_PUBLIC_VIRTUOSO_MESSAGE_LIST_LICENSE;

var MessageRunningErrorType;
(function (MessageRunningErrorType) {
    MessageRunningErrorType["RUNNING_ERROR_TYPE_UNSPECIFIED"] = "RUNNING_ERROR_TYPE_UNSPECIFIED";
    MessageRunningErrorType["RUNNING_ERROR_TYPE_ENGINE_ERROR"] = "RUNNING_ERROR_TYPE_ENGINE_ERROR";
    MessageRunningErrorType["RUNNING_ERROR_TYPE_INNER_COMPONENT_ERROR"] = "RUNNING_ERROR_TYPE_INNER_COMPONENT_ERROR";
    MessageRunningErrorType["RUNNING_ERROR_TYPE_ENERGY_INSUFFICIANT"] = "RUNNING_ERROR_TYPE_ENERGY_INSUFFICIANT";
    MessageRunningErrorType["RUNNING_ERROR_TYPE_LLM_TOKEN_TOO_LONG"] = "RUNNING_ERROR_TYPE_LLM_TOKEN_TOO_LONG";
})(MessageRunningErrorType || (MessageRunningErrorType = {}));
var ImageStatus;
(function (ImageStatus) {
    ImageStatus["DONE"] = "DONE";
    ImageStatus["PROCESSING"] = "PROCESSING";
    ImageStatus["ERROR"] = "ERROR";
})(ImageStatus || (ImageStatus = {}));
var MsgEvents;
(function (MsgEvents) {
    MsgEvents["AUTH_FAIL"] = "auth_fail";
    MsgEvents["MSG_ERROR"] = "message_error";
    MsgEvents["MSG_SENT"] = "message_sent";
    MsgEvents["REPLY_MSG_CREATED"] = "reply_message_created";
    MsgEvents["MSG_UPDATED"] = "message_updated";
    MsgEvents["MSG_TEXT_STREAM"] = "text_stream";
    MsgEvents["MSG_AUDIO_STREAM"] = "audio_stream";
    MsgEvents["MSG_REPLIED"] = "message_replied";
    MsgEvents["MSG_TRANSLATED"] = "message_translated";
    MsgEvents["TRANSLATION_STREAM"] = "translation_stream";
    MsgEvents["ENERGY_INFO"] = "energy_info";
    MsgEvents["NO_ENOUGH_ENERGY"] = "no_enough_energy";
    MsgEvents["EXCEPTION"] = "exception";
    MsgEvents["RESET_MEMORY"] = "reset_memory";
    MsgEvents["BOT_PROMPT_UPDATED"] = "bot_prompt_updated";
    MsgEvents["CONNECTED_TO_DISCORD"] = "connected_to_discord";
    MsgEvents["CONNECTED_TO_TWITTER"] = "connected_to_twitter";
    MsgEvents["NEED_VERIFY_CAPTCHA"] = "need_verify_captcha";
    MsgEvents["VOICE_CALL_END"] = "voice_call_end";
    MsgEvents["CHAT_LOGIN_POPUP"] = "chat_login_popup";
})(MsgEvents || (MsgEvents = {}));
const AudioSpeedValue2KeyMap = {
    0.5: 'BOT_CHAT_SETTING_AUDIO_SPEED_ZERO_POINT_FIVE',
    0.75: 'BOT_CHAT_SETTING_AUDIO_SPEED_ZERO_POINT_SEVEN_FIVE',
    1: 'BOT_CHAT_SETTING_AUDIO_SPEED_ONE',
    1.25: 'BOT_CHAT_SETTING_AUDIO_SPEED_ONE_POINT_TWENTY_FIVE',
    1.5: 'BOT_CHAT_SETTING_AUDIO_SPEED_ONE_POINT_FIVE'
};
var ChatSettingSpeakingLangEnum;
(function (ChatSettingSpeakingLangEnum) {
    ChatSettingSpeakingLangEnum["UNSPECIFIED"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_UNSPECIFIED";
    ChatSettingSpeakingLangEnum["AUTO"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_AUTO";
    ChatSettingSpeakingLangEnum["EN"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_EN";
    ChatSettingSpeakingLangEnum["ZH"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_ZH";
    ChatSettingSpeakingLangEnum["JA"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_JA";
    ChatSettingSpeakingLangEnum["RU"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_RU";
    ChatSettingSpeakingLangEnum["ES"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_ES";
    ChatSettingSpeakingLangEnum["KO"] = "BOT_CHAT_SETTING_SPEAKING_LANGUAGE_KO";
})(ChatSettingSpeakingLangEnum || (ChatSettingSpeakingLangEnum = {}));

function getAssetsUrl(url) {
    if (!isString(url) || !(url || '').trim()) {
        return url;
    }
    if (url.startsWith('http')) {
        return url;
    }
    return `${CDN_URL}${url}`;
}
function isClient() {
    return typeof window !== 'undefined';
}
function isString(str) {
    return typeof str === 'string' || str instanceof String;
}
function isNullOrUndefined(value) {
    return value == null || value === undefined;
}
function generateUUID() {
    return uuid.v4();
}
function isIos() {
    const device = isMobile__default.default();
    return device.apple.phone || device.apple.tablet || device.apple.ipod;
}
function checkSupportedMimeType() {
    const mimeTypes = [
        'audio/mp4',
        'audio/mpeg',
        'audio/wav',
        'audio/webm',
        'audio/webm;codecs=opus',
        'audio/webm;codecs=pcm',
        'audio/ogg',
        'audio/ogg;codecs=opus',
        'audio/ogg;codecs=vorbis'
    ];
    let supportedType = '';
    try {
        for (const type of mimeTypes) {
            if (MediaRecorder.isTypeSupported(type)) {
                supportedType = type;
                break;
            }
        }
    }
    catch (e) {
    }
    return supportedType;
}
function checkAudioRecordSupport() {
    return (!!navigator.mediaDevices && navigator.mediaDevices.getUserMedia) || !!window.MediaRecorder;
}
function requestAudioRecordAccess() {
    return navigator.mediaDevices.getUserMedia({
        audio: true,
        video: false
    });
}
function secondsConverter(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    return `${(minutes < 10 && minutes > 0 ? '0' : '') + minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
}
function durationFormatter(seconds) {
    if (isNaN(seconds) || seconds === Infinity) {
        return '';
    }
    const _seconds = Math.floor(seconds);
    return secondsConverter(_seconds);
}
function getFileExtension(fileName) {
    const parts = fileName.split('.');
    if (parts.length > 1) {
        return parts[parts.length - 1].toLowerCase();
    }
    return '';
}
function camelToSnake(camelCase) {
    return camelCase.replace(/([A-Z])/g, '_$1').toLowerCase();
}
function isVideo(fileSuffix) {
    const videoTypes = ['mp4'];
    return videoTypes.some(t => t === fileSuffix);
}
const getPercent = (time, duration) => {
    if (!time || !duration) {
        return 0;
    }
    const ratio = time / duration;
    return ratio >= 1 ? 1 : ratio;
};
const numberArraySum = (numberArr) => {
    return numberArr.reduce((accumulator, currentValue) => {
        return accumulator + currentValue;
    }, 0);
};

class IdentityService {
    constructor() {
    }
    getIsNewUser() {
        const userId = localStorage.getItem('userId');
        return localStorage.getItem(`isnew-${userId}`) === '1';
    }
    setIsNewUser(isNew) {
        const userId = localStorage.getItem('userId');
        localStorage.setItem(`isnew-${userId}`, isNew ? '1' : '0');
    }
    getIsKol() {
        return localStorage.getItem('kol') === '1';
    }
    setIsKol(isKol) {
        localStorage.setItem('kol', isKol ? '1' : '0');
    }
    setHasVisitedAIpp(value) {
        localStorage.setItem('isFirstToAIpp', value.toString());
    }
    getHasVisitedAIpp() {
        return localStorage.getItem('isFirstToAIpp') || undefined;
    }
    setIsViewedHowToPlay(value) {
        localStorage.setItem('isViewedHowToPlay', value.toString());
    }
    getIsViewedHowToPlay() {
        return localStorage.getItem('isViewedHowToPlay') || undefined;
    }
    getLoginMethod() {
        return localStorage.getItem('loginMethod');
    }
    getPrivyToken() {
        return localStorage.getItem('privy:token');
    }
    getInviteCode() {
        return localStorage.getItem('inviteCode');
    }
    setInviteCode(value) {
        if (value) {
            localStorage.setItem('inviteCode', value);
        }
        else {
            localStorage.removeItem('inviteCode');
        }
    }
    getPageSearch(pageId) {
        return sessionStorage.getItem(`${pageId}-searchparams`);
    }
    setPageSearch(pageId, value) {
        if (value) {
            sessionStorage.setItem(`${pageId}-searchparams`, value);
        }
        else {
            sessionStorage.removeItem(`${pageId}-searchparams`);
        }
    }
    getSharingCode() {
        return localStorage.getItem('sharingCode');
    }
    setSharingCode(value) {
        if (value) {
            localStorage.setItem('sharingCode', value);
        }
        else {
            localStorage.removeItem('sharingCode');
        }
    }
    getSharingBotCode() {
        return localStorage.getItem('sharingBotCode');
    }
    setSharingBotCode(value) {
        if (value) {
            localStorage.setItem('sharingBotCode', value);
        }
        else {
            localStorage.removeItem('sharingBotCode');
        }
    }
    getSharingBotId() {
        return localStorage.getItem('sharingBotId');
    }
    setSharingBotId(value) {
        if (value) {
            localStorage.setItem('sharingBotId', value);
        }
        else {
            localStorage.removeItem('sharingBotId');
        }
    }
    getAnonymousId() {
        return localStorage.getItem('mix_sc_anonymous_id');
    }
    setAnonymousId(value) {
        if (value) {
            localStorage.setItem('mix_sc_anonymous_id', value);
        }
        else {
            localStorage === null || localStorage === void 0 ? void 0 : localStorage.removeItem('mix_sc_anonymous_id');
        }
    }
    getSCDeviceId() {
        return localStorage.getItem('mix_sc_device_id');
    }
    setSCDeviceId(value) {
        if (value) {
            localStorage.setItem('mix_sc_device_id', value);
        }
        else {
            localStorage === null || localStorage === void 0 ? void 0 : localStorage.removeItem('mix_sc_device_id');
        }
    }
    getPublicAddress() {
        const publicAddressStr = localStorage.getItem('publicAddress');
        return publicAddressStr || null;
    }
    setPublicAddress(value) {
        if (isNullOrUndefined(value)) {
            localStorage.removeItem('publicAddress');
        }
        else {
            localStorage.setItem('publicAddress', `${value}`);
        }
    }
    setShareWidgetLink(link) {
        if (link) {
            localStorage.setItem('shareWidgetLink', link);
        }
        else {
            localStorage.removeItem('shareWidgetLink');
        }
    }
    getShareWidgetLink() {
        var _a;
        return (_a = localStorage.getItem('shareWidgetLink')) !== null && _a !== void 0 ? _a : undefined;
    }
    setInviteInfo(link) {
        return localStorage.setItem('inviteLink', link);
    }
    getInviteInfo() {
        var _a;
        return (_a = localStorage.getItem('inviteLink')) !== null && _a !== void 0 ? _a : undefined;
    }
    removeInviteInfo() {
        localStorage.removeItem('inviteLink');
    }
    setTgGuid(tgGuid) {
        localStorage.setItem('tgGuid', tgGuid);
    }
    getTgGuid() {
        var _a;
        return (_a = localStorage.getItem('tgGuid')) !== null && _a !== void 0 ? _a : undefined;
    }
    setAutoEnhanced(autoEnhanced) {
        localStorage.setItem('autoEnhanced', autoEnhanced);
    }
    getAutoEnhanced() {
        var _a;
        return (_a = localStorage.getItem('autoEnhanced')) !== null && _a !== void 0 ? _a : undefined;
    }
    setTryAdvanced(tryAdvanced) {
        localStorage.setItem('tryAdvanced', tryAdvanced);
    }
    getTryAdvanced() {
        var _a;
        return (_a = localStorage.getItem('tryAdvanced')) !== null && _a !== void 0 ? _a : undefined;
    }
    setHasPrivyMarquee(hasPrivyMarquee) {
        const userId = localStorage.getItem('userId');
        localStorage.setItem(`hasPrivyMarquee-${userId}`, hasPrivyMarquee);
    }
    getHasPrivyMarquee() {
        var _a;
        const userId = localStorage.getItem('userId');
        return (_a = localStorage.getItem(`hasPrivyMarquee-${userId}`)) !== null && _a !== void 0 ? _a : undefined;
    }
    setUserGuide(userGuide) {
        const userId = localStorage.getItem('userId');
        localStorage.setItem(`userGuide-${userId}`, userGuide);
    }
    getChatDrivered() {
        var _a;
        return (_a = localStorage.getItem('handleOpenDrivered')) !== null && _a !== void 0 ? _a : undefined;
    }
    setChatDrivered(isDriverd) {
        localStorage.setItem('handleOpenDrivered', isDriverd);
    }
    getUserGuide() {
        var _a;
        const userId = localStorage.getItem('userId');
        return (_a = localStorage.getItem(`userGuide-${userId}`)) !== null && _a !== void 0 ? _a : undefined;
    }
    clearTgGuid() {
        localStorage.removeItem('tgGuid');
    }
    clearInvitationData() {
        this.removeInviteInfo();
        localStorage.removeItem('inviteCode');
        localStorage.removeItem('sharingBotCode');
        localStorage.removeItem('sharingBotUid');
        localStorage.removeItem('sharingBotId');
        localStorage.removeItem('sharingCode');
    }
    setBlockChainTransactionCalled(userId, step, expireTimeStamp) {
        let blockChainTransactionCalledUserMap = {};
        const blockChainTransactionCalledData = this.getBlockChainTransactionCalled();
        if (blockChainTransactionCalledData) {
            blockChainTransactionCalledUserMap = Object.assign({}, JSON.parse(blockChainTransactionCalledData));
        }
        blockChainTransactionCalledUserMap[`${userId}`] = {
            step,
            expireTimeStamp
        };
        localStorage.setItem('blockChainTransactionCalled', JSON.stringify(blockChainTransactionCalledUserMap));
    }
    clearBlockChainTransactionCalled(userId) {
        let blockChainTransactionCalledUserMap = {};
        const blockChainTransactionCalledData = this.getBlockChainTransactionCalled();
        if (blockChainTransactionCalledData) {
            blockChainTransactionCalledUserMap = Object.assign({}, JSON.parse(blockChainTransactionCalledData));
        }
        delete blockChainTransactionCalledUserMap[`${userId}`];
        localStorage.setItem('blockChainTransactionCalled', JSON.stringify(blockChainTransactionCalledUserMap));
    }
    getBlockChainTransactionCalled() {
        return localStorage.getItem('blockChainTransactionCalled');
    }
    setBlockChainGuruStep(userId, step) {
        let blockChainGuruStepUserMap = {};
        const data = this.getBlockChainGuruStep();
        if (data) {
            blockChainGuruStepUserMap = Object.assign({}, JSON.parse(data));
        }
        blockChainGuruStepUserMap[userId] = `${step}`;
        localStorage.setItem('blockChainGuruStep', JSON.stringify(blockChainGuruStepUserMap));
    }
    getBlockChainGuruStep() {
        return localStorage.getItem('blockChainGuruStep');
    }
    setBlockChainGuruHash(userId, hash) {
        let blockChainGuruHashUserMap = {};
        const data = this.getBlockChainGuruHash();
        if (data) {
            blockChainGuruHashUserMap = Object.assign({}, JSON.parse(data));
        }
        blockChainGuruHashUserMap[`${userId}`] = hash;
        localStorage.setItem('blockChainGuruHash', JSON.stringify(blockChainGuruHashUserMap));
    }
    clearBlockChainGuruHash(userId) {
        let blockChainGuruHashUserMap = {};
        const data = this.getBlockChainGuruHash();
        if (data) {
            blockChainGuruHashUserMap = Object.assign({}, JSON.parse(data));
        }
        delete blockChainGuruHashUserMap[`${userId}`];
        localStorage.setItem('blockChainGuruHash', JSON.stringify(blockChainGuruHashUserMap));
    }
    getBlockChainGuruHash() {
        return localStorage.getItem('blockChainGuruHash');
    }
    getLoginPopup() {
        return localStorage.getItem('loginPopup');
    }
    setLoginPopup(val) {
        if (val) {
            localStorage.setItem('loginPopup', val);
        }
        else {
            localStorage.removeItem('loginPopup');
        }
    }
    setTheme(value) {
        localStorage.setItem('theme', value);
    }
    getTheme() {
        return localStorage.getItem('theme');
    }
    setWidgetTransactionDisplaySet(set) {
        return localStorage.setItem('widgetTransactionDisplaySet', JSON.stringify(Array.from(set)));
    }
    getWidgetTextInputMap() {
        const d = localStorage.getItem('widgetTextInputMap');
        if (!isNullOrUndefined(d)) {
            return JSON.parse(d);
        }
        return {};
    }
    removeTextInputMap() {
        localStorage.removeItem('textInputMap');
    }
    removeWidgetTextInputMap() {
        localStorage.removeItem('widgetTextInputMap');
    }
    setCreateDraft(val, userId) {
        if (val === null) {
            localStorage.removeItem(`createDraft${userId}`);
        }
        localStorage.setItem(`createDraft${userId}`, JSON.stringify(val));
    }
    getCreateDraft(userId) {
        const d = localStorage.getItem(`createDraft${userId}`);
        if (!isNullOrUndefined(d)) {
            return JSON.parse(d);
        }
        return null;
    }
    setDontShow2FA(val) {
        localStorage.setItem('DontShow2FA', JSON.stringify(val));
    }
    getDontShow2FA() {
        const val = localStorage.getItem('DontShow2FA');
        if (!isNullOrUndefined(val)) {
            return JSON.parse(val);
        }
        return false;
    }
    getToken() {
        return localStorage.getItem('token');
    }
    setToken(value) {
        if (value) {
            localStorage.setItem('token', value);
            document.cookie = `token=${value}; path=/; max-age=259200`;
        }
        else {
            localStorage.removeItem('token');
            document.cookie = 'token=; path=/; max-age=0';
        }
    }
    clearAll() {
        const userId = localStorage.getItem('userId');
        this.clearInvitationData();
        localStorage.removeItem('publicAddress');
        localStorage.removeItem('token');
        document.cookie = 'token=; path=/; max-age=0';
        localStorage.removeItem('userId');
        localStorage.removeItem('selected_bot_id');
        localStorage.removeItem('selected_ugc_bot_id');
        localStorage.removeItem(`filterValues_${userId}`);
        localStorage.removeItem(`childTagsObj_${userId}`);
        localStorage.removeItem('sharingCode');
        localStorage.removeItem('loginMethod');
    }
}
const identityService = new IdentityService();

function computeChecksum1226(rawTimestamp) {
    const timestamp = (rawTimestamp - (rawTimestamp % 10)) / 10;
    let flag = false;
    let sum = 0;
    let t = timestamp;
    while (t) {
        const mod = t % 10;
        sum += (flag ? 5 : 2) * mod;
        t = (t - mod) / 10;
        flag = !flag;
    }
    const checkBit = sum % 10;
    return timestamp * 10 + checkBit;
}

const Global = {
    set language(language) {
        if (!isClient()) {
            throw new Error('Not support server-side call');
        }
        window.$global.locale = language;
    },
    get language() {
        if (!isClient()) {
            throw new Error('Not support server-side call');
        }
        return window.$global.locale;
    },
    get visitorId() {
        if (!isClient()) {
            throw new Error('Not support server-side call');
        }
        if (!window.$global.visitorId) {
            return generateUUID();
        }
        return window.$global.visitorId;
    },
    get userId() {
        if (!isClient()) {
            throw new Error('Not support server-side call');
        }
        return window.$global.userId;
    },
    set userId(userId) {
        if (!isClient()) {
            throw new Error('Not support server-side call');
        }
        window.$global.userId = userId;
    },
    get isLogin() {
        if (!isClient()) {
            throw new Error('Not support server-side call');
        }
        return window.$global.isLogin;
    },
    set isLogin(isLogin) {
        if (!isClient()) {
            throw new Error('Not support server-side call');
        }
        window.$global.isLogin = isLogin;
    },
};

function CfMitigatedHandler(value) {
    if (value === 'challenge') {
        const currentHref = window.location.href;
        const userId = Global.userId;
        const visitorId = Global.visitorId;
        const userIdentity = userId ? `userId=${userId}` : `visitorId=${visitorId}`;
        const targetHref = `${window.location.origin}/cf-captcha?originHref=${currentHref}&${userIdentity}`;
        window.location.href = targetHref;
    }
}

const EventEmitter = {
    events: {},
    dispatch(event, data) {
        if (!this.events[event]) {
            return;
        }
        this.events[event].forEach(callback => callback(data));
    },
    subscribe(event, callback, once) {
        if (!this.events[event]) {
            this.events[event] = [];
        }
        let cb = callback;
        if (once) {
            cb = data => {
                callback(data);
                this.unSubscribe(event);
            };
        }
        this.events[event].push(cb);
    },
    unSubscribe(event, callback) {
        if (!callback) {
            delete this.events[event];
            return;
        }
        if (!this.events[event]) {
            return;
        }
        this.events[event] = this.events[event].filter(cb => cb !== callback);
    }
};

const defaultVisitorId = () => generateUUID().replace(/-/g, '');

const modalStore = zustand.createStore(set => ({
    modalProps: {},
    openModal: (modalProps) => set({
        modalProps: Object.assign(Object.assign({}, modalProps), { onOk: (sign) => {
                var _a;
                (_a = modalProps.onOk) === null || _a === void 0 ? void 0 : _a.call(modalProps, sign);
                set({ modalProps: {} });
            }, onCancel: () => {
                var _a;
                (_a = modalProps.onCancel) === null || _a === void 0 ? void 0 : _a.call(modalProps);
                set({ modalProps: { open: false } });
            } })
    })
}));
const openModal = modalStore.getState().openModal;

const CaptchaTriggerMap = {
    '/v1/shell_coins/exchange_shell_coin_with_season_points': 'Redemption',
    '/v1/shell_coins/exchange_shell_coin_with_badges': 'Redemption',
    '/v1/season/task/claim': 'ClaimTask',
    '/v1/season/task/claim_all_last_season_points': 'ClaimTask',
    '/v1/season/task/claim_all': 'ClaimTask',
    '/v2/season/task/claim_all': 'ClaimTask',
    '/v1/bot/chat/send_message': 'SendMessage',
    '/v2/season/reward/redeem': 'Redemption',
    '/v1/season/reward/auto_redeem_and_use_season_pass_if_needed': 'ClaimPremiumCard'
};
process.env.NEXT_PUBLIC_BSC_EXPLORE_URL;
process.env.NEXT_PUBLIC_SHOW_BNB_BALANCE;
process.env.NEXT_PUBLIC_ENV === 'production' ? chains.bsc.id : chains.bscTestnet.id;
var SupportedChain;
(function (SupportedChain) {
    SupportedChain["Ethereum"] = "Ethereum";
    SupportedChain["BSC"] = "BSC";
    SupportedChain["OpBNB"] = "opBNB";
    SupportedChain["MyShell_Mainnet"] = "MyShell Mainnet";
    SupportedChain["MyShell_Testnet"] = "MyShell Testnet";
    SupportedChain["Base"] = "Base";
    SupportedChain["USDC"] = "Ethereum";
    SupportedChain["USDT"] = "Ethereum";
})(SupportedChain || (SupportedChain = {}));
var WalletLabel;
(function (WalletLabel) {
    WalletLabel["Metamask"] = "Metamask";
    WalletLabel["OKX"] = "OKX Web3 Wallet";
    WalletLabel["WalletConnect"] = "Wallet Connect";
    WalletLabel["BSC"] = "Binance Web3 Wallet";
    WalletLabel["RABBY"] = "Rabby Wallet";
})(WalletLabel || (WalletLabel = {}));
({
    [chains.mainnet.id]: SupportedChain.Ethereum,
    [chains.bsc.id]: SupportedChain.BSC,
    [chains.bscTestnet.id]: SupportedChain.BSC,
    [chains.opBNB.id]: SupportedChain.OpBNB
});
({
    [SupportedChain.Ethereum]: 'ETH',
    [SupportedChain.BSC]: 'BNB',
    [SupportedChain.OpBNB]: 'BNB',
    [SupportedChain.MyShell_Mainnet]: 'ETH',
    [SupportedChain.MyShell_Testnet]: 'ETH'
});
({
    [SupportedChain.Ethereum]: getAssetsUrl('image/web3/20241022/eth.svg'),
    [SupportedChain.BSC]: getAssetsUrl('image/web3/20241022/bnb.svg'),
    [SupportedChain.OpBNB]: getAssetsUrl('image/web3/20241022/bnb.svg'),
    [SupportedChain.MyShell_Mainnet]: getAssetsUrl('image/web3/20241022/myshell_mainnet.svg'),
    [SupportedChain.MyShell_Testnet]: getAssetsUrl('image/web3/20241022/myshell_mainnet.svg'),
    [SupportedChain.Base]: getAssetsUrl('image/web3/20241022/base.svg')
});

class StandaloneSensors {
    constructor() { }
    track(eventName, eventProps) {
        var _a;
        (_a = window === null || window === void 0 ? void 0 : window.sensors) === null || _a === void 0 ? void 0 : _a.track(eventName, Object.assign({}, (eventProps || {})));
    }
    setOnceProfile(props) {
        window === null || window === void 0 ? void 0 : window.sensors.setOnceProfile(Object.assign({}, (props || {})));
    }
    setProfile(props) {
        window === null || window === void 0 ? void 0 : window.sensors.setProfile(Object.assign({}, (props || {})));
    }
    login(userId) {
        window === null || window === void 0 ? void 0 : window.sensors.login(userId);
    }
}

const sensors = new StandaloneSensors();
const getNeteaseRequestToken = async () => {
    sensors === null || sensors === void 0 ? void 0 : sensors.track('ReadyForYiDunToken');
    const startAt = new Date().valueOf();
    try {
        const neg = createNEGuardian({ appId: NETEASE_ENGINE_APP_ID, timeout: 10000 });
        const { code, token } = await neg.getToken();
        const endAt = new Date().valueOf();
        const timeDiff = endAt - startAt;
        sensors === null || sensors === void 0 ? void 0 : sensors.track('ObtainYiDunToken', {
            result: code === 200 || code === 201,
            time_spent: timeDiff
        });
        if (code === 200 || code === 201) {
            return token;
        }
        else {
            throw new Error('getNeteaseEngineToken Error');
        }
    }
    catch (e) {
        const endAt = new Date().valueOf();
        const timeDiff = endAt - startAt;
        sensors === null || sensors === void 0 ? void 0 : sensors.track('ObtainYiDunToken', {
            result: false,
            time_spent: timeDiff
        });
        console.error(e);
        throw new Error('getNeteaseEngineToken Error');
    }
};

var __rest$y = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const LangMap = {
    en: 'en',
    zh: 'zh-CN',
    'zh-tw': 'zh-TW',
    es: 'es',
    jp: 'ja',
    ru: 'ru',
    ko: 'ko'
};
const baseURL$1 = `${API_URL}`;
const getTokenFromCookie = () => {
    const allCookies = typeof document !== 'undefined' ? document.cookie : '';
    const matched = allCookies.match(/(^|;\s*)token=([^;]+)/);
    return (matched && (matched === null || matched === void 0 ? void 0 : matched[2]));
};
const getCommonHeaders = async (opt) => {
    var _a, _b, _c, _d;
    const { isGoLang, allowAnonymous, withMyShellSecurityToken, serverContext } = opt;
    const headers = {};
    if (isGoLang) {
        headers['myshell-service-name'] = 'organics-api';
    }
    if (isClient() && !allowAnonymous) {
        const token = identityService.getToken();
        if (token) {
            headers.Authorization = `Bearer ${token}`;
            if (getTokenFromCookie() !== token) {
                document.cookie = `token=${token}; path=/; max-age=259200`;
            }
        }
        else {
            document.cookie = 'token=; path=/; max-age=0';
            const { visitorId } = Global;
            if (visitorId) {
                headers['visitor-id'] = visitorId;
            }
            const nanoAnonymousId = defaultVisitorId();
            let scDeviceId = identityService.getSCDeviceId();
            if (!scDeviceId) {
                const anonymousId = identityService.getAnonymousId();
                if (anonymousId) {
                    scDeviceId = anonymousId;
                }
                else {
                    identityService.setAnonymousId(nanoAnonymousId);
                    scDeviceId = nanoAnonymousId;
                }
                headers['sc-device-id'] = scDeviceId;
            }
            else if (scDeviceId && scDeviceId.trim()) {
                headers['sc-cookie-id'] = scDeviceId;
            }
        }
    }
    if (isClient() && withMyShellSecurityToken) {
        try {
            const neteaseEngineToken = await getNeteaseRequestToken();
            headers['myshell-security-token'] = neteaseEngineToken;
        }
        catch (e) {
        }
    }
    if (!isClient()) {
        headers['x-call-from'] = 'myshell-ssr';
        if (!headers.Authorization) {
            const token = (_b = (_a = serverContext === null || serverContext === void 0 ? void 0 : serverContext.cookies) === null || _a === void 0 ? void 0 : _a.get('token')) === null || _b === void 0 ? void 0 : _b.value;
            if (token) {
                headers.Authorization = `Bearer ${token}`;
            }
        }
        if (!headers.Authorization) {
            if (!headers['sc-device-id']) {
                headers['sc-device-id'] = 'node-server';
            }
            if (!headers['visitor-id']) {
                headers['visitor-id'] = (_c = serverContext === null || serverContext === void 0 ? void 0 : serverContext.headers) === null || _c === void 0 ? void 0 : _c.get('x-visitor');
            }
        }
    }
    headers.platform = 'web';
    headers.version = '1.0.0';
    const lang = (isClient() ? Global.language : (_d = serverContext === null || serverContext === void 0 ? void 0 : serverContext.headers) === null || _d === void 0 ? void 0 : _d.get('x-locale')) || 'en';
    headers['Accept-Language'] = LangMap[lang];
    headers['myshell-client-version'] = 'v1.6.4';
    headers.timestamp = computeChecksum1226(new Date().getTime());
    return headers;
};
const handleFetch = async (url, request) => {
    var _a, _b, _c, _d, _e;
    const urlBody = `${baseURL$1}${url}`;
    const { body, adapter, isGoLang, hideErrorToast, withMyShellSecurityToken, allowAnonymous, timeout, serverContext, params, signal, headers } = request, rest = __rest$y(request, ["body", "adapter", "isGoLang", "hideErrorToast", "withMyShellSecurityToken", "allowAnonymous", "timeout", "serverContext", "params", "signal", "headers"]);
    const requestUrl = (request === null || request === void 0 ? void 0 : request.params) ? `${urlBody}${params}` : `${urlBody}`;
    const requestBody = body ? (body instanceof FormData ? { body } : { body: JSON.stringify(body) }) : {};
    const commonHeaders = await getCommonHeaders({
        isGoLang,
        withMyShellSecurityToken,
        allowAnonymous,
        serverContext
    });
    const requestHeaders = Object.assign(Object.assign({}, (headers || (body && body instanceof FormData ? {} : { 'Content-Type': 'application/json' }))), commonHeaders);
    const delay = timeout || (typeof window !== 'undefined' ? 15000 : 5000);
    const controller = new AbortController();
    const finalSignal = signal || (delay ? controller.signal : undefined);
    let response;
    try {
        if (delay) {
            setTimeout(() => controller.abort(), delay);
        }
        response = await fetch(requestUrl, Object.assign(Object.assign(Object.assign({}, requestBody), rest), { headers: requestHeaders, credentials: 'include', signal: finalSignal, cache: 'no-store' }));
        const contentType = response.headers.get('content-type');
        const contentDisposition = response.headers.get('content-disposition');
        const result = contentType && (contentType.indexOf('application/json') !== -1 || contentType.indexOf('text/plain') !== -1)
            ? await response.json()
            : (contentDisposition === null || contentDisposition === void 0 ? void 0 : contentDisposition.indexOf('attachment')) !== -1
                ? await response.blob()
                : response;
        if (response.status >= 200 && response.status < 300) {
            if (typeof window !== 'undefined') {
                const token = identityService.getToken();
                const resToken = response.headers.get('refreshed-auth-token');
                if (resToken && resToken !== token) {
                    identityService.setToken(resToken);
                }
            }
            const data = typeof adapter === 'function' ? adapter(result) : result;
            return { success: true, data };
        }
        if (response.status === 400 && result.reason === 'ERROR_REASON_SAFETY_NEED_VERIFY_CAPTCHA') {
            if (isClient()) {
                await new Promise(resolve => openModal({ open: true, onOk: () => resolve(), triggerScene: CaptchaTriggerMap[url] }));
            }
            return await handleFetch(url, request);
        }
        if (response.status === 400 && !hideErrorToast) {
            if (isClient()) {
                const { Message } = await Promise.resolve().then(function () { return useNotification$1; });
                Message.error({
                    content: result.message,
                    translateInToast: true,
                    id: 'request-400'
                });
            }
            throw { status: response.status, data: Object.assign(Object.assign({}, result), { reason: 'request-400' }), message: result.message };
        }
        else {
            if (response.status === 429) {
                if (isClient()) {
                    const { Message } = await Promise.resolve().then(function () { return useNotification$1; });
                    Message.error({
                        content: 'request.error.rateLimit',
                        translateInToast: true,
                        id: 'request-429'
                    });
                }
            }
            if (response.status === 403) {
                if (isClient()) {
                    const cfMitigated = response.headers.get('cf-mitigated');
                    CfMitigatedHandler(cfMitigated);
                }
            }
            if (response.status === 401) {
                if (isClient()) {
                    EventEmitter.dispatch('Unauthorized', null);
                }
            }
            throw { status: response.status, data: result };
        }
    }
    catch (error) {
        const err = JSON.stringify({
            url: requestUrl,
            message: (error === null || error === void 0 ? void 0 : error.message) ? error === null || error === void 0 ? void 0 : error.message : error,
            status: response === null || response === void 0 ? void 0 : response.status,
            requestId: (_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a.get('organics-request-id'),
            headers: requestHeaders,
            vid: isClient() ? Global.visitorId : (_b = serverContext === null || serverContext === void 0 ? void 0 : serverContext.headers) === null || _b === void 0 ? void 0 : _b.get('x-visitor'),
            reason: error === null || error === void 0 ? void 0 : error.reason
        });
        console.error(err);
        let msg = (error === null || error === void 0 ? void 0 : error.message) || error;
        if (error === null || error === void 0 ? void 0 : error.data) {
            if (Array.isArray(error === null || error === void 0 ? void 0 : error.data.message)) {
                msg = error.data.message.join('; ');
            }
            else {
                msg = error.data.message;
            }
        }
        return {
            success: false,
            msg,
            reason: ((_c = error === null || error === void 0 ? void 0 : error.data) === null || _c === void 0 ? void 0 : _c.reason) || ((_d = error === null || error === void 0 ? void 0 : error.data) === null || _d === void 0 ? void 0 : _d.message),
            metadata: (_e = error === null || error === void 0 ? void 0 : error.data) === null || _e === void 0 ? void 0 : _e.metadata,
            status: error.status
        };
    }
};
const APIFetch = {
    get: async (url, request) => {
        return handleFetch(url, Object.assign(Object.assign({}, request), { method: 'GET' }));
    },
    post: async (url, request) => {
        return handleFetch(url, Object.assign(Object.assign({}, request), { method: 'POST' }));
    },
    put: async (url, request) => {
        return handleFetch(url, Object.assign(Object.assign({}, request), { method: 'PUT' }));
    },
    patch: async (url, request) => {
        return handleFetch(url, Object.assign(Object.assign({}, request), { method: 'PATCH' }));
    },
    delete: async (url, request) => {
        return handleFetch(url, Object.assign(Object.assign({}, request), { method: 'DELETE' }));
    }
};

const baseURL = `${API_URL}`;
const axiosClient = axios__default.default.create({
    baseURL
});
async function getConfig(config) {
    const commonHeaders = await getCommonHeaders({
        isGoLang: config === null || config === void 0 ? void 0 : config.isGoLang,
        allowAnonymous: config === null || config === void 0 ? void 0 : config.allowAnonymous,
        withMyShellSecurityToken: config === null || config === void 0 ? void 0 : config.withMyShellSecurityToken,
    });
    const mergedConfig = {
        timeout: (config === null || config === void 0 ? void 0 : config.timeout) || 15000,
        headers: Object.assign({ 'Content-Type': 'application/json' }, commonHeaders),
        withCredentials: true
    };
    return mergedConfig;
}
const rxPost = (url, data, config) => {
    const source = axios__default.default.CancelToken.source();
    const requestUrl = url;
    return rxjs.from(getConfig(config)).pipe(rxjs.mergeMap(mergedConfig => createObservable(axiosClient.post(`${requestUrl}`, data, Object.assign({ cancelToken: source.token }, mergedConfig)), source)));
};
const createObservable = (prom, source, config) => {
    return new rxjs.Observable(subscriber => {
        prom
            .then(req => {
            subscriber.next(req);
        })
            .catch(err => {
            if (axios__default.default.isCancel(err)) ;
            else {
                subscriber.error(err);
            }
        })
            .finally(() => {
            subscriber.complete();
        });
        return () => {
            source.cancel();
        };
    }).pipe(rxjs.mergeMap(res => {
        return handleResponse(res);
    }), rxjs.catchError((err) => handleError(err)));
};
const handleResponse = (res, config) => {
    if (res.status >= axios.HttpStatusCode.Ok && res.status < axios.HttpStatusCode.MultipleChoices) {
        return rxjs.of(res.data);
    }
    return rxjs.throwError(() => res);
};
const handleError = (err, config) => {
    var _a, _b;
    err.message = JSON.stringify({
        url: (_a = err === null || err === void 0 ? void 0 : err.config) === null || _a === void 0 ? void 0 : _a.url,
        message: err === null || err === void 0 ? void 0 : err.message,
        headers: err === null || err === void 0 ? void 0 : err.config.headers,
        response: err === null || err === void 0 ? void 0 : err.response
    });
    if ((_b = err === null || err === void 0 ? void 0 : err.response) === null || _b === void 0 ? void 0 : _b.status) {
        const { status, headers } = err.response;
        const { data } = err.response;
        if (status < axios.HttpStatusCode.Ok) ;
        else if (status === axios.HttpStatusCode.Ok) {
            data === null || data === void 0 ? void 0 : data.message;
        }
        else if (status > axios.HttpStatusCode.Ok && status < axios.HttpStatusCode.MultipleChoices) ;
        else if (status === axios.HttpStatusCode.BadRequest) {
            console.log(data);
            if (data === null || data === void 0 ? void 0 : data.message) {
                if (Array.isArray(data.message)) {
                    data.message.join('; ');
                }
                else {
                    data.message;
                }
            }
        }
        else if (status === axios.HttpStatusCode.Unauthorized) {
            {
                EventEmitter.dispatch('Unauthorized', null);
            }
        }
        else if (status > axios.HttpStatusCode.BadRequest && status < axios.HttpStatusCode.InternalServerError) {
            if (status === axios.HttpStatusCode.TooManyRequests) ;
            else if (status === axios.HttpStatusCode.Forbidden) {
                const cfMitigated = headers['cf-mitigated'];
                CfMitigatedHandler(cfMitigated);
            }
            else ;
        }
        else ;
    }
    return rxjs.throwError(() => err);
};

var __rest$x = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function getUserProfile(props, serverContext) {
    const { userId, name, nameTag } = props || {};
    return APIFetch.post('/v1/user/get_info', {
        body: Object.assign(Object.assign(Object.assign({}, (userId && { userId })), (name && { name: decodeURIComponent(name) })), (nameTag && { nameTag: decodeURIComponent(nameTag) })),
        isGoLang: true,
        adapter: (res) => {
            var _a, _b, _c, _d;
            const user = res.userDetail || {};
            const summary = (user === null || user === void 0 ? void 0 : user.summary) || {};
            const membershipInfo = summary.membershipInfo || {};
            return {
                avatar: summary.avatar,
                email: summary.email,
                id: summary.id,
                isGenesisPasscard: membershipInfo.type === UserMembershipTypeEnum.TYPE_GENESIS_WITH_GENESIS_CARD,
                isNftAvatar: summary.isNftAvatar,
                isPasscard: membershipInfo.type === UserMembershipTypeEnum.TYPE_GENESIS_WITH_PASS_CARD,
                level: membershipInfo.type === UserMembershipTypeEnum.TYPE_GENESIS_WITH_GENESIS_CARD ||
                    membershipInfo.type === UserMembershipTypeEnum.TYPE_GENESIS_WITH_PASS_CARD
                    ? 3
                    : membershipInfo.type === UserMembershipTypeEnum.TYPE_PREMIUM
                        ? 2
                        : 1,
                name: summary.name,
                nameTag: summary.nameTag,
                createdDate: summary.userCreatedAt
                    ? dayjs__default.default(Number(summary.userCreatedAt)).format('YYYY-MM-DDTHH:mm:ssZ')
                    : undefined,
                createdTime: summary.userCreatedAt
                    ? dayjs__default.default(Number(summary.userCreatedAt)).format('YYYY-MM-DD HH:mm:ss.SSS')
                    : undefined,
                publicAddress: summary.publicAddress,
                source: summary.userSource,
                hasParticleAccount: user.hasParticleAccount,
                privateBotLimit: membershipInfo.privateBotLimit,
                publicBotLimit: membershipInfo.publicBotLimit,
                premiumInfo: {
                    level: (_a = membershipInfo.premiumInfo) === null || _a === void 0 ? void 0 : _a.level,
                    totalExp: (_b = membershipInfo.premiumInfo) === null || _b === void 0 ? void 0 : _b.totalExp,
                    nextLevelNeedExp: (_c = membershipInfo.premiumInfo) === null || _c === void 0 ? void 0 : _c.nextLevelNeedExp,
                    currentLevelExp: (_d = membershipInfo.premiumInfo) === null || _d === void 0 ? void 0 : _d.currentLevelExp
                },
                canPublishNewBot: user.canPublishNewBot,
                connectInfo: user.connectInfo,
                followedCount: summary.followedCount,
                fansCount: summary.fansCount,
                hasFollowed: summary.hasFollowed,
                followStatus: summary.followStatus,
                description: summary.description,
                backgroundUrl: summary.backgroundUrl,
                loginCredential: user.loginCredential,
                loginType: user.loginType,
                publicKey: user.publicKey
            };
        },
        serverContext
    });
}
function getUserEnergyInfo(userId) {
    return APIFetch.post('/v1/user/get_energy', {
        body: {
            userId
        },
        isGoLang: true,
        adapter: (res) => {
            return res.energyInfo;
        }
    });
}
function updateLanguage(language) {
    return rxPost('/user/updateLanguage', { language });
}
function getShellCoins() {
    return APIFetch.post('/v1/shell_coins/get_account', {
        isGoLang: true,
        adapter: (res) => {
            return res.account;
        }
    });
}
function claimAndUseSeasonPass() {
    return APIFetch.post('/v1/season/reward/auto_redeem_and_use_season_pass_if_needed', {
        isGoLang: true,
        withMyShellSecurityToken: true,
        adapter: (res) => {
            return res.item;
        }
    });
}
function getCoinRecords(pageToken, pageSize) {
    return APIFetch.post('/v1/shell_coins/list_account_orders', {
        body: {
            listRequest: {
                pageToken,
                pageSize
            }
        },
        isGoLang: true
    });
}
function setUserFollow(targetUserId, followed) {
    return APIFetch.post('/v1/user/follow', {
        body: {
            targetUserId,
            followed
        },
        isGoLang: true
    });
}
function getWidgetsByUser(userId) {
    return APIFetch.post('/v1/widget/list_user_public_widgets', {
        body: {
            userId
        },
        isGoLang: true,
        adapter: (res) => {
            return {
                widgets: res.widgets.map(widget => {
                    var _a, _b;
                    return (Object.assign(Object.assign({}, widget), { imComponent: Object.assign(Object.assign({}, widget.imComponent), { componentsInput: (_b = (_a = widget.imComponent) === null || _a === void 0 ? void 0 : _a.componentsInput) === null || _b === void 0 ? void 0 : _b.map((item) => {
                                var _a, _b;
                                let inputType = '';
                                let defaultValue = '';
                                let options = [];
                                const props = {};
                                let supportedFileTypes = [];
                                switch (item.type) {
                                    case 'BOT_IM_COMPONENT_INPUT_TYPE_FILE_UPLOAD':
                                        inputType = 'upload';
                                        supportedFileTypes = item.supportedFileTypes;
                                        break;
                                    case 'BOT_IM_COMPONENT_INPUT_TYPE_AUDIO_UPLOAD':
                                        inputType = 'upload';
                                        supportedFileTypes = ['MESSAGE_METADATA_TYPE_AUDIO_FILE'];
                                        break;
                                    case 'BOT_IM_COMPONENT_INPUT_TYPE_VIDEO_UPLOAD':
                                        inputType = 'upload';
                                        supportedFileTypes = ['MESSAGE_METADATA_TYPE_VIDEO_FILE'];
                                        break;
                                    case 'BOT_IM_COMPONENT_INPUT_TYPE_IMAGE_UPLOAD':
                                        inputType = 'upload';
                                        supportedFileTypes = ['MESSAGE_METADATA_TYPE_IMAGE_FILE'];
                                        break;
                                    case 'BOT_IM_COMPONENT_INPUT_TYPE_TEXT_UPLOAD':
                                        inputType = 'upload';
                                        supportedFileTypes = ['MESSAGE_METADATA_TYPE_TEXT_FILE'];
                                        break;
                                    case 'BOT_IM_COMPONENT_INPUT_TYPE_TEXT_INPUT':
                                        inputType = 'textarea';
                                        defaultValue = item.stringDefault;
                                        break;
                                    case 'BOT_IM_COMPONENT_INPUT_TYPE_TEXT_SELECTOR':
                                        inputType = 'select';
                                        defaultValue = item.textSelectorDefault;
                                        options = (_a = item.textSelectorAllOf) === null || _a === void 0 ? void 0 : _a.map((e) => {
                                            return {
                                                label: e.label || e.value,
                                                value: e.value,
                                                iconUrl: e.iconUrl
                                            };
                                        });
                                        break;
                                    case 'BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_INPUT':
                                        inputType = item.hasNumberLimitation ? 'numberSlider' : 'numberInput';
                                        defaultValue = item.numberDefault;
                                        props.maxLength = item.numberMax;
                                        props.minLength = item.numberMin;
                                        break;
                                    case 'BOT_IM_COMPONENT_INPUT_TYPE_INTEGER_INPUT':
                                        inputType = item.hasIntegerLimitation ? 'interSlider' : 'interInput';
                                        defaultValue = item.integerDefault;
                                        props.maxLength = item.integerMax;
                                        props.minLength = item.integerMin;
                                        break;
                                    case 'BOT_IM_COMPONENT_INPUT_TYPE_CHECKBOX':
                                        inputType = 'checkbox';
                                        defaultValue = item.booleanDefault;
                                        break;
                                    case 'BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_SELECTOR':
                                        inputType = 'numberSelect';
                                        defaultValue = item.numberSelectorDefault;
                                        options = (_b = item.numberSelectorAllOf) === null || _b === void 0 ? void 0 : _b.map((e) => {
                                            return {
                                                label: e.label || e.value,
                                                value: e.value,
                                                iconUrl: e.iconUrl
                                            };
                                        });
                                        break;
                                    case 'BOT_IM_COMPONENT_INPUT_TYPE_CODE_EDITOR':
                                        inputType = 'codeEditor';
                                        defaultValue = item.stringDefault;
                                        break;
                                }
                                return Object.assign(Object.assign({}, item), { id: item.fieldName, serverType: item.type, props, rules: props, type: inputType, defaultValue,
                                    options,
                                    supportedFileTypes });
                            }) }) }));
                })
            };
        }
    });
}
function getBotsByUser(userId) {
    return APIFetch.post('/v1/bot/list_user_public_bots', {
        body: {
            userId
        },
        isGoLang: true,
        adapter: (res) => {
            var _a;
            return ((_a = res === null || res === void 0 ? void 0 : res.bots) !== null && _a !== void 0 ? _a : []).map((d) => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                const { lastMessage = {}, latestInteractionDateUnix, canEditBot, inChatList, photos, pinned, summary = {}, setting = {}, unreadMessageCount, visitorCanChat, widgets } = d;
                const _j = summary || {}, { backgroundImageThemeHexColors } = _j, sRest = __rest$x(_j, ["backgroundImageThemeHexColors"]);
                const data = Object.assign(Object.assign({ canEditBot,
                    pinned,
                    inChatList,
                    photos, official: summary === null || summary === void 0 ? void 0 : summary.isOfficial, nsfw: (_a = summary === null || summary === void 0 ? void 0 : summary.tagList) === null || _a === void 0 ? void 0 : _a.some((tag) => tag.id === '1800000000000000019'), userId: Number(((_b = summary === null || summary === void 0 ? void 0 : summary.author) === null || _b === void 0 ? void 0 : _b.id) || 0), lastMessage: lastMessage
                        ? Object.assign(Object.assign({}, lastMessage), { createdDate: Number(lastMessage === null || lastMessage === void 0 ? void 0 : lastMessage.createdDateUnix), updatedDate: Number(lastMessage === null || lastMessage === void 0 ? void 0 : lastMessage.updatedDateUnix) }) : null }, (sRest || {})), { createdDate: summary === null || summary === void 0 ? void 0 : summary.createdDateUnix, updatedDate: summary === null || summary === void 0 ? void 0 : summary.updatedDateUnix, botSetting: setting, language: (_d = (_c = summary === null || summary === void 0 ? void 0 : summary.language) === null || _c === void 0 ? void 0 : _c.name) !== null && _d !== void 0 ? _d : 'English', unreadMessageCount, privateBotId: Number((summary === null || summary === void 0 ? void 0 : summary.privateBotId) || 0), lastInteractionDate: Number(latestInteractionDateUnix || 0), schemes: (_e = backgroundImageThemeHexColors === null || backgroundImageThemeHexColors === void 0 ? void 0 : backgroundImageThemeHexColors.schemes) !== null && _e !== void 0 ? _e : null, visitorCanChat, isImageBot: (summary === null || summary === void 0 ? void 0 : summary.botGenType) === 'BOT_GEN_TYPE_IMAGE' || (summary === null || summary === void 0 ? void 0 : summary.botGenType) === 'BOT_GEN_TYPE_GIF', membershipChatConfig: (_f = summary === null || summary === void 0 ? void 0 : summary.membershipChatConfig) !== null && _f !== void 0 ? _f : {}, stakingDisabled: summary === null || summary === void 0 ? void 0 : summary.stakingDisabled, isPanelImageBot: (summary === null || summary === void 0 ? void 0 : summary.chatPanelType) === 'BOT_CHAT_PANEL_TYPE_COMPONENT', isComponentBot: (summary === null || summary === void 0 ? void 0 : summary.chatPanelType) === 'BOT_CHAT_PANEL_TYPE_COMPONENT', imComponent: Object.assign(Object.assign({}, summary === null || summary === void 0 ? void 0 : summary.imComponent), { componentsInput: (_h = (_g = summary === null || summary === void 0 ? void 0 : summary.imComponent) === null || _g === void 0 ? void 0 : _g.componentsInput) === null || _h === void 0 ? void 0 : _h.map((item) => {
                            var _a, _b;
                            let inputType = '';
                            let defaultValue = '';
                            let options = [];
                            const props = {};
                            let supportedFileTypes = [];
                            switch (item.type) {
                                case 'BOT_IM_COMPONENT_INPUT_TYPE_FILE_UPLOAD':
                                    inputType = 'upload';
                                    supportedFileTypes = item.supportedFileTypes;
                                    break;
                                case 'BOT_IM_COMPONENT_INPUT_TYPE_AUDIO_UPLOAD':
                                    inputType = 'upload';
                                    supportedFileTypes = ['MESSAGE_METADATA_TYPE_AUDIO_FILE'];
                                    break;
                                case 'BOT_IM_COMPONENT_INPUT_TYPE_VIDEO_UPLOAD':
                                    inputType = 'upload';
                                    supportedFileTypes = ['MESSAGE_METADATA_TYPE_VIDEO_FILE'];
                                    break;
                                case 'BOT_IM_COMPONENT_INPUT_TYPE_IMAGE_UPLOAD':
                                    inputType = 'upload';
                                    supportedFileTypes = ['MESSAGE_METADATA_TYPE_IMAGE_FILE'];
                                    break;
                                case 'BOT_IM_COMPONENT_INPUT_TYPE_TEXT_UPLOAD':
                                    inputType = 'upload';
                                    supportedFileTypes = ['MESSAGE_METADATA_TYPE_TEXT_FILE'];
                                    break;
                                case 'BOT_IM_COMPONENT_INPUT_TYPE_TEXT_INPUT':
                                    inputType = 'textarea';
                                    defaultValue = item.stringDefault;
                                    break;
                                case 'BOT_IM_COMPONENT_INPUT_TYPE_TEXT_SELECTOR':
                                    inputType = 'select';
                                    defaultValue = item.textSelectorDefault;
                                    options = (_a = item.textSelectorAllOf) === null || _a === void 0 ? void 0 : _a.map((e) => {
                                        return {
                                            label: e.label || e.value,
                                            value: e.value,
                                            iconUrl: e.iconUrl
                                        };
                                    });
                                    break;
                                case 'BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_INPUT':
                                    inputType = item.hasNumberLimitation ? 'numberSlider' : 'numberInput';
                                    defaultValue = item.numberDefault;
                                    props.maxLength = item.numberMax;
                                    props.minLength = item.numberMin;
                                    break;
                                case 'BOT_IM_COMPONENT_INPUT_TYPE_INTEGER_INPUT':
                                    inputType = item.hasIntegerLimitation ? 'interSlider' : 'interInput';
                                    defaultValue = item.integerDefault;
                                    props.maxLength = item.integerMax;
                                    props.minLength = item.integerMin;
                                    break;
                                case 'BOT_IM_COMPONENT_INPUT_TYPE_CHECKBOX':
                                    inputType = 'checkbox';
                                    defaultValue = item.booleanDefault;
                                    break;
                                case 'BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_SELECTOR':
                                    inputType = 'numberSelect';
                                    defaultValue = item.numberSelectorDefault;
                                    options = (_b = item.numberSelectorAllOf) === null || _b === void 0 ? void 0 : _b.map((e) => {
                                        return {
                                            label: e.label || e.value,
                                            value: e.value,
                                            iconUrl: e.iconUrl
                                        };
                                    });
                                    break;
                                case 'BOT_IM_COMPONENT_INPUT_TYPE_CODE_EDITOR':
                                    inputType = 'codeEditor';
                                    defaultValue = item.stringDefault;
                                    break;
                            }
                            return Object.assign(Object.assign({}, item), { id: item.fieldName, serverType: item.type, props, rules: props, type: inputType, defaultValue,
                                options,
                                supportedFileTypes });
                        }) }), widgets });
                return data;
            });
        }
    });
}
function getInvitation() {
    return APIFetch.post('/v1/user/invitation/get_invitation', {
        isGoLang: true
    });
}
function updateUserSettings(data) {
    return APIFetch.post('/v1/user/update_user_settings', {
        isGoLang: true,
        body: {
            settings: Array.isArray(data) ? data : [data]
        }
    });
}
function getUserSettings() {
    return APIFetch.post('/v1/user/get_user_settings', {
        isGoLang: true,
        adapter: res => {
            return res.settings;
        }
    });
}

function ArrowDownTrayIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"
  }));
}
const ForwardRef$T = /*#__PURE__*/ React__namespace.forwardRef(ArrowDownTrayIcon);

function ArrowDownIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M19.5 13.5 12 21m0 0-7.5-7.5M12 21V3"
  }));
}
const ForwardRef$S = /*#__PURE__*/ React__namespace.forwardRef(ArrowDownIcon);

function ArrowLeftIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M10.5 19.5 3 12m0 0 7.5-7.5M3 12h18"
  }));
}
const ForwardRef$R = /*#__PURE__*/ React__namespace.forwardRef(ArrowLeftIcon$1);

function ArrowPathIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99"
  }));
}
const ForwardRef$Q = /*#__PURE__*/ React__namespace.forwardRef(ArrowPathIcon$1);

function ArrowRightIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M13.5 4.5 21 12m0 0-7.5 7.5M21 12H3"
  }));
}
const ForwardRef$P = /*#__PURE__*/ React__namespace.forwardRef(ArrowRightIcon);

function ArrowUpOnSquareIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M9 8.25H7.5a2.25 2.25 0 0 0-2.25 2.25v9a2.25 2.25 0 0 0 2.25 2.25h9a2.25 2.25 0 0 0 2.25-2.25v-9a2.25 2.25 0 0 0-2.25-2.25H15m0-3-3-3m0 0-3 3m3-3V15"
  }));
}
const ForwardRef$O = /*#__PURE__*/ React__namespace.forwardRef(ArrowUpOnSquareIcon);

function ArrowUpTrayIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5"
  }));
}
const ForwardRef$N = /*#__PURE__*/ React__namespace.forwardRef(ArrowUpTrayIcon);

function ArrowUpIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M4.5 10.5 12 3m0 0 7.5 7.5M12 3v18"
  }));
}
const ForwardRef$M = /*#__PURE__*/ React__namespace.forwardRef(ArrowUpIcon);

function Bars3Icon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"
  }));
}
const ForwardRef$L = /*#__PURE__*/ React__namespace.forwardRef(Bars3Icon);

function CheckCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
  }));
}
const ForwardRef$K = /*#__PURE__*/ React__namespace.forwardRef(CheckCircleIcon);

function CheckIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m4.5 12.75 6 6 9-13.5"
  }));
}
const ForwardRef$J = /*#__PURE__*/ React__namespace.forwardRef(CheckIcon$1);

function ChevronLeftIcon$2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15.75 19.5 8.25 12l7.5-7.5"
  }));
}
const ForwardRef$I = /*#__PURE__*/ React__namespace.forwardRef(ChevronLeftIcon$2);

function ChevronRightIcon$2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m8.25 4.5 7.5 7.5-7.5 7.5"
  }));
}
const ForwardRef$H = /*#__PURE__*/ React__namespace.forwardRef(ChevronRightIcon$2);

function ChevronUpIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m4.5 15.75 7.5-7.5 7.5 7.5"
  }));
}
const ForwardRef$G = /*#__PURE__*/ React__namespace.forwardRef(ChevronUpIcon);

function DocumentDuplicateIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"
  }));
}
const ForwardRef$F = /*#__PURE__*/ React__namespace.forwardRef(DocumentDuplicateIcon);

function EllipsisHorizontalIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M6.75 12a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM12.75 12a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0ZM18.75 12a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0Z"
  }));
}
const ForwardRef$E = /*#__PURE__*/ React__namespace.forwardRef(EllipsisHorizontalIcon);

function ExclamationCircleIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 9v3.75m9-.75a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 3.75h.008v.008H12v-.008Z"
  }));
}
const ForwardRef$D = /*#__PURE__*/ React__namespace.forwardRef(ExclamationCircleIcon$1);

function ExclamationTriangleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"
  }));
}
const ForwardRef$C = /*#__PURE__*/ React__namespace.forwardRef(ExclamationTriangleIcon);

function EyeSlashIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M3.98 8.223A10.477 10.477 0 0 0 1.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.451 10.451 0 0 1 12 4.5c4.756 0 8.773 3.162 10.065 7.498a10.522 10.522 0 0 1-4.293 5.774M6.228 6.228 3 3m3.228 3.228 3.65 3.65m7.894 7.894L21 21m-3.228-3.228-3.65-3.65m0 0a3 3 0 1 0-4.243-4.243m4.242 4.242L9.88 9.88"
  }));
}
const ForwardRef$B = /*#__PURE__*/ React__namespace.forwardRef(EyeSlashIcon);

function HandThumbDownIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M7.498 15.25H4.372c-1.026 0-1.945-.694-2.054-1.715a12.137 12.137 0 0 1-.068-1.285c0-2.848.992-5.464 2.649-7.521C5.287 4.247 5.886 4 6.504 4h4.016a4.5 4.5 0 0 1 1.423.23l3.114 1.04a4.5 4.5 0 0 0 1.423.23h1.294M7.498 15.25c.618 0 .991.724.725 1.282A7.471 7.471 0 0 0 7.5 19.75 2.25 2.25 0 0 0 9.75 22a.75.75 0 0 0 .75-.75v-.633c0-.573.11-1.14.322-1.672.304-.76.93-1.33 1.653-1.715a9.04 9.04 0 0 0 2.86-2.4c.498-.634 1.226-1.08 2.032-1.08h.384m-10.253 1.5H9.7m8.075-9.75c.01.05.027.1.05.148.593 1.2.925 2.55.925 3.977 0 1.487-.36 2.89-.999 4.125m.023-8.25c-.076-.365.183-.75.575-.75h.908c.889 0 1.713.518 1.972 1.368.339 1.11.521 2.287.521 3.507 0 1.553-.295 3.036-.831 4.398-.306.774-1.086 1.227-1.918 1.227h-1.053c-.472 0-.745-.556-.5-.96a8.95 8.95 0 0 0 .303-.54"
  }));
}
const ForwardRef$A = /*#__PURE__*/ React__namespace.forwardRef(HandThumbDownIcon$1);

function HandThumbUpIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M6.633 10.25c.806 0 1.533-.446 2.031-1.08a9.041 9.041 0 0 1 2.861-2.4c.723-.384 1.35-.956 1.653-1.715a4.498 4.498 0 0 0 .322-1.672V2.75a.75.75 0 0 1 .75-.75 2.25 2.25 0 0 1 2.25 2.25c0 1.152-.26 2.243-.723 3.218-.266.558.107 1.282.725 1.282m0 0h3.126c1.026 0 1.945.694 2.054 1.715.045.422.068.85.068 1.285a11.95 11.95 0 0 1-2.649 7.521c-.388.482-.987.729-1.605.729H13.48c-.483 0-.964-.078-1.423-.23l-3.114-1.04a4.501 4.501 0 0 0-1.423-.23H5.904m10.598-9.75H14.25M5.904 18.5c.083.205.173.405.27.602.197.4-.078.898-.523.898h-.908c-.889 0-1.713-.518-1.972-1.368a12 12 0 0 1-.521-3.507c0-1.553.295-3.036.831-4.398C3.387 9.953 4.167 9.5 5 9.5h1.053c.472 0 .745.556.5.96a8.958 8.958 0 0 0-1.302 4.665c0 1.194.232 2.333.654 3.375Z"
  }));
}
const ForwardRef$z = /*#__PURE__*/ React__namespace.forwardRef(HandThumbUpIcon$1);

function LinkIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M13.19 8.688a4.5 4.5 0 0 1 1.242 7.244l-4.5 4.5a4.5 4.5 0 0 1-6.364-6.364l1.757-1.757m13.35-.622 1.757-1.757a4.5 4.5 0 0 0-6.364-6.364l-4.5 4.5a4.5 4.5 0 0 0 1.242 7.244"
  }));
}
const ForwardRef$y = /*#__PURE__*/ React__namespace.forwardRef(LinkIcon$1);

function MagnifyingGlassMinusIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM13.5 10.5h-6"
  }));
}
const ForwardRef$x = /*#__PURE__*/ React__namespace.forwardRef(MagnifyingGlassMinusIcon);

function MagnifyingGlassPlusIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607ZM10.5 7.5v6m3-3h-6"
  }));
}
const ForwardRef$w = /*#__PURE__*/ React__namespace.forwardRef(MagnifyingGlassPlusIcon);

function MicrophoneIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 18.75a6 6 0 0 0 6-6v-1.5m-6 7.5a6 6 0 0 1-6-6v-1.5m6 7.5v3.75m-3.75 0h7.5M12 15.75a3 3 0 0 1-3-3V4.5a3 3 0 1 1 6 0v8.25a3 3 0 0 1-3 3Z"
  }));
}
const ForwardRef$v = /*#__PURE__*/ React__namespace.forwardRef(MicrophoneIcon);

/** @deprecated */
function MinusSmallIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M18 12H6"
  }));
}
const ForwardRef$u = /*#__PURE__*/ React__namespace.forwardRef(MinusSmallIcon);

function NoSymbolIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M18.364 18.364A9 9 0 0 0 5.636 5.636m12.728 12.728A9 9 0 0 1 5.636 5.636m12.728 12.728L5.636 5.636"
  }));
}
const ForwardRef$t = /*#__PURE__*/ React__namespace.forwardRef(NoSymbolIcon);

function PaperClipIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m18.375 12.739-7.693 7.693a4.5 4.5 0 0 1-6.364-6.364l10.94-10.94A3 3 0 1 1 19.5 7.372L8.552 18.32m.009-.01-.01.01m5.699-9.941-7.81 7.81a1.5 1.5 0 0 0 2.112 2.13"
  }));
}
const ForwardRef$s = /*#__PURE__*/ React__namespace.forwardRef(PaperClipIcon);

function PauseIcon$2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15.75 5.25v13.5m-7.5-13.5v13.5"
  }));
}
const ForwardRef$r = /*#__PURE__*/ React__namespace.forwardRef(PauseIcon$2);

function PencilSquareIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10"
  }));
}
const ForwardRef$q = /*#__PURE__*/ React__namespace.forwardRef(PencilSquareIcon);

function PlayIcon$2({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.347a1.125 1.125 0 0 1 0 1.972l-11.54 6.347a1.125 1.125 0 0 1-1.667-.986V5.653Z"
  }));
}
const ForwardRef$p = /*#__PURE__*/ React__namespace.forwardRef(PlayIcon$2);

function PlusCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 9v6m3-3H9m12 0a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
  }));
}
const ForwardRef$o = /*#__PURE__*/ React__namespace.forwardRef(PlusCircleIcon);

/** @deprecated */
function PlusSmallIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M12 6v12m6-6H6"
  }));
}
const ForwardRef$n = /*#__PURE__*/ React__namespace.forwardRef(PlusSmallIcon);

function StopCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
  }), /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M9 9.563C9 9.252 9.252 9 9.563 9h4.874c.311 0 .563.252.563.563v4.874c0 .311-.252.563-.563.563H9.564A.562.562 0 0 1 9 14.437V9.564Z"
  }));
}
const ForwardRef$m = /*#__PURE__*/ React__namespace.forwardRef(StopCircleIcon);

function TrashIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0"
  }));
}
const ForwardRef$l = /*#__PURE__*/ React__namespace.forwardRef(TrashIcon);

function XCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m9.75 9.75 4.5 4.5m0-4.5-4.5 4.5M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z"
  }));
}
const ForwardRef$k = /*#__PURE__*/ React__namespace.forwardRef(XCircleIcon);

function XMarkIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M6 18 18 6M6 6l12 12"
  }));
}
const ForwardRef$j = /*#__PURE__*/ React__namespace.forwardRef(XMarkIcon$1);

function ExclamationCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12ZM12 8.25a.75.75 0 0 1 .75.75v3.75a.75.75 0 0 1-1.5 0V9a.75.75 0 0 1 .75-.75Zm0 8.25a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$i = /*#__PURE__*/ React__namespace.forwardRef(ExclamationCircleIcon);

function InformationCircleIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12Zm8.706-1.442c1.146-.573 2.437.463 2.126 1.706l-.709 2.836.042-.02a.75.75 0 0 1 .67 1.34l-.04.022c-1.147.573-2.438-.463-2.127-1.706l.71-2.836-.042.02a.75.75 0 1 1-.671-1.34l.041-.022ZM12 9a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$h = /*#__PURE__*/ React__namespace.forwardRef(InformationCircleIcon);

function cn(...inputs) {
    return tailwindMerge.twMerge(clsx.clsx(inputs));
}
function limitStringLength(str, limit) {
    if (str.length > limit) {
        return str.substring(0, limit) + '...';
    }
    else {
        return str;
    }
}

const trackedConnections = /* @__PURE__ */ new Map();
const getTrackedConnectionState = (name) => {
  const api = trackedConnections.get(name);
  if (!api) return {};
  return Object.fromEntries(
    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])
  );
};
const extractConnectionInformation = (store, extensionConnector, options) => {
  if (store === void 0) {
    return {
      type: "untracked",
      connection: extensionConnector.connect(options)
    };
  }
  const existingConnection = trackedConnections.get(options.name);
  if (existingConnection) {
    return { type: "tracked", store, ...existingConnection };
  }
  const newConnection = {
    connection: extensionConnector.connect(options),
    stores: {}
  };
  trackedConnections.set(options.name, newConnection);
  return { type: "tracked", store, ...newConnection };
};
const devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {
  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;
  let extensionConnector;
  try {
    extensionConnector = (enabled != null ? enabled : (undefined ? undefined.MODE : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch (e) {
  }
  if (!extensionConnector) {
    if ((undefined ? undefined.MODE : void 0) !== "production" && enabled) {
      console.warn(
        "[zustand devtools middleware] Please install/enable Redux devtools extension"
      );
    }
    return fn(set, get, api);
  }
  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);
  let isRecording = true;
  api.setState = (state, replace, nameOrAction) => {
    const r = set(state, replace);
    if (!isRecording) return r;
    const action = nameOrAction === void 0 ? { type: anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction;
    if (store === void 0) {
      connection == null ? void 0 : connection.send(action, get());
      return r;
    }
    connection == null ? void 0 : connection.send(
      {
        ...action,
        type: `${store}/${action.type}`
      },
      {
        ...getTrackedConnectionState(options.name),
        [store]: api.getState()
      }
    );
    return r;
  };
  const setStateFromDevtools = (...a) => {
    const originalIsRecording = isRecording;
    isRecording = false;
    set(...a);
    isRecording = originalIsRecording;
  };
  const initialState = fn(api.setState, get, api);
  if (connectionInformation.type === "untracked") {
    connection == null ? void 0 : connection.init(initialState);
  } else {
    connectionInformation.stores[connectionInformation.store] = api;
    connection == null ? void 0 : connection.init(
      Object.fromEntries(
        Object.entries(connectionInformation.stores).map(([key, store2]) => [
          key,
          key === connectionInformation.store ? initialState : store2.getState()
        ])
      )
    );
  }
  if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
    let didWarnAboutReservedActionType = false;
    const originalDispatch = api.dispatch;
    api.dispatch = (...a) => {
      if ((undefined ? undefined.MODE : void 0) !== "production" && a[0].type === "__setState" && !didWarnAboutReservedActionType) {
        console.warn(
          '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
        );
        didWarnAboutReservedActionType = true;
      }
      originalDispatch(...a);
    };
  }
  connection.subscribe((message) => {
    var _a;
    switch (message.type) {
      case "ACTION":
        if (typeof message.payload !== "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return parseJsonThen(
          message.payload,
          (action) => {
            if (action.type === "__setState") {
              if (store === void 0) {
                setStateFromDevtools(action.state);
                return;
              }
              if (Object.keys(action.state).length !== 1) {
                console.error(
                  `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
                );
              }
              const stateFromDevtools = action.state[store];
              if (stateFromDevtools === void 0 || stateFromDevtools === null) {
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {
                setStateFromDevtools(stateFromDevtools);
              }
              return;
            }
            if (!api.dispatchFromDevtools) return;
            if (typeof api.dispatch !== "function") return;
            api.dispatch(action);
          }
        );
      case "DISPATCH":
        switch (message.payload.type) {
          case "RESET":
            setStateFromDevtools(initialState);
            if (store === void 0) {
              return connection == null ? void 0 : connection.init(api.getState());
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "COMMIT":
            if (store === void 0) {
              connection == null ? void 0 : connection.init(api.getState());
              return;
            }
            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
          case "ROLLBACK":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                connection == null ? void 0 : connection.init(api.getState());
                return;
              }
              setStateFromDevtools(state[store]);
              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return parseJsonThen(message.state, (state) => {
              if (store === void 0) {
                setStateFromDevtools(state);
                return;
              }
              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {
                setStateFromDevtools(state[store]);
              }
            });
          case "IMPORT_STATE": {
            const { nextLiftedState } = message.payload;
            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;
            if (!lastComputedState) return;
            if (store === void 0) {
              setStateFromDevtools(lastComputedState);
            } else {
              setStateFromDevtools(lastComputedState[store]);
            }
            connection == null ? void 0 : connection.send(
              null,
              // FIXME no-any
              nextLiftedState
            );
            return;
          }
          case "PAUSE_RECORDING":
            return isRecording = !isRecording;
        }
        return;
    }
  });
  return initialState;
};
const devtools = devtoolsImpl;
const parseJsonThen = (stringified, f) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      e
    );
  }
  if (parsed !== void 0) f(parsed);
};

function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a;
      const parse = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, void 0 );
      };
      const str = (_a = storage.getItem(name)) != null ? _a : null;
      if (str instanceof Promise) {
        return str.then(parse);
      }
      return parse(str);
    },
    setItem: (name, newValue) => storage.setItem(
      name,
      JSON.stringify(newValue, void 0 )
    ),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
const toThenable = (fn) => (input) => {
  try {
    const result = fn(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e);
      }
    };
  }
};
const oldImpl = (config, baseOptions) => (set, get, api) => {
  let options = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage;
  try {
    storage = options.getStorage();
  } catch (e) {
  }
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const thenableSerialize = toThenable(options.serialize);
  const setItem = () => {
    const state = options.partialize({ ...get() });
    let errorInSync;
    const thenable = thenableSerialize({ state, version: options.version }).then(
      (serializedValue) => storage.setItem(options.name, serializedValue)
    ).catch((e) => {
      errorInSync = e;
    });
    if (errorInSync) {
      throw errorInSync;
    }
    return thenable;
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api
  );
  let stateFromStorage;
  const hydrate = () => {
    var _a;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => cb(get()));
    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
      if (storageValue) {
        return options.deserialize(storageValue);
      }
    }).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a2;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get()) != null ? _a2 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.getStorage) {
        storage = newOptions.getStorage();
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  hydrate();
  return stateFromStorage || configResult;
};
const newImpl = (config, baseOptions) => (set, get, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate = () => {
    var _a, _b;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => {
      var _a2;
      return cb((_a2 = get()) != null ? _a2 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(
              deserializedStorageValue.state,
              deserializedStorageValue.version
            );
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a2;
      stateFromStorage = options.merge(
        migratedState,
        (_a2 = get()) != null ? _a2 : configResult
      );
      set(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate();
  }
  return stateFromStorage || configResult;
};
const persistImpl = (config, baseOptions) => {
  if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
    if ((undefined ? undefined.MODE : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
      );
    }
    return oldImpl(config, baseOptions);
  }
  return newImpl(config, baseOptions);
};
const persist = persistImpl;

const immerImpl = (initializer) => (set, get, store) => {
  store.setState = (updater, replace, ...a) => {
    const nextState = typeof updater === "function" ? immer$1.produce(updater) : updater;
    return set(nextState, replace, ...a);
  };
  return initializer(store.setState, get, store);
};
const immer = immerImpl;

const DEFAULT_STATE$9 = {
    isMobile: false,
    isToInviteArea: false,
    isOpenLoginModal: false,
    cantCloseLogin: false,
    guiding: false,
    isOpenInviteCodeModal: false,
    showChatBotRecommend: false,
    inviteCodeStep: 1,
    loadingCount: 0,
    createAutoPromptTaskResult: null,
    noEnergyWithUsablePropModalVisible: false,
    onboarding: false,
    sumUnread: 0
};
const computeState$6 = (state) => ({
    isGlobalLoading: state.loadingCount > 0
});
const createGlobalStore = (initState) => {
    const createGlobalSlice = set => {
        return Object.assign(Object.assign(Object.assign({}, DEFAULT_STATE$9), initState), { setIsMobile(isMobile) {
                set({ isMobile }, false, 'setIsMobile');
            },
            goToInviteArea(isToInviteArea) {
                set({ isToInviteArea }, false, 'goToInviteArea');
            },
            globalLoading() {
                set(state => {
                    state.loadingCount++;
                }, false, 'globalLoading');
            },
            globalLoaded() {
                set(state => {
                    const count = state.loadingCount - 1;
                    state.loadingCount = count < 0 ? 0 : count;
                }, false, 'globalLoaded');
            },
            toggleLoginModal(isOpenLoginModal) {
                set(state => {
                    state.isOpenLoginModal = isOpenLoginModal;
                    if (!isOpenLoginModal) {
                        state.cantCloseLogin = false;
                    }
                }, false, 'toggleLoginModal');
            },
            setGuiding(guiding) {
                set({ guiding }, false, 'setGuiding');
            },
            setShowChatBotRecommend(showChatBotRecommend) {
                set({ showChatBotRecommend }, false, 'setShowChatBotRecommend');
            },
            toggleInvitecodeModal(isOpenInviteCodeModal) {
                set({ isOpenInviteCodeModal }, false, 'toggleInvitecodeModal');
            },
            setInviteCodeStep(step) {
                set({ inviteCodeStep: step }, false, 'setInviteCodeStep');
            },
            setAutoPromptTaskResult(createAutoPromptTaskResult) {
                set({ createAutoPromptTaskResult }, false, 'setAutoPromptTaskResult');
            },
            setNoEnergyWithUsablePropModalVisible(visible) {
                set(state => {
                    state.noEnergyWithUsablePropModalVisible = visible;
                }, false, 'setNoEnergyWithUsablePropModalVisible');
            },
            showOnboarding(val) {
                set(state => {
                    state.onboarding = val;
                }, false, 'showOnboarding');
            },
            setSumUnread(val) {
                set(state => {
                    state.sumUnread = val;
                }, false, 'setSumUnread');
            } });
    };
    return zustand.createStore()(computed__default.default(immer(devtools(createGlobalSlice, { store: 'user' })), computeState$6));
};

var TaskTypeEnum;
(function (TaskTypeEnum) {
    TaskTypeEnum["SEASON_TASK_TYPE_UNSPECIFIED"] = "SEASON_TASK_TYPE_UNSPECIFIED";
    TaskTypeEnum["SEASON_TASK_TYPE_DAILY_MESSAGE"] = "SEASON_TASK_TYPE_DAILY_MESSAGE";
    TaskTypeEnum["SEASON_TASK_TYPE_DC_INTERACTION"] = "SEASON_TASK_TYPE_DC_INTERACTION";
    TaskTypeEnum["SEASON_TASK_TYPE_BLOCKCHAIN_INTERACTION"] = "SEASON_TASK_TYPE_BLOCKCHAIN_INTERACTION";
    TaskTypeEnum["SEASON_TASK_TYPE_USE_VOICE_VIDEO"] = "SEASON_TASK_TYPE_USE_VOICE_VIDEO";
    TaskTypeEnum["SEASON_TASK_TYPE_CREATE_BOT"] = "SEASON_TASK_TYPE_CREATE_BOT";
    TaskTypeEnum["SEASON_TASK_TYPE_USE_VOICE_CLONE"] = "SEASON_TASK_TYPE_USE_VOICE_CLONE";
    TaskTypeEnum["SEASON_TASK_TYPE_USE_AUTO_PROMPT"] = "SEASON_TASK_TYPE_USE_AUTO_PROMPT";
    TaskTypeEnum["SEASON_TASK_TYPE_TALK_TO_GPT4_BOT"] = "SEASON_TASK_TYPE_TALK_TO_GPT4_BOT";
    TaskTypeEnum["SEASON_TASK_TYPE_TALK_TO_BOTS"] = "SEASON_TASK_TYPE_TALK_TO_BOTS";
    TaskTypeEnum["SEASON_TASK_TALK_TO_BOT_WITH_TAG"] = "SEASON_TASK_TALK_TO_BOT_WITH_TAG";
    TaskTypeEnum["SEASON_TASK_TYPE_BOT_MASTER"] = "SEASON_TASK_TYPE_BOT_MASTER";
    TaskTypeEnum["SEASON_TASK_TYPE_MODEL_MASTER"] = "SEASON_TASK_TYPE_MODEL_MASTER";
    TaskTypeEnum["SEASON_TASK_TYPE_INVITEE_MESSAGE_LV1"] = "SEASON_TASK_TYPE_INVITEE_MESSAGE_LV1";
    TaskTypeEnum["SEASON_TASK_TYPE_INVITEE_MESSAGE_LV2"] = "SEASON_TASK_TYPE_INVITEE_MESSAGE_LV2";
    TaskTypeEnum["SEASON_TASK_TYPE_FANS_KEY"] = "SEASON_TASK_TYPE_FANS_KEY";
    TaskTypeEnum["SEASON_TASK_TYPE_STAKING_EXPERIENCE"] = "SEASON_TASK_TYPE_STAKING_EXPERIENCE";
    TaskTypeEnum["SEASON_TASK_TYPE_EXPERIENCE_IMAGE_BOTS"] = "SEASON_TASK_TYPE_EXPERIENCE_IMAGE_BOTS";
    TaskTypeEnum["SEASON_TASK_TYPE_PUBLIC_VOICE_INCOME"] = "SEASON_TASK_TYPE_PUBLIC_VOICE_INCOME";
    TaskTypeEnum["SEASON_TASK_TYPE_BIND_DC_ACCOUNT"] = "SEASON_TASK_TYPE_BIND_DC_ACCOUNT";
    TaskTypeEnum["SEASON_TASK_TYPE_PATRON_BADGE"] = "SEASON_TASK_TYPE_PATRON_BADGE";
    TaskTypeEnum["SEASON_TASK_TYPE_TWEET_SHARE"] = "SEASON_TASK_TYPE_TWEET_SHARE";
    TaskTypeEnum["SEASON_TASK_TYPE_SOCIAL_MEDIA_SHARE"] = "SEASON_TASK_TYPE_SOCIAL_MEDIA_SHARE";
    TaskTypeEnum["SEASON_TASK_TOP_CURVE_HOLDERS_DAILY_INCOME"] = "SEASON_TASK_TOP_CURVE_HOLDERS_DAILY_INCOME";
    TaskTypeEnum["SEASON_TASK_TYPE_LUCKY_STAR"] = "SEASON_TASK_TYPE_LUCKY_STAR";
    TaskTypeEnum["SEASON_TASK_TYPE_CURVE_PROFIT_SHARE"] = "SEASON_TASK_TYPE_CURVE_PROFIT_SHARE";
    TaskTypeEnum["SEASON_TASK_TYPE_JACKPOT"] = "SEASON_TASK_TYPE_JACKPOT";
    TaskTypeEnum["SEASON_TASK_TYPE_FOLLOW_MYSHELL_SHARE_TWEET"] = "SEASON_TASK_TYPE_FOLLOW_MYSHELL_SHARE_TWEET";
    TaskTypeEnum["SEASON_TASK_TYPE_TRADING_NOVICE"] = "SEASON_TASK_TYPE_TRADING_NOVICE";
    TaskTypeEnum["SEASON_TASK_TYPE_TRADING_MAESTRO"] = "SEASON_TASK_TYPE_TRADING_MAESTRO";
    TaskTypeEnum["SEASON_TASK_TYPE_MARKET_CAP_CLIMBER"] = "SEASON_TASK_TYPE_MARKET_CAP_CLIMBER";
    TaskTypeEnum["SEASON_TASK_TYPE_MARKET_CAP_CRAFTER"] = "SEASON_TASK_TYPE_MARKET_CAP_CRAFTER";
    TaskTypeEnum["SEASON_TASK_TYPE_AIPP_ADVOCATE"] = "SEASON_TASK_TYPE_AIPP_ADVOCATE";
    TaskTypeEnum["SEASON_TASK_TYPE_KOL_INVITEE_INTERACTION"] = "SEASON_TASK_TYPE_KOL_INVITEE_INTERACTION";
})(TaskTypeEnum || (TaskTypeEnum = {}));
var GolangUserTaskStatusEnum;
(function (GolangUserTaskStatusEnum) {
    GolangUserTaskStatusEnum["SEASON_TASK_ITEM_STATUS_UNSPECIFIED"] = "SEASON_TASK_ITEM_STATUS_UNSPECIFIED";
    GolangUserTaskStatusEnum["SEASON_TASK_ITEM_STATUS_IN_PROGRESS"] = "SEASON_TASK_ITEM_STATUS_IN_PROGRESS";
    GolangUserTaskStatusEnum["SEASON_TASK_ITEM_STATUS_PRE_CLAIMABLE"] = "SEASON_TASK_ITEM_STATUS_PRE_CLAIMABLE";
    GolangUserTaskStatusEnum["SEASON_TASK_ITEM_STATUS_CLAIMABLE"] = "SEASON_TASK_ITEM_STATUS_CLAIMABLE";
    GolangUserTaskStatusEnum["SEASON_TASK_ITEM_STATUS_CLAIMED"] = "SEASON_TASK_ITEM_STATUS_CLAIMED";
    GolangUserTaskStatusEnum["SEASON_TASK_ITEM_STATUS_UNAVAILABLE"] = "SEASON_TASK_ITEM_STATUS_UNAVAILABLE";
    GolangUserTaskStatusEnum["SEASON_TASK_ITEM_STATUS_MONTHLY_LIMIT_REACHED"] = "SEASON_TASK_ITEM_STATUS_MONTHLY_LIMIT_REACHED";
})(GolangUserTaskStatusEnum || (GolangUserTaskStatusEnum = {}));
var PropTypeEnum;
(function (PropTypeEnum) {
    PropTypeEnum["standardBattlePass"] = "standardBattlePass";
    PropTypeEnum["genesisPass"] = "genesisPass";
    PropTypeEnum["seasonBadge"] = "seasonBadge";
    PropTypeEnum["energyPack"] = "energyPack";
    PropTypeEnum["shellCoin"] = "shellCoin";
})(PropTypeEnum || (PropTypeEnum = {}));
var GolangRewardStatusEnum;
(function (GolangRewardStatusEnum) {
    GolangRewardStatusEnum["BACKPACK_ITEM_STATUS_UNSPECIFIED"] = "BACKPACK_ITEM_STATUS_UNSPECIFIED";
    GolangRewardStatusEnum["BACKPACK_ITEM_STATUS_COMING_SOON"] = "BACKPACK_ITEM_STATUS_COMING_SOON";
    GolangRewardStatusEnum["BACKPACK_ITEM_STATUS_DISABLED"] = "BACKPACK_ITEM_STATUS_DISABLED";
})(GolangRewardStatusEnum || (GolangRewardStatusEnum = {}));
var PropStatusEnum;
(function (PropStatusEnum) {
    PropStatusEnum["BACKPACK_ITEM_STATUS_UNSPECIFIED"] = "BACKPACK_ITEM_STATUS_UNSPECIFIED";
    PropStatusEnum["BACKPACK_ITEM_STATUS_COMING_SOON"] = "BACKPACK_ITEM_STATUS_COMING_SOON";
    PropStatusEnum["BACKPACK_ITEM_STATUS_DISABLED"] = "BACKPACK_ITEM_STATUS_DISABLED";
})(PropStatusEnum || (PropStatusEnum = {}));
var OrderType;
(function (OrderType) {
    OrderType["ORDER_SOURCE_TYPE_UNSPECIFIED"] = "ORDER_SOURCE_TYPE_UNSPECIFIED";
    OrderType["ORDER_SOURCE_TYPE_SEASON_POINT_EXCHANGE"] = "ORDER_SOURCE_TYPE_SEASON_POINT_EXCHANGE";
    OrderType["ORDER_SOURCE_TYPE_BADGE_EXCHANGE"] = "ORDER_SOURCE_TYPE_BADGE_EXCHANGE";
    OrderType["ORDER_SOURCE_TYPE_BUY_SHARE_KEY"] = "ORDER_SOURCE_TYPE_BUY_SHARE_KEY";
    OrderType["ORDER_SOURCE_TYPE_SELL_SHARE_KEY"] = "ORDER_SOURCE_TYPE_SELL_SHARE_KEY";
})(OrderType || (OrderType = {}));
var OrderStatus;
(function (OrderStatus) {
    OrderStatus["ORDER_STATUS_UNSPECIFIED"] = "ORDER_STATUS_UNSPECIFIED";
    OrderStatus["ORDER_STATUS_WAITING_PAY"] = "ORDER_STATUS_WAITING_PAY";
    OrderStatus["ORDER_STATUS_PAID"] = "ORDER_STATUS_PAID";
    OrderStatus["ORDER_STATUS_CANCELED"] = "ORDER_STATUS_CANCELED";
})(OrderStatus || (OrderStatus = {}));
var SeasonStatus;
(function (SeasonStatus) {
    SeasonStatus["SEASON_STATUS_UNSPECIFIED"] = "SEASON_STATUS_UNSPECIFIED";
    SeasonStatus["SEASON_STATUS_ON_GOING"] = "SEASON_STATUS_ON_GOING";
    SeasonStatus["SEASON_STATUS_PREPARING_FOR_REWARDS"] = "SEASON_STATUS_PREPARING_FOR_REWARDS";
    SeasonStatus["SEASON_STATUS_REWARDS_REDEMPTION"] = "SEASON_STATUS_REWARDS_REDEMPTION";
    SeasonStatus["SEASON_STATUS_FINISHED"] = "SEASON_STATUS_FINISHED";
})(SeasonStatus || (SeasonStatus = {}));
var PointTypeEnum;
(function (PointTypeEnum) {
    PointTypeEnum["USER_POINT_TYPE_GENERAL"] = "USER_POINT_TYPE_GENERAL";
    PointTypeEnum["USER_POINT_TYPE_ADVOCATOR"] = "USER_POINT_TYPE_ADVOCATOR";
    PointTypeEnum["USER_POINT_TYPE_CREATOR"] = "USER_POINT_TYPE_CREATOR";
    PointTypeEnum["USER_POINT_TYPE_INVESTOR"] = "USER_POINT_TYPE_INVESTOR";
})(PointTypeEnum || (PointTypeEnum = {}));

const DEFAULT_STATE$8 = {
    seasons: null,
    seasonIndex: 0,
    taskList: [],
    newlyPropsCount: 0,
    points: [],
    claimedPoints: 0,
    exchangePoints: [],
    myProps: [],
    deductionPoints: null,
    seasonPassUseSuccessModalVisible: false,
    holdBadges: [],
    txHash: undefined,
    blockChainInteractionState: 'not_start',
    rewardList: [],
    rewardQuerying: true,
    myPropsQuerying: true
};
const createTaskSlice = set => {
    return Object.assign(Object.assign({}, DEFAULT_STATE$8), { setUnclaimedPoints(points) {
            set({ unclaimedPoints: points }, false, 'setUnclaimedPoints');
        },
        setExchangePoints(points) {
            set({ exchangePoints: points }, false, 'setExchangePoints');
        },
        setSeasons(season, lastSeason) {
            set({ seasons: [season, lastSeason] }, false, 'setSeasons');
        },
        setSeasonIndex(index) {
            set({ seasonIndex: index }, false, 'setSeasonIndex');
        },
        setTaskList(taskList) {
            set({ taskList }, false, 'setTaskList');
        },
        setPoints(points, addToClaimed = false) {
            set({ points }, false, 'setPoints');
        },
        clearClaimedPoints() {
            set({ claimedPoints: 0 }, false, 'clearClaimedPoints');
        },
        setMyProps(myProps) {
            set({ myProps }, false, 'setMyProps');
        },
        setNewlyPropsCount(newlyPropsCount) {
            set({ newlyPropsCount }, false, 'setNewlyPropsCount');
        },
        setDeductionPoints(points) {
            set({ deductionPoints: points }, false, 'setDeductionPoints');
        },
        setSeasonPassUseSuccessModalVisible(state) {
            set({ seasonPassUseSuccessModalVisible: state }, false, 'setSeasonPassUseSuccessModalVisible');
        },
        setHoldBadges(badges) {
            set(state => {
                state.holdBadges = badges;
            }, false, 'setHoldBadges');
        },
        setTxHash(hash) {
            set({ txHash: hash }, false, 'setTxHash');
        },
        setBlockChainInteractionState(state) {
            set({ blockChainInteractionState: state }, false, 'setBlockChainInteractionState');
        },
        setRewardList(rewardList) {
            set({ rewardList }, false, 'setRewardList');
        },
        setRewardQuerying(rewardQuerying) {
            set({ rewardQuerying }, false, 'setRewardQuering');
        },
        setMyPropsQuerying(myPropsQuerying) {
            set({ myPropsQuerying }, false, 'setMyPropsQuerying');
        } });
};
const computeState$5 = (state) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    return ({
        seasonId: state.seasons ? (_a = state.seasons[state.seasonIndex]) === null || _a === void 0 ? void 0 : _a.id : null,
        seasonName: state.seasons ? (_b = state.seasons[state.seasonIndex]) === null || _b === void 0 ? void 0 : _b.name : null,
        isBeta: state.seasons ? (_c = state.seasons[state.seasonIndex]) === null || _c === void 0 ? void 0 : _c.isBate : null,
        seasonBanners: state.seasons
            ? [
                (_d = state.seasons[state.seasonIndex]) === null || _d === void 0 ? void 0 : _d.bannerPcLight,
                (_e = state.seasons[state.seasonIndex]) === null || _e === void 0 ? void 0 : _e.bannerPcDark,
                (_f = state.seasons[state.seasonIndex]) === null || _f === void 0 ? void 0 : _f.bannerMobileLight,
                (_g = state.seasons[state.seasonIndex]) === null || _g === void 0 ? void 0 : _g.bannerMobileDark
            ]
            : null,
        seasonStartDate: state.seasons ? (_j = (_h = state.seasons[state.seasonIndex]) === null || _h === void 0 ? void 0 : _h.startDate) !== null && _j !== void 0 ? _j : null : null,
        seasonEndDate: state.seasons ? (_l = (_k = state.seasons[state.seasonIndex]) === null || _k === void 0 ? void 0 : _k.endDate) !== null && _l !== void 0 ? _l : null : null,
        claimableStartDate: state.seasons ? (_o = (_m = state.seasons[state.seasonIndex]) === null || _m === void 0 ? void 0 : _m.claimableStart) !== null && _o !== void 0 ? _o : null : null,
        claimableEndDate: state.seasons ? (_q = (_p = state.seasons[state.seasonIndex]) === null || _p === void 0 ? void 0 : _p.claimableEnd) !== null && _q !== void 0 ? _q : null : null,
        silentPeriodEndDate: state.seasons ? (_s = (_r = state.seasons[state.seasonIndex]) === null || _r === void 0 ? void 0 : _r.silentPeriodEnd) !== null && _s !== void 0 ? _s : null : null,
        hasClaimableTask: state.taskList.some(task => task.status === GolangUserTaskStatusEnum.SEASON_TASK_ITEM_STATUS_CLAIMABLE),
        seasonPoints: Array.isArray(state.points) ? state.points[state.seasonIndex] : undefined
    });
};
const useTaskStore = zustand.create()(computed__default.default(immer(devtools(createTaskSlice, { store: 'task' })), computeState$5));

const DEFAULT_STATE$7 = {
    user: null,
    inviteCode: '',
    invitationCount: 0,
    validInvitationCount: 0,
    tgValidInvitationCount: 0,
    inviteLink: '',
    retriveEnergySuccess: false,
    energy: 0,
    dailyEnergy: 0,
    isEnergyOverflow: false,
    tgInfo: null,
    connectedAccounts: null,
    userSettingsInfo: [
        {
            name: UserSettingEnum.FLAG_ICON_REWARD,
            value: '1'
        },
        {
            name: UserSettingEnum.FLAG_ICON_FORUM,
            value: '1'
        },
        {
            name: UserSettingEnum.FLAG_TAG_NOTICE,
            value: '1'
        },
        {
            name: UserSettingEnum.FLAG_USET_FIRST_PUBLISH_GALLERY,
            value: '1'
        },
        {
            name: UserSettingEnum.FLAG_USET_FIRST_VISIT_GALLERY,
            value: '1'
        },
        {
            name: UserSettingEnum.FLAG_LLM_MODEL_CONFIG,
            value: '1'
        },
        {
            name: UserSettingEnum.SHOW_NSFW,
            value: '0'
        },
        {
            name: UserSettingEnum.FLAG_NSFW_CONFIRMED,
            value: '0'
        },
        {
            name: UserSettingEnum.LAST_SEASON,
            value: '0'
        },
        {
            name: UserSettingEnum.FLAG_stake_earn_VIEWED,
            value: '1'
        },
        { name: UserSettingEnum.FLAG_SHARE_KEY_EARN_POPUP_CONFIRMED, value: '0' },
        { name: UserSettingEnum.NOTIFICATION, value: '0' }
    ],
    rewardsCenterVisited: false,
    forumVisited: false,
    tagNoticeVisited: false,
    flagUserFirstPublishGallery: false,
    flagUserFirstVisitGallery: false,
    modelConfigClicked: false,
    showNsfw: NsfwEnum.INIT,
    nsfwConfirmed: false,
    nsfwSwitch: true,
    isLogin: false,
    shellCoins: null,
    frozenShellCoins: null,
    loginMethod: undefined,
    language: 'en',
    loginPopVisible: false
};
const computeState$4 = (state) => {
    var _a, _b, _c, _d;
    return ({
        isVisitor: !state.isLogin || ((_a = state.user) === null || _a === void 0 ? void 0 : _a.source) === exports.UserSourceEnum.VISITOR ? VisitorEnum.YES : VisitorEnum.NO,
        userId: (_b = state.user) === null || _b === void 0 ? void 0 : _b.id,
        premiumInfo: state.user
            ? state.user.premiumInfo
            : {
                level: 0,
                totalExp: 0,
                nextLevelNeedExp: 0,
                currentLevelExp: 5
            },
        isEnergyOverflow: state.energy > state.dailyEnergy,
        rewardsCenterVisited: state.userSettingsInfo.some(s => s.name === UserSettingEnum.FLAG_ICON_REWARD && s.value === '1'),
        forumVisited: state.userSettingsInfo.some(s => s.name === UserSettingEnum.FLAG_ICON_FORUM && s.value === '1'),
        tagNoticeVisited: state.userSettingsInfo.some(s => s.name === UserSettingEnum.FLAG_TAG_NOTICE && s.value === '1'),
        flagUserFirstPublishGallery: state.userSettingsInfo.some(s => s.name === UserSettingEnum.FLAG_USET_FIRST_PUBLISH_GALLERY && s.value === '1'),
        flagUserFirstVisitGallery: state.userSettingsInfo.some(s => s.name === UserSettingEnum.FLAG_USET_FIRST_VISIT_GALLERY && s.value === '1'),
        modelConfigClicked: state.userSettingsInfo.some(s => s.name === UserSettingEnum.FLAG_LLM_MODEL_CONFIG),
        nsfwConfirmed: state.userSettingsInfo.some(s => s.name === UserSettingEnum.FLAG_NSFW_CONFIRMED && s.value === '1'),
        blockChainGuruTaskOnceCompleted: state.userSettingsInfo.some(s => s.name === UserSettingEnum.FLAG_COMPLETED_OPBNB_CHAIN_TASK && s.value === '1'),
        silentPeriodConfirmed: state.userSettingsInfo.find(s => s.name === UserSettingEnum.FLAG_SILENT_PERIOD_CONFIRMED)
            ? state.userSettingsInfo.some(s => { var _a; return s.name === UserSettingEnum.FLAG_SILENT_PERIOD_CONFIRMED && s.value !== ((_a = useTaskStore.getState().seasons) === null || _a === void 0 ? void 0 : _a[1].id); })
            : null,
        deductionConfirmed: state.userSettingsInfo.find(({ name }) => name === 'flagDeductionConfirmed')
            ? state.userSettingsInfo.some(s => {
                var _a;
                return s.name === UserSettingEnum.DEDUCTION_CONFIRMED && s.value !== ((_a = useTaskStore.getState().seasons) === null || _a === void 0 ? void 0 : _a[1].id);
            })
            : null,
        subscribingEarnViewed: state.userSettingsInfo.some(s => s.name === UserSettingEnum.FLAG_stake_earn_VIEWED && s.value === '1'),
        nsfwSwitch: state.nsfwSwitch,
        timezone: (_c = state.userSettingsInfo.find(s => s.name === UserSettingEnum.TIME_ZONE)) === null || _c === void 0 ? void 0 : _c.value,
        notification: ((_d = state.userSettingsInfo.find(s => s.name === UserSettingEnum.NOTIFICATION)) === null || _d === void 0 ? void 0 : _d.value) === '1'
    });
};
const createUserStore = (initState) => {
    const createUserSlice = set => {
        return Object.assign(Object.assign(Object.assign({}, DEFAULT_STATE$7), initState), { setUser(user) {
                set({ user }, false, 'setUser');
            },
            setUserInviteCode(inviteCode) {
                set({ inviteCode }, false, 'setUserInviteCode');
            },
            setInvitationCount(invitationCount) {
                set({ invitationCount }, false, 'setInvitationCount');
            },
            setValidInvitationCount(validInvitationCount) {
                set({ validInvitationCount }, false, 'setValidInvitationCount');
            },
            setTgValidInvitationCount(tgValidInvitationCount) {
                set({ tgValidInvitationCount }, false, 'setTgValidInvitationCount');
            },
            setInviteLink(inviteLink) {
                set({ inviteLink }, false, 'setInviteLink');
            },
            setEnergyInfo(data) {
                set(state => {
                    state.energy = data.energy;
                    state.dailyEnergy = data.dailyEnergy || state.dailyEnergy;
                    state.retriveEnergySuccess = true;
                }, false, 'setEnergyInfo');
            },
            setTgInfo(tgInfo) {
                set({ tgInfo }, false, 'setTgInfo');
            },
            setConnectedAccounts(connectedAccounts) {
                set({ connectedAccounts }, false, 'setConnectedAccounts');
            },
            setUserSettingsInfo(userSettingsInfo) {
                set({ userSettingsInfo }, false, 'setUserSettingsInfo');
            },
            clearUser() {
                set(DEFAULT_STATE$7, false, 'clearUser');
            },
            setShowNsfw(showNsfw) {
                set({ showNsfw }, false, 'setShowNsfw');
            },
            setShellCoins(coins) {
                set(state => {
                    state.shellCoins = coins;
                }, false, 'setShellCoins');
            },
            setFrozenShellCoins(coins) {
                set(state => {
                    state.frozenShellCoins = coins;
                }, false, 'setFrozenShellCoins');
            },
            setLoginMethod(method) {
                set({ loginMethod: method }, false, 'setLoginMethod');
            },
            setIsLogin(isLogin) {
                set({ isLogin }, false, 'setIsLogin');
            },
            setLoginTimestamp(timestamp) {
                set({ loginTimestamp: timestamp }, false, 'setLoginTimestamp');
            },
            setLanguage(language) {
                set({ language }, false, 'setLanguage');
            },
            setLoginPopVisible(visible) {
                set({ loginPopVisible: visible }, false, 'setLoginPopVisible');
            } });
    };
    return zustand.createStore()(computed__default.default(immer(devtools(createUserSlice, { store: 'user' })), computeState$4));
};

(undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function setMessageHandled(msgId) {
    return APIFetch.post('/v1/bot/chat/set_message_handled', {
        body: {
            msgId
        },
        isGoLang: true
    });
}
function removeBotFromChatList(botId) {
    return APIFetch.post('/v1/bot/chat/remove_bot_from_chat_list', {
        body: {
            botId
        },
        isGoLang: true
    });
}
const shareCodeCacheMap$$2 = new Map();
async function getBotSharingCode(botId) {
    if (!shareCodeCacheMap$$2.has(botId)) {
        const res = (await getBotSharingCodeByBotId(botId));
        if (res.success && res.data.code) {
            shareCodeCacheMap$$2.set(botId, res.data.code);
        }
    }
    return shareCodeCacheMap$$2.get(botId);
}
function getBotSharingCodeByBotId(botId) {
    return APIFetch.post('/v1/bot/shared/generate_bot_shared_code', {
        body: {
            botId
        },
        isGoLang: true
    });
}
function mediaFileMetadata(params) {
    return APIFetch.post('/v1/bot/im/media_file_metadata', {
        body: params,
        isGoLang: true
    }).then(res => res === null || res === void 0 ? void 0 : res.data);
}

immer$1.enableMapSet();
const DEFAULT_STATE$6 = {
    inputType: 'text',
    lastInputType: 'text',
    multiBotMap: {},
    multiPublishMap: {},
    selectedDeleteChatList: [],
    playingAudio: null,
    audioQueue: [],
    sending: false,
    copyText: '',
    chatBodyType: '',
    fileUpload: { uploading: null, filesMap: {}, deletedList: [], alert: {}, dragModal: false },
    errorMsgList: {},
    hasUnRead: false
};
const createChatSlice = (set, get) => {
    return Object.assign(Object.assign({}, DEFAULT_STATE$6), { multiBotMap: {}, setInputType(type) {
            set(state => {
                const t1 = ['audio', 'text'];
                const t2 = ['share', 'delete', 'publish'];
                if (t2.includes(type) && t1.includes(state.inputType)) {
                    state.lastInputType = state.inputType;
                }
                else {
                    state.lastInputType = type;
                }
                state.inputType = type;
            }, false, 'setInputType');
        },
        setMessageHandled({ botId, msgId }) {
            set(state => {
                setMessageHandled(msgId);
                const msg = state.multiBotMap[String(botId)].chatDic.get(msgId);
                state.multiBotMap[String(botId)].chatDic.set(msgId, Object.assign(Object.assign({}, msg), { handled: true }));
                state.multiBotMap[String(botId)].chatList = [...state.multiBotMap[String(botId)].chatDic.values()];
            }, false, 'setMessageHandled');
        },
        setMultiPublishMap(image, item) {
            set(state => {
                if (state.multiPublishMap[image]) {
                    delete state.multiPublishMap[image];
                }
                else {
                    state.multiPublishMap[image] = item;
                }
            }, false, 'setMultiPublishMap');
        },
        clearMultiPublishMap() {
            set(state => {
                state.multiPublishMap = {};
            }, false, 'clearMultiPublishMap');
        },
        pushAudioIdToQueue(audioId) {
            set(state => {
                state.audioQueue.push(audioId);
                state.audioQueue = Array.from(new Set(state.audioQueue));
            }, false, 'pushAudioIdToQueue');
        },
        setErrorMsg(chatId, msg) {
            set(state => {
                if (!state.errorMsgList) {
                    state.errorMsgList = {};
                }
                state.errorMsgList[chatId] = msg;
            }, true, 'setErrorMsg');
        },
        removePlayedAudio(id) {
            set(state => {
                state.audioQueue = state.audioQueue.filter(audioId => audioId !== id);
            }, false, 'removePlayedAudio');
        },
        clearAudioQueue() {
            set(state => {
                state.audioQueue = [];
                state.playingAudio = null;
            }, false, 'clearAudioQueue');
        },
        changePlayingAudio(audioId) {
            set(state => {
                state.playingAudio = audioId !== null && audioId !== void 0 ? audioId : null;
            }, false, 'changePlayingAudio');
        },
        setChatBodyType(val) {
            set(state => {
                state.chatBodyType = val;
            }, false, 'setChatBodyType');
        },
        setHasUnRead(val) {
            set(state => {
                state.hasUnRead = val;
            }, false, 'setHasUnRead');
        },
        setFileAlert(data) {
            set(state => {
                console.log(data);
                state.fileUpload.alert = data;
            });
        },
        showDragModal(val) {
            set(state => {
                state.fileUpload.dragModal = val;
            });
        } });
};
const useChatStore = zustand.create()(immer(devtools((...a) => (Object.assign({}, createChatSlice(...a))), { store: 'chat' })));

({
    isAutopushOn: true,
    isAudioOn: false,
    isAudioPlayOn: false,
    isTranscriptionOn: true,
    isTranslationOn: true,
    speakingLanguage: ChatSettingSpeakingLangEnum.AUTO,
    audioSpeed: AudioSpeedValue2KeyMap[1]
});
immer$1.enableMapSet();
const DEFAULT_STATE$5 = {
    updatingBotList: false,
    botList: [],
    botLastMessageMap: new Map(),
    selectedBotList: [],
    tagList: [],
    ugcBotList: [],
    ownUgcBotList: [],
    selectedUgcBotId: '',
    activeType: 'all',
    name: '',
    pageToken: '0',
    dataPush: false,
    filters: null,
    checkedFiltersSet: new Set(),
    isFromLandingPage: false,
    kolInfo: null,
    recommend: { banners: [], list: [] },
    tagFilters: [],
    searchList: [],
    botChatSettingMap: new Map(),
    homeData: null,
    includeTagIds: []
};
const initIsFromLandingPage = () => {
    if (typeof window !== 'undefined') {
        const searchParams = new URLSearchParams(window.location.search);
        const apkpure_vid = searchParams.get('apkpure_vid');
        return !!apkpure_vid;
    }
    return false;
};
const createBotSlice = set => {
    return Object.assign(Object.assign({}, DEFAULT_STATE$5), { isFromLandingPage: initIsFromLandingPage(), setUpdatingBotList(val) {
            set({ updatingBotList: val }, false, 'setUpdatingBotList');
        },
        setBotList(bots) {
            set({ botList: bots }, false, 'setBotList');
        },
        setOwnUgcBotList(bots) {
            set({ ownUgcBotList: bots }, false, 'setOwnUgcBotList');
        },
        setSelectedUgcBotId(botId) {
            set({ selectedUgcBotId: botId }, false, 'setSelectedUgcBotId');
            if (botId) {
                localStorage.setItem('selected_ugc_bot_id', botId);
            }
            else {
                localStorage.removeItem('selected_ugc_bot_id');
            }
        },
        batchSetBotLastMessage(botList) {
            set(state => {
                for (const bot of botList) {
                    if (bot.lastMessage) {
                        const msg = Object.assign(Object.assign({}, bot.lastMessage), { createdDate: new Date(bot.lastMessage.createdDate).getTime() });
                        state.botLastMessageMap.set(String(bot.id), msg);
                    }
                }
            });
        },
        setBotLastMessage(botId, lastMessage) {
            set(state => {
                if (lastMessage) {
                    const msg = Object.assign(Object.assign({}, lastMessage), { createdDate: new Date(lastMessage.createdDate || Number(lastMessage.createdDateUnix)).getTime() });
                    state.botLastMessageMap.set(botId, msg);
                    const bot = state.botList.find(bot => bot.id === botId);
                    if (bot) {
                        const filterBotList = state.botList.filter(bot => bot.id !== botId);
                        if (bot.pinned) {
                            state.botList = [bot, ...filterBotList];
                        }
                        else {
                            const pinnedBots = filterBotList.filter(bot => bot.pinned);
                            const unpinnedBots = filterBotList.filter(bot => !bot.pinned);
                            state.botList = [...pinnedBots, bot, ...unpinnedBots];
                        }
                    }
                }
                else {
                    state.botLastMessageMap.delete(botId);
                }
            }, false, 'setBotLastMessage');
        },
        reset() {
            set(DEFAULT_STATE$5, false, 'reset');
        },
        setKolInfo(info) {
            set({ kolInfo: info }, false, 'setKolInfo');
        },
        setRecommend(recommend) {
            set({ recommend }, false, 'setRecommend');
        },
        setTagFilters(tagFilters) {
            set({ tagFilters }, false, 'setTagFilters');
        },
        setSearchList(searchList) {
            set({ searchList }, false, 'setSearchList');
        },
        setHomeData(homeData) {
            set({ homeData }, false, 'setHomeData');
        },
        setPageToken(pageToken) {
            set({ pageToken }, false, 'setPageToken');
        },
        setDataPush(dataPush) {
            set({ dataPush }, false, 'setDataPush');
        },
        setActiveType(val) {
            set({ activeType: val }, false, 'setActiveType');
        },
        setBotChatSetting(botId, chatSetting) {
            set(state => {
                state.botChatSettingMap.set(botId, chatSetting);
            }, false, 'setBotChatSetting');
        },
        clearBotChatSetting() {
            set(state => {
                state.botChatSettingMap.clear();
            }, false, 'clearBotChatSetting');
        },
        updateBotEnergyPerChat(botId, energyPerChat, energyPerLevelByPass) {
            set(state => {
                const matchedBot = state.botList.find(bot => bot.id == botId);
                if (matchedBot === null || matchedBot === void 0 ? void 0 : matchedBot.energyPerChat) {
                    matchedBot.energyPerChat = energyPerChat;
                }
                if (matchedBot === null || matchedBot === void 0 ? void 0 : matchedBot.llmModel) {
                    matchedBot.llmModel.energyPerLevelByPass = energyPerLevelByPass;
                }
            }, false, 'updateBotEnergyPerChat');
        },
        setSSECtrl(sseCtrl) {
            set({ sseCtrl }, false, 'setSSECtrl');
        } });
};
const computeState$3 = (state) => ({
    sumUnReadMessageCount: state.botList.reduce((accumulator, current) => {
        return accumulator + current.unreadMessageCount;
    }, 0)
});
zustand.create()(computed__default.default(immer(devtools(createBotSlice, { store: 'bot' })), computeState$3));

var CardEnum;
(function (CardEnum) {
    CardEnum["TYPE_NORMAL_TITLE"] = "TYPE_NORMAL_TITLE";
    CardEnum["TYPE_SLIDER"] = "TYPE_SLIDER";
    CardEnum["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
})(CardEnum || (CardEnum = {}));
var MediaEnum;
(function (MediaEnum) {
    MediaEnum["MEDIA_TYPE_VIDEO"] = "MEDIA_TYPE_VIDEO";
    MediaEnum["MEDIA_TYPE_IMAGE"] = "MEDIA_TYPE_IMAGE";
    MediaEnum["MEDIA_TYPE_UNSPECIFIED"] = "MEDIA_TYPE_UNSPECIFIED";
})(MediaEnum || (MediaEnum = {}));
var WidgetStatusEnum;
(function (WidgetStatusEnum) {
    WidgetStatusEnum["STATUS_UNSPECIFIED"] = "STATUS_UNSPECIFIED";
    WidgetStatusEnum["STATUS_PUBLIC"] = "STATUS_PUBLIC";
    WidgetStatusEnum["STATUS_PRIVATE"] = "STATUS_PRIVATE";
})(WidgetStatusEnum || (WidgetStatusEnum = {}));
var ChatPanelTypeEnum;
(function (ChatPanelTypeEnum) {
    ChatPanelTypeEnum["BOT_CHAT_PANEL_TYPE_UNSPECIFIED"] = "BOT_CHAT_PANEL_TYPE_UNSPECIFIED";
    ChatPanelTypeEnum["BOT_CHAT_PANEL_TYPE_IM"] = "BOT_CHAT_PANEL_TYPE_IM";
    ChatPanelTypeEnum["BOT_CHAT_PANEL_TYPE_IMAGE_GEN"] = "BOT_CHAT_PANEL_TYPE_IMAGE_GEN";
    ChatPanelTypeEnum["BOT_CHAT_PANEL_TYPE_COMPONENT"] = "BOT_CHAT_PANEL_TYPE_COMPONENT";
})(ChatPanelTypeEnum || (ChatPanelTypeEnum = {}));
var ParamTypeEnum;
(function (ParamTypeEnum) {
    ParamTypeEnum["BOT_IM_SLASH_PARAM_TYPE_UNSPECIFIED"] = "BOT_IM_SLASH_PARAM_TYPE_UNSPECIFIED";
    ParamTypeEnum["BOT_IM_SLASH_PARAM_TYPE_NUMBER"] = "BOT_IM_SLASH_PARAM_TYPE_NUMBER";
    ParamTypeEnum["BOT_IM_SLASH_PARAM_TYPE_STRING"] = "BOT_IM_SLASH_PARAM_TYPE_STRING";
})(ParamTypeEnum || (ParamTypeEnum = {}));
var supportedEmbedTypesEnum;
(function (supportedEmbedTypesEnum) {
    supportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_UNSPECIFIED"] = "MESSAGE_METADATA_TYPE_UNSPECIFIED";
    supportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_IMAGE_FILE"] = "MESSAGE_METADATA_TYPE_IMAGE_FILE";
    supportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_TEXT_FILE"] = "MESSAGE_METADATA_TYPE_TEXT_FILE";
    supportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_ALL_FILE"] = "MESSAGE_METADATA_TYPE_ALL_FILE";
    supportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_AUDIO_FILE"] = "MESSAGE_METADATA_TYPE_AUDIO_FILE";
    supportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_VIDEO_FILE"] = "MESSAGE_METADATA_TYPE_VIDEO_FILE";
    supportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_TEXT_CONTENT"] = "MESSAGE_METADATA_TYPE_TEXT_CONTENT";
    supportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_USER_AUDIO"] = "MESSAGE_METADATA_TYPE_USER_AUDIO";
    supportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_COMPONENT_INPUT"] = "MESSAGE_METADATA_TYPE_COMPONENT_INPUT";
    supportedEmbedTypesEnum["MESSAGE_METADATA_TYPE_ASYNC_JOB_INFO"] = "MESSAGE_METADATA_TYPE_ASYNC_JOB_INFO";
})(supportedEmbedTypesEnum || (supportedEmbedTypesEnum = {}));
var ImComponentsInputTypeEnum;
(function (ImComponentsInputTypeEnum) {
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_UNSPECIFIED"] = "BOT_IM_COMPONENT_INPUT_TYPE_UNSPECIFIED";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_FILE_UPLOAD"] = "BOT_IM_COMPONENT_INPUT_TYPE_FILE_UPLOAD";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_VIDEO_UPLOAD"] = "BOT_IM_COMPONENT_INPUT_TYPE_VIDEO_UPLOAD";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_IMAGE_UPLOAD"] = "BOT_IM_COMPONENT_INPUT_TYPE_IMAGE_UPLOAD";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_TEXT_UPLOAD"] = "BOT_IM_COMPONENT_INPUT_TYPE_TEXT_UPLOAD";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_TEXT_INPUT"] = "BOT_IM_COMPONENT_INPUT_TYPE_TEXT_INPUT";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_TEXT_SELECTOR"] = "BOT_IM_COMPONENT_INPUT_TYPE_TEXT_SELECTOR";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_INPUT"] = "BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_INPUT";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_INTEGER_INPUT"] = "BOT_IM_COMPONENT_INPUT_TYPE_INTEGER_INPUT";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_CHECKBOX"] = "BOT_IM_COMPONENT_INPUT_TYPE_CHECKBOX";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_SELECTOR"] = "BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_SELECTOR";
    ImComponentsInputTypeEnum["BOT_IM_COMPONENT_INPUT_TYPE_CODE_EDITOR"] = "BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_SELECTOR";
})(ImComponentsInputTypeEnum || (ImComponentsInputTypeEnum = {}));
var WidgetChatCallerTypeEnum;
(function (WidgetChatCallerTypeEnum) {
    WidgetChatCallerTypeEnum["WIDGET_CHAT_CALLER_TYPE_UNSPECFIED"] = "WIDGET_CHAT_CALLER_TYPE_UNSPECFIED";
    WidgetChatCallerTypeEnum["WIDGET_CHAT_CALLER_TYPE_PROMPT"] = "WIDGET_CHAT_CALLER_TYPE_PROMPT";
    WidgetChatCallerTypeEnum["WIDGET_CHAT_CALLER_TYPE_VOICE"] = "WIDGET_CHAT_CALLER_TYPE_VOICE";
    WidgetChatCallerTypeEnum["WIDGET_CHAT_CALLER_TYPE_COMPONENT"] = "WIDGET_CHAT_CALLER_TYPE_COMPONENT";
})(WidgetChatCallerTypeEnum || (WidgetChatCallerTypeEnum = {}));

function ttsWidgetTrail(widgetId) {
    return APIFetch.post('/v1/widget/chat/voice/trail', {
        body: {
            widgetId
        },
        isGoLang: true,
        adapter: (res) => {
            return res.voiceUrl;
        }
    });
}
const shareCodeCacheMap$$1 = new Map();
async function getWidgetSharingCode(widgetId) {
    if (!shareCodeCacheMap$$1.has(widgetId)) {
        const res = (await getWidgetSharingCodeByWidgetId(widgetId));
        if (res.success && res.data) {
            shareCodeCacheMap$$1.set(widgetId, res.data.code);
        }
    }
    return shareCodeCacheMap$$1.get(widgetId);
}
function getWidgetSharingCodeByWidgetId(widgetId) {
    return APIFetch.post('/v1/shared/generate_shared_code', {
        body: {
            bizId: widgetId,
            bizType: 'BIZ_TYPE_WIDGET'
        },
        isGoLang: true
    });
}
function removeWidgetFromChatList(widgetId) {
    return APIFetch.post('/v1/widget/chat/remove_widget_from_chat_list', {
        body: {
            widgetId
        },
        isGoLang: true
    });
}
var DEPLOY_STATUS;
(function (DEPLOY_STATUS) {
    DEPLOY_STATUS["DEPLOY_STATUS_UNKNOWN"] = "DEPLOY_STATUS_UNKNOWN";
    DEPLOY_STATUS["DEPLOY_STATUS_IGNORE"] = "DEPLOY_STATUS_IGNORE";
    DEPLOY_STATUS["DEPLOY_STATUS_REQUIRE_DEPLOY"] = "DEPLOY_STATUS_REQUIRE_DEPLOY";
    DEPLOY_STATUS["DEPLOY_STATUS_IN_PROGRESS"] = "DEPLOY_STATUS_IN_PROGRESS";
    DEPLOY_STATUS["DEPLOY_STATUS_COMPLETED"] = "DEPLOY_STATUS_COMPLETED";
    DEPLOY_STATUS["DEPLOY_STATUS_FAILED"] = "DEPLOY_STATUS_FAILED";
    DEPLOY_STATUS["ERROR_REASON_INTERNAL_SERVER_ERROR"] = "ERROR_REASON_INTERNAL_SERVER_ERROR";
})(DEPLOY_STATUS || (DEPLOY_STATUS = {}));
function getDeployment(body) {
    return APIFetch.post('/v1/bot/workflow/get_deployment', {
        body: Object.assign(Object.assign({}, body), { bot_id: body.bot_id }),
        isGoLang: true
    });
}
function getDeploymentCount() {
    return APIFetch.post('/v1/bot/workflow/count', {
        isGoLang: true
    });
}

var Scenario;
(function (Scenario) {
    Scenario["SCENARIO_BOT_PHOTO"] = "SCENARIO_BOT_PHOTO";
    Scenario["SCENARIO_BOT_REPLY_TTS_VOICE"] = "SCENARIO_BOT_REPLY_TTS_VOICE";
    Scenario["SCENARIO_USER_BOT_CHAT_VOICE"] = "SCENARIO_USER_BOT_CHAT_VOICE";
    Scenario["SCENARIO_USER_AVATAR"] = "SCENARIO_USER_AVATAR";
    Scenario["SCENARIO_USER_BACKGROUND"] = "SCENARIO_USER_BACKGROUND";
    Scenario["SCENARIO_BOT_VOICE"] = "SCENARIO_BOT_VOICE";
    Scenario["SCENARIO_BOT_LOGO"] = "SCENARIO_BOT_LOGO";
    Scenario["SCENARIO_BOT_VOICE_SAMPLE_AUDIO"] = "SCENARIO_BOT_VOICE_SAMPLE_AUDIO";
    Scenario["SCENARIO_BOT_VOICE_LOGO"] = "SCENARIO_BOT_VOICE_LOGO";
    Scenario["SCENARIO_IM_CHAT"] = "SCENARIO_IM_CHAT";
    Scenario["SCENARIO_CURVE_COMMENT"] = "SCENARIO_CURVE_COMMENT";
})(Scenario || (Scenario = {}));
var ContentTypeEnum;
(function (ContentTypeEnum) {
    ContentTypeEnum["PNG"] = "CONTENT_TYPE_IMAGE_PNG";
    ContentTypeEnum["JPEG"] = "CONTENT_TYPE_IMAGE_JPEG";
    ContentTypeEnum["JPG"] = "CONTENT_TYPE_IMAGE_JPG";
    ContentTypeEnum["APNG"] = "CONTENT_TYPE_IMAGE_APNG";
    ContentTypeEnum["GIF"] = "CONTENT_TYPE_IMAGE_GIF";
    ContentTypeEnum["TIFF"] = "CONTENT_TYPE_IMAGE_TIFF";
    ContentTypeEnum["TIF"] = "CONTENT_TYPE_IMAGE_TIFF";
    ContentTypeEnum["BMP"] = "CONTENT_TYPE_IMAGE_BMP";
    ContentTypeEnum["MP3"] = "CONTENT_TYPE_MP3";
    ContentTypeEnum["WAV"] = "CONTENT_TYPE_AUDIO_WAV";
    ContentTypeEnum["OGG"] = "CONTENT_TYPE_AUDIO_OGG";
    ContentTypeEnum["FLAC"] = "CONTENT_TYPE_AUDIO_FLAC";
    ContentTypeEnum["APE"] = "CONTENT_TYPE_AUDIO_APE";
    ContentTypeEnum["WMA"] = "CONTENT_TYPE_AUDIO_WMA";
    ContentTypeEnum["TXT"] = "CONTENT_TYPE_TEXT_TXT";
    ContentTypeEnum["DOC"] = "CONTENT_TYPE_TEXT_DOC";
    ContentTypeEnum["DOCX"] = "CONTENT_TYPE_TEXT_DOCX";
    ContentTypeEnum["PDF"] = "CONTENT_TYPE_TEXT_PDF";
    ContentTypeEnum["MARKDOWN"] = "CONTENT_TYPE_TEXT_MARKDOWN";
    ContentTypeEnum["MD"] = "CONTENT_TYPE_TEXT_MARKDOWN";
    ContentTypeEnum["RTF"] = "CONTENT_TYPE_TEXT_RTF";
    ContentTypeEnum["MP4"] = "CONTENT_TYPE_VIDEO_MP4";
    ContentTypeEnum["AVI"] = "CONTENT_TYPE_VIDEO_AVI";
    ContentTypeEnum["MOV"] = "CONTENT_TYPE_VIDEO_MOV";
    ContentTypeEnum["WMV"] = "CONTENT_TYPE_VIDEO_WMV";
    ContentTypeEnum["FLV"] = "CONTENT_TYPE_VIDEO_FLV";
    ContentTypeEnum["ALL"] = "CONTENT_TYPE_ALL";
})(ContentTypeEnum || (ContentTypeEnum = {}));
var EmbedObjType;
(function (EmbedObjType) {
    EmbedObjType["UNKNOWN"] = "MESSAGE_METADATA_TYPE_UNSPECIFIED";
    EmbedObjType["IMAGE"] = "MESSAGE_METADATA_TYPE_IMAGE_FILE";
    EmbedObjType["DOC"] = "MESSAGE_METADATA_TYPE_TEXT_FILE";
    EmbedObjType["AUDIO"] = "MESSAGE_METADATA_TYPE_AUDIO_FILE";
    EmbedObjType["VIDEO"] = "MESSAGE_METADATA_TYPE_VIDEO_FILE";
    EmbedObjType["TEXT_CONTENT"] = "MESSAGE_METADATA_TYPE_TEXT_CONTENT";
    EmbedObjType["AUDIO_CONTENT"] = "MESSAGE_METADATA_TYPE_USER_AUDIO";
    EmbedObjType["ALL"] = "MESSAGE_METADATA_TYPE_ALL_FILE";
})(EmbedObjType || (EmbedObjType = {}));
var EmbedObjStatus;
(function (EmbedObjStatus) {
    EmbedObjStatus["UNKNOWN"] = "EMBED_OBJ_STATUS_UNSPECIFIED";
    EmbedObjStatus["PENDING"] = "EMBED_OBJ_STATUS_PENDING";
    EmbedObjStatus["PROCESSING"] = "EMBED_OBJ_STATUS_PROCESSING";
    EmbedObjStatus["DONE"] = "EMBED_OBJ_STATUS_DONE";
    EmbedObjStatus["ERROR"] = "EMBED_OBJ_STATUS_ERROR";
    EmbedObjStatus["DELETED"] = "EMBED_OBJ_STATUS_DELETED";
    EmbedObjStatus["QUEUEING"] = "EMBED_OBJ_STATUS_QUEUEING";
})(EmbedObjStatus || (EmbedObjStatus = {}));
var BizTypeEnum;
(function (BizTypeEnum) {
    BizTypeEnum["BIZ_TYPE_FEATURE_PAGE"] = "BIZ_TYPE_FEATURE_PAGE";
    BizTypeEnum["BIZ_TYPE_BOT"] = "BIZ_TYPE_BOT";
    BizTypeEnum["BIZ_TYPE_WIDGET"] = "BIZ_TYPE_WIDGET";
    BizTypeEnum["BIZ_TYPE_UNSPECIFIED"] = "BIZ_TYPE_UNSPECIFIED";
    BizTypeEnum["BIZ_TYPE_FORUM_POST"] = "BIZ_TYPE_FORUM_POST";
})(BizTypeEnum || (BizTypeEnum = {}));
const replaceSpecialChars = (str) => {
    return str.replace(/[:/?#$&+=@%{}\[\]]/g, '');
};
function getPreSignUrl(fileInfo) {
    return APIFetch.post('/v1/resource/get_put_object_pre_sign_url', {
        body: {
            fileInfo
        },
        isGoLang: true
    });
}
async function uploadFileToS3(scenario, suffix, file) {
    var _a;
    const contentType = (_a = ContentTypeEnum[(suffix.startsWith('.') ? suffix.substring(1) : suffix).toUpperCase()]) !== null && _a !== void 0 ? _a : ContentTypeEnum.ALL;
    const preSignResponse = await getPreSignUrl({
        scenario,
        contentType,
        fileName: replaceSpecialChars(file.name),
        contentLength: String(file.size)
    });
    const response = await fetch(preSignResponse.data.uploadUrl, {
        method: 'PUT',
        headers: {
            Expires: preSignResponse.data.expiresAt,
            'Content-Type': preSignResponse.data.contentType
        },
        body: file
    });
    if (response.ok) {
        return preSignResponse.data;
    }
    return { objectKey: '', objectAccessUrl: '' };
}
async function uploadFileToS3WithProgress({ scenario, contentType, file, onProgress, cancelToken }) {
    const preSignResponse = await getPreSignUrl({
        scenario,
        contentType: contentType || ContentTypeEnum.ALL,
        fileName: replaceSpecialChars(file.name),
        contentLength: String(file.size)
    });
    const res = await new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        const cancel = () => {
            xhr.abort();
        };
        if (cancelToken) {
            cancelToken(cancel);
        }
        xhr.timeout = 120000;
        xhr.open('PUT', preSignResponse.data.uploadUrl);
        xhr.setRequestHeader('expires', preSignResponse.data.expiresAt);
        xhr.setRequestHeader('Content-Type', preSignResponse.data.contentType);
        xhr.upload.onprogress = event => {
            if (event.lengthComputable) {
                const p = Math.round((event.loaded * 100) / event.total);
                onProgress(p);
            }
        };
        xhr.onerror = () => {
            reject({ success: false, msg: 'upload error', code: 400 });
        };
        xhr.onabort = () => {
            reject({ success: false, msg: 'the request has been aborted' });
        };
        xhr.upload.onabort = () => {
            reject({ success: false, msg: 'the request has been aborted' });
        };
        xhr.onload = () => {
            if (xhr.status === 200) {
                resolve({ success: true, msg: 'upload success' });
            }
        };
        xhr.ontimeout = e => {
            reject({ success: false, msg: 'timeout' });
        };
        xhr.send(file);
    }).catch(e => {
        console.error(e);
        return { success: false, msg: 'something is wrong!', code: 400 };
    });
    if (res.success) {
        return Object.assign(Object.assign({}, preSignResponse.data), { success: true });
    }
    return { objectKey: '', objectAccessUrl: '', success: false, code: res.code };
}

const isSameSet = (set1, set2) => {
    if (set1 === set2) {
        return true;
    }
    if (set1.size !== set2.size) {
        return false;
    }
    for (const item of set1) {
        if (!set2.has(item)) {
            return false;
        }
    }
    return true;
};

const limitQueue = (concurrency) => {
    let queue = [];
    let activeCount = 0;
    const next = () => {
        activeCount--;
        if (queue.length > 0) {
            queue.shift()();
        }
    };
    const run = async (function_, resolve, arguments_) => {
        activeCount++;
        const result = (async () => function_(...arguments_))();
        resolve(result);
        try {
            await result;
        }
        catch (_a) { }
        next();
    };
    const enqueue = (function_, resolve, arguments_) => {
        queue.push(run.bind(undefined, function_, resolve, arguments_));
        (async () => {
            await Promise.resolve();
            if (activeCount < concurrency && queue.length > 0) {
                queue.shift()();
            }
        })();
    };
    const generator = ((function_, ...arguments_) => new Promise(resolve => {
        enqueue(function_, resolve, arguments_);
    }));
    Object.defineProperties(generator, {
        activeCount: {
            get: () => activeCount
        },
        pendingCount: {
            get: () => queue.length
        },
        clearQueue: {
            value() {
                queue = [];
            }
        }
    });
    return generator;
};

immer$1.enableMapSet();
const fileQueue$1 = limitQueue(1);
const DEFAULT_STATE$4 = {
    languageList: [],
    ttsList: [],
    noCodeCheckPassed: false,
    pendingVoiceIds: new Set(),
    uncheckedSet: new Set(),
    selectedTTSId: '',
    oriForm: null,
    currentForm: null,
    editNotSave: false,
    ttsContentMap: new Map(),
    widgetList: [],
    cardWidgetList: [],
    widgetFilters: [],
    widgetName: '',
    filterValues: {},
    widgetPageToken: '0',
    widgetDataPush: false,
    gettingChatWidgetList: false,
    chatWidgetHasMore: false,
    chatWidgetPageToken: '0',
    sidebarWidgetList: null,
    gettingChatBotList: false,
    sidebarMyBotList: null,
    sidebarToolboxList: null,
    draftBotIds: new Set(),
    widgetStateMap: {},
    fileUpload: { uploading: null, filesMap: {}, deletedList: [], alert: {}, dragModal: false },
    widgetErrorChatRecordList: [],
    widgetInputType: 'text',
    lastWidgetInputType: 'text',
    widgetSending: false,
    selectedWidgetDeleteChatList: [],
    sentWidgetMsgIdList: new Set(),
    widgetTextInputMap: {},
    childTagsObj: {},
    initializeScrolled: false,
    poped: false,
    newlyAdded: false,
    widgetLastMessageMap: new Map(),
    widgetDriverChatId: '',
    widgetStartJobIds: [],
    recommend: { banners: [], list: [] },
    tagFilters: [],
    searchList: [],
    deployInfoMap: {},
    deployCount: {
        currentCount: 0,
        totalLimit: 0
    }
};
const createWorkshopSlice = (set, get) => {
    return Object.assign(Object.assign({}, DEFAULT_STATE$4), { setNoCodeCheckPassed(noCodeCheckPassed) {
            set({ noCodeCheckPassed }, false, 'setNoCodeCheckPassed');
        },
        setRecommend(recommend) {
            set({ recommend }, false, 'setRecommend');
        },
        setTagFilters(tagFilters) {
            set({ tagFilters }, false, 'setTagFilters');
        },
        setSearchList(searchList) {
            set({ searchList }, false, 'setSearchList');
        },
        setCardWidgetList(cardWidgets) {
            set({ cardWidgetList: cardWidgets }, false, 'setCardWidgetList');
        },
        setWidgetSearchList(widgets) {
            set({ widgetList: widgets }, false, 'setWidgetSearchList');
        },
        setWidgetFilters(widgetFilters) {
            set({ widgetFilters }, false, 'setWidgetFilters');
        },
        setWidgetName(widgetName) {
            set({ widgetName }, false, 'setWidgetName');
        },
        setWidgetDataPush(widgetDataPush) {
            set({ widgetDataPush }, false, 'setWidgetDataPush');
        },
        setLanguageList(list) {
            set({ languageList: list }, false, 'setLanguageList');
        },
        setTTSList(list) {
            set({ ttsList: list }, false, 'setTTSList');
        },
        removeItemFromUncheckedSet(id) {
            set(state => {
                state.uncheckedSet.delete(id);
            }, false, 'removeItemFromUncheckedSet');
        },
        setSelectedTTSId(ttsId) {
            set({ selectedTTSId: ttsId || '' }, false, '`setSelected`TTSId');
        },
        setOriForm(oriForm) {
            set({ oriForm: oriForm || null }, false, 'setOriForm');
        },
        setCurrentForm(currentForm) {
            set({ currentForm: currentForm || null }, false, 'setCurrentForm');
        },
        setCurrentFormItem(key, value) {
            set(state => {
                state.currentForm[key] = value;
            }, false, 'setCurrentFormItem');
        },
        setEditNotSave() {
            set(state => {
                const oriForm = state.oriForm || {};
                const currentForm = state.currentForm || {};
                const compareKeys = Object.keys(oriForm) || [];
                if (compareKeys.length <= 0)
                    return false;
                state.editNotSave = !compareKeys.every(key => {
                    var _a, _b, _c, _d;
                    const oriValue = typeof (oriForm === null || oriForm === void 0 ? void 0 : oriForm[key]) === 'string'
                        ? (_b = (_a = oriForm === null || oriForm === void 0 ? void 0 : oriForm[key]) === null || _a === void 0 ? void 0 : _a.replaceAll('\r', '')) === null || _b === void 0 ? void 0 : _b.replaceAll('\n', '')
                        : oriForm === null || oriForm === void 0 ? void 0 : oriForm[key];
                    const curValue = typeof (currentForm === null || currentForm === void 0 ? void 0 : currentForm[key]) === 'string'
                        ? (_d = (_c = currentForm === null || currentForm === void 0 ? void 0 : currentForm[key]) === null || _c === void 0 ? void 0 : _c.replaceAll('\r', '')) === null || _d === void 0 ? void 0 : _d.replaceAll('\n', '')
                        : currentForm === null || currentForm === void 0 ? void 0 : currentForm[key];
                    return oriValue == curValue;
                });
            }, false, 'setEditNotSave');
        },
        getTtsContent(ttsId, content) {
            const ttsVocies = get().ttsContentMap.get(`${ttsId}`);
            if (Array.isArray(ttsVocies)) {
                const matchedVoice = ttsVocies.find(voice => voice.content === content);
                if (matchedVoice) {
                    return matchedVoice.voiceUrl;
                }
            }
        },
        setDraftBotIds(botIds) {
            const oldBotIds = get().draftBotIds;
            const newBotIds = typeof botIds === 'function' ? botIds(oldBotIds) : botIds;
            if (!isSameSet(oldBotIds, newBotIds)) {
                set(state => {
                    state.draftBotIds = newBotIds;
                });
            }
        },
        async widgetUploadFiles(widgetId, files, retry) {
            set(state => {
                const botFiles = state.fileUpload.filesMap[widgetId] || [];
                if (retry) {
                    const newFiles = botFiles.map(file => {
                        if (file.id === files[0].id) {
                            return files[0];
                        }
                        return file;
                    });
                    state.fileUpload.filesMap[widgetId] = [...newFiles];
                }
                else {
                    state.fileUpload.filesMap[widgetId] = [...botFiles, ...files];
                }
            });
            for (const file of files) {
                fileQueue$1(async () => {
                    const { deletedList } = get().fileUpload;
                    if (deletedList.includes(file.id)) {
                        set(state => {
                            state.fileUpload.deletedList = state.fileUpload.deletedList.filter(id => id !== file.id);
                        });
                        return;
                    }
                    set(state => {
                        state.fileUpload.uploading = file;
                    });
                    const res = await uploadFileToS3WithProgress({
                        scenario: Scenario.SCENARIO_IM_CHAT,
                        contentType: file.uiData.contentType,
                        onProgress: value => {
                            set(state => {
                                state.fileUpload.uploading = Object.assign(Object.assign({}, file), { progress: value });
                            });
                        },
                        file: file.file,
                        cancelToken: (cancel) => {
                            set(state => {
                                const botFiles = state.fileUpload.filesMap[widgetId] || [];
                                const newBotFiles = botFiles.map(botFile => {
                                    if (botFile.id === file.id) {
                                        return Object.assign(Object.assign({}, botFile), { cancelToken: {
                                                cancel
                                            } });
                                    }
                                    return botFile;
                                });
                                state.fileUpload.filesMap[widgetId] = newBotFiles;
                            });
                        }
                    });
                    const deletedListAfter = get().fileUpload.deletedList;
                    if (deletedListAfter.includes(file.id)) {
                        set(state => {
                            state.fileUpload.deletedList = state.fileUpload.deletedList.filter(id => id !== file.id);
                            state.fileUpload.uploading = null;
                        });
                        return;
                    }
                    set(state => {
                        if (fileQueue$1.pendingCount === 0) {
                            state.fileUpload.uploading = null;
                        }
                        const { deletedList } = state.fileUpload;
                        if (deletedList.includes(file.id)) {
                            state.fileUpload.uploading = null;
                        }
                        const botFiles = state.fileUpload.filesMap[widgetId] || [];
                        const newFiles = botFiles.map(f => {
                            if (f.id === file.id) {
                                return Object.assign(Object.assign({}, f), { status: (res === null || res === void 0 ? void 0 : res.objectAccessUrl) ? 'completed' : 'error', url: res === null || res === void 0 ? void 0 : res.objectAccessUrl });
                            }
                            return f;
                        });
                        state.fileUpload.filesMap[widgetId] = newFiles;
                    });
                });
            }
        },
        setInitializeScrolled(initializeScrolled) {
            set(state => {
                state.initializeScrolled = initializeScrolled;
            }, false, 'setInitializeScrolled');
        },
        setPoped(status) {
            set(state => {
                state.poped = status;
            }, false, 'setPoped');
        },
        setNewlyAdded(status) {
            set(state => {
                state.newlyAdded = status;
            }, false, 'setNewlyAdded');
        },
        setWidgetFileAlert(data) {
            set(state => {
                state.fileUpload.alert = data;
            });
        },
        showWidgetDragModal(val) {
            set(state => {
                state.fileUpload.dragModal = val;
            });
        },
        async getDeployment(data) {
            if (data.shell_agent_file_url) {
                try {
                    for (let i = 0; i < 3; i++) {
                        const result = await getDeployment(data);
                        if (result.success) {
                            set(state => {
                                lodashEs.set(state.deployInfoMap, [data.bot_id || '0', data.shell_agent_file_url], result === null || result === void 0 ? void 0 : result.data);
                            });
                            break;
                        }
                        else {
                            set(state => {
                                lodashEs.set(state.deployInfoMap, [data.bot_id || '0', data.shell_agent_file_url], {
                                    status: result.reason,
                                    msg: result.msg
                                });
                            });
                        }
                    }
                }
                catch (err) {
                    console.log("err: ", err);
                }
            }
        },
        async getDeploymentCount() {
            try {
                for (let i = 0; i < 3; i++) {
                    const result = await getDeploymentCount();
                    if (result.success) {
                        set(state => {
                            state.deployCount = result === null || result === void 0 ? void 0 : result.data;
                        });
                        break;
                    }
                }
            }
            catch (err) {
                console.log("err: ", err);
            }
        } });
};
const computeState$2 = (state) => ({
    workshopListInitialized: state.sidebarMyBotList != null && state.sidebarWidgetList != null
});
zustand.create()(computed__default.default(immer(devtools(createWorkshopSlice, { store: 'workshop' })), computeState$2));

const DEFAULT_STATE$3 = {
    searchList: [],
    tagFilters: { tagList: [], sortList: [] },
    postFullView: undefined,
    showPost: undefined,
    postDetail: {},
    postLoading: true,
    setPostDetail: () => { },
    setPostLoading: () => { }
};
const computeState$1 = (state) => ({
    history: []
});
zustand.create()(computed__default.default((set, get) => (Object.assign(Object.assign({}, DEFAULT_STATE$3), { setSearchList: (searchList) => {
        set({ searchList });
    }, setTagFilters: (tagFilters) => {
        set({ tagFilters });
    }, setPostFullView: (postFullView) => {
        set({ postFullView });
    }, setShowPost: (showPost) => {
        set({ showPost });
    }, setPostDetail: (postDetail) => {
        set({ postDetail });
    }, setPostLoading: (postLoading) => {
        set({ postLoading });
    } })), computeState$1));

const GlobalStoreContext = React.createContext(undefined);
const GlobalStoreProvider = ({ children, nonce, isMobile }) => {
    const storeRef = React.useRef();
    const isMobileDevice = reactUse.useMedia('(max-width: 768px)', isMobile);
    if (!storeRef.current) {
        storeRef.current = createGlobalStore({ nonce, isMobile: isMobileDevice });
    }
    React.useEffect(() => {
        var _a;
        (_a = storeRef.current) === null || _a === void 0 ? void 0 : _a.getState().setIsMobile(isMobileDevice);
    }, [isMobileDevice]);
    return jsxRuntime.jsx(GlobalStoreContext.Provider, { value: storeRef.current, children: children });
};
const useGlobalStore = (selector) => {
    const globalStoreContext = React.useContext(GlobalStoreContext);
    if (!globalStoreContext) {
        throw new Error(`globalStoreContext must be used within globalStoreProvider`);
    }
    return zustand.useStore(globalStoreContext, selector);
};

var __rest$w = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const PopoverRoot = PopoverPrimitive__namespace.Root;
const PopoverTrigger = PopoverPrimitive__namespace.Trigger;
const PopoverContent = React__namespace.forwardRef((_a, ref) => {
    var { className, align = 'center', variant = 'default', side = 'top', sideOffset = 4, alignOffset = 0, showArrow = true, children, container } = _a, props = __rest$w(_a, ["className", "align", "variant", "side", "sideOffset", "alignOffset", "showArrow", "children", "container"]);
    return (jsxRuntime.jsx(PopoverPrimitive__namespace.Portal, { container: container, children: jsxRuntime.jsxs(PopoverPrimitive__namespace.Content, Object.assign({ ref: ref, align: align, alignOffset: alignOffset, sideOffset: sideOffset, side: side, forceMount: true, className: cn('relative z-[49] w-fit max-w-72 text-xs mx-4 p-3 text-left rounded-lg border border-opaque shadow-modal-default outline-none data-[state=open]:animate-in [&[data-state=open]>span]:animate-none data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2', variant === 'default'
                ? 'bg-surface-search-field text-subtle'
                : variant === 'info'
                    ? 'bg-surface-accent-yellow-subtle text-warning-bolder'
                    : 'bg-utility-sky-blue-500 text-static', className) }, props, { children: [children, showArrow && (jsxRuntime.jsx(PopoverPrimitive__namespace.Arrow, { width: 16, height: 6, className: cn('visible', variant === 'default'
                        ? 'fill-surface-search-field'
                        : variant === 'info'
                            ? 'fill-surface-accent-yellow-subtle'
                            : 'fill-utility-sky-blue-500') }))] })) }));
});
PopoverContent.displayName = PopoverPrimitive__namespace.Content.displayName;
const Popover = (_a) => {
    var { disabled = false, open, content, anchor, children, className, triggerClassName, hasOpenState = false, isMTooltip = false, modal = false, openChangeCallback } = _a, props = __rest$w(_a, ["disabled", "open", "content", "anchor", "children", "className", "triggerClassName", "hasOpenState", "isMTooltip", "modal", "openChangeCallback"]);
    return (jsxRuntime.jsxs(PopoverRoot, Object.assign({ open: disabled ? false : open, modal: modal, onOpenChange: openChangeCallback }, props, { children: [anchor, content && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { className: cn('inline-flex items-center justify-center', hasOpenState && 'data-[state=open]:bg-surface-hovered', triggerClassName), onClick: e => {
                            if (isMTooltip) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        }, children: jsxRuntime.jsx(PopoverTrigger, { asChild: true, children: jsxRuntime.jsx("div", { className: cn('inline-flex items-center justify-center', hasOpenState && 'data-[state=open]:bg-surface-hovered', triggerClassName), children: children }) }) }), jsxRuntime.jsx(PopoverContent, Object.assign({}, props, { className: cn('w-fit max-w-[324px]', className), onCloseAutoFocus: e => e.preventDefault(), children: content }))] })), !content && children] })));
};

var __rest$v = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const colorMap = {
    default: 'text-default',
    subtle: 'text-subtle',
    subtler: 'text-subtler',
    subtlest: 'text-subtlest',
    disabled: 'text-disabled',
    inverse: 'text-inverse',
    static: 'text-static',
    'static-black': 'text-static-black',
    brand: 'text-brand',
    critical: 'text-critical',
    'critical-bolder': 'text-critical-bolder',
    warning: 'text-warning',
    'warning-bolder': 'text-warning-bolder',
    success: 'text-success',
    'success-bolder': 'text-success-bolder'
};
const lineClampMap = {
    1: 'line-clamp-1',
    2: 'line-clamp-2',
    3: 'line-clamp-3',
    4: 'line-clamp-4',
    5: 'line-clamp-5',
    6: 'line-clamp-6'
};
const displayVariants = classVarianceAuthority.cva('font-semibold', {
    variants: {
        size: {
            '2xl': 'text-7xl',
            xl: 'text-5xl',
            lg: 'text-3xl',
            md: 'text-2xl',
            sm: 'text-xl',
            xs: 'text-lg'
        },
        color: colorMap,
        lineClamp: lineClampMap
    },
    defaultVariants: {
        size: 'lg',
        color: 'default'
    }
});
const headingVariants = classVarianceAuthority.cva('font-medium', {
    variants: {
        size: {
            h1: 'text-2xl',
            h2: 'text-xl',
            h3: 'text-lg',
            h4: 'text-base',
            h5: 'text-sm'
        },
        color: colorMap,
        lineClamp: lineClampMap
    },
    defaultVariants: {
        size: 'h1',
        color: 'default'
    }
});
const subHeadingVariants = classVarianceAuthority.cva('text-default', {
    variants: {
        size: {
            sm: 'text-xs',
            lg: 'text-sm'
        },
        color: colorMap,
        lineClamp: lineClampMap
    },
    defaultVariants: {
        size: 'lg',
        color: 'default'
    }
});
const textVariants = classVarianceAuthority.cva('', {
    variants: {
        size: {
            xs: 'text-xs',
            sm: 'text-sm',
            lg: 'text-base'
        },
        weight: {
            regular: 'font-normal',
            medium: 'font-medium',
            semibold: 'font-semibold'
        },
        color: colorMap,
        lineClamp: lineClampMap
    },
    defaultVariants: {
        size: 'lg',
        weight: 'regular',
        color: 'default'
    }
});
const descriptionVariants = classVarianceAuthority.cva('', {
    variants: {
        size: {
            lg: 'text-xs',
            sm: 'text-2xs'
        },
        weight: {
            regular: 'font-normal',
            medium: 'font-medium'
        },
        color: colorMap,
        lineClamp: lineClampMap
    },
    defaultVariants: {
        size: 'lg',
        weight: 'regular',
        color: 'subtler'
    }
});
const HComponentMap = {
    h1: 'h1',
    h2: 'h2',
    h3: 'h3',
    h4: 'h4',
    h5: 'h5',
    h6: 'h6'
};
const TextComponentMap = {
    p: 'p',
    blockquote: 'blockquote',
    span: 'span',
    code: 'code',
    bold: 'b',
    italic: 'i',
    strikethrough: 's',
    underline: 'u'
};
const renderBlock = ({ underline = false, strikethrough = false, strong = false, italic = false }, defaultValue = 'p') => {
    const underlineValue = underline && 'underline';
    const strikethroughValue = strikethrough && 'strikethrough';
    const strongValue = strong && 'bold';
    const italicValue = italic && 'italic';
    return TextComponentMap[underlineValue || strikethroughValue || strongValue || italicValue || defaultValue];
};
const dangerouText = (text) => {
    return isomorphicDompurify.sanitize(`${text}`, {
        ADD_ATTR: ['target'],
        FORBID_TAGS: [
            'style',
            'form',
            'input',
            'checkbox',
            'svg',
            'script',
            'iframe',
            'object',
            'embed',
            'applet',
            'meta',
            'link',
            'button',
            'textarea',
            'select',
            'option'
        ],
        FORBID_ATTR: ['action', 'style', 'data-*', 'aria-*', 'srcset', 'on*']
    });
};
const Heading = React__namespace.forwardRef((props, ref) => {
    const { className, size, color, lineClamp, children, dangerous } = props, passProps = __rest$v(props, ["className", "size", "color", "lineClamp", "children", "dangerous"]);
    const Comp = HComponentMap[size || 'h1'];
    const text = dangerous && dangerouText(`${children}`);
    return (jsxRuntime.jsx(Comp, Object.assign({ ref: ref, className: cn(headingVariants({ size, color, lineClamp }), className) }, passProps, (dangerous && { dangerouslySetInnerHTML: { __html: `${text}` } }), { children: !dangerous ? children : null })));
});
const Display$1 = React__namespace.forwardRef((props, ref) => {
    const { className, size, color, lineClamp, underline, strikethrough, strong, italic, children, dangerous } = props, passProps = __rest$v(props, ["className", "size", "color", "lineClamp", "underline", "strikethrough", "strong", "italic", "children", "dangerous"]);
    const Comp = renderBlock({
        underline,
        strikethrough,
        strong,
        italic
    }, 'span');
    const text = dangerous && dangerouText(`${children}`);
    return (jsxRuntime.jsx(Comp, Object.assign({ ref: ref, className: cn(displayVariants({ size, color, lineClamp }), className) }, lodashEs.omit(passProps, 'lineClamp'), (dangerous && { dangerouslySetInnerHTML: { __html: `${text}` } }), { children: !dangerous ? children : null })));
});
React__namespace.forwardRef((props, ref) => {
    const { className, size, color, children, lineClamp } = props, passProps = __rest$v(props, ["className", "size", "color", "children", "lineClamp"]);
    return (jsxRuntime.jsx("p", Object.assign({ ref: ref, className: cn(subHeadingVariants({ size, color, lineClamp }), className) }, passProps, { children: children })));
});
const Text = React__namespace.forwardRef((props, ref) => {
    const { className, size, weight, color, lineClamp, underline, strikethrough, strong, italic, children, dangerous } = props, passProps = __rest$v(props, ["className", "size", "weight", "color", "lineClamp", "underline", "strikethrough", "strong", "italic", "children", "dangerous"]);
    const Comp = renderBlock({
        underline,
        strikethrough,
        strong,
        italic
    }, 'span');
    const text = dangerous && dangerouText(`${children}`);
    return (jsxRuntime.jsx(Comp, Object.assign({ ref: ref, className: cn(textVariants({ size, weight, color, lineClamp }), className) }, lodashEs.omit(passProps, 'lineClamp'), (dangerous && { dangerouslySetInnerHTML: { __html: `${text}` } }), { children: !dangerous ? children : null })));
});
React__namespace.forwardRef((props, ref) => {
    const { className, size, weight, color, lineClamp, underline, strikethrough, strong, italic, children, dangerous } = props, passProps = __rest$v(props, ["className", "size", "weight", "color", "lineClamp", "underline", "strikethrough", "strong", "italic", "children", "dangerous"]);
    const Comp = renderBlock({
        underline,
        strikethrough,
        strong,
        italic
    }, 'p');
    const text = dangerous && dangerouText(`${children}`);
    return (jsxRuntime.jsx(Comp, Object.assign({ ref: ref, className: cn(textVariants({ size, weight, color, lineClamp }), className) }, passProps, (dangerous && { dangerouslySetInnerHTML: { __html: `${text}` } }), { children: !dangerous ? children : null })));
});
const Description$1 = React__namespace.forwardRef((props, ref) => {
    const { className, size, weight, color, lineClamp, underline, strikethrough, strong, italic, children, dangerous } = props, passProps = __rest$v(props, ["className", "size", "weight", "color", "lineClamp", "underline", "strikethrough", "strong", "italic", "children", "dangerous"]);
    const Comp = renderBlock({
        underline,
        strikethrough,
        strong,
        italic
    }, 'span');
    const text = dangerous && dangerouText(`${children}`);
    return (jsxRuntime.jsx(Comp, Object.assign({ ref: ref, className: cn(descriptionVariants({ size, weight, color, lineClamp }), className) }, lodashEs.omit(passProps, 'lineClamp'), (dangerous && { dangerouslySetInnerHTML: { __html: `${text}` } }), { children: !dangerous ? children : null })));
});

var __rest$u = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const TooltipProvider = TooltipPrimitive__namespace.Provider;
const TooltipTrigger = TooltipPrimitive__namespace.Trigger;
const TooltipArrow = TooltipPrimitive__namespace.Arrow;
const Tooltip = React__namespace.forwardRef((_a, ref) => {
    var { open, defaultOpen, disabled = false, children, title, description, size = 'sm', titleDangerous = false, descriptionDangerous = false, contentClassName, triggerClassName } = _a, props = __rest$u(_a, ["open", "defaultOpen", "disabled", "children", "title", "description", "size", "titleDangerous", "descriptionDangerous", "contentClassName", "triggerClassName"]);
    const isDesktop = !useGlobalStore(state => state.isMobile);
    const defaultTitleColor = props.variant === 'message' ? 'static' : props.variant === 'default' ? 'warning-bolder' : 'default';
    const defaultDescColor = props.variant === 'message' ? 'static' : props.variant === 'info' ? 'warning-bolder' : 'default';
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: isDesktop ? (jsxRuntime.jsx(TooltipProvider, { children: jsxRuntime.jsxs(TooltipPrimitive__namespace.Root, { open: disabled || (!description && !title) ? false : open, defaultOpen: defaultOpen, children: [jsxRuntime.jsx(TooltipTrigger, { asChild: true, children: jsxRuntime.jsx("div", { className: cn('cursor-pointer', triggerClassName), children: children }) }), jsxRuntime.jsxs(TooltipContent, Object.assign({ ref: ref, className: contentClassName }, props, { children: [title && (jsxRuntime.jsx("p", { className: "mb-1", children: jsxRuntime.jsx(Description$1, { size: "lg", weight: "medium", color: defaultTitleColor, dangerous: titleDangerous, className: cn(size === 'md' && 'text-sm'), children: title }) })), description && (jsxRuntime.jsx(Description$1, { size: "lg", weight: title ? 'regular' : 'medium', color: title ? 'subtle' : defaultDescColor, dangerous: descriptionDangerous, className: cn(size === 'md' && 'text-sm'), children: description }))] }))] }) })) : (jsxRuntime.jsx(Popover, Object.assign({ open: open, content: description, disabled: disabled, triggerClassName: triggerClassName, className: cn(contentClassName, size === 'md' && 'text-sm'), isMTooltip: true }, props, { children: children }))) }));
});
Tooltip.displayName = TooltipPrimitive__namespace.Root.displayName;
const TooltipContent = React__namespace.forwardRef((_a, ref) => {
    var { className, variant = 'default', align = 'center', side = 'top', sideOffset = 4, alignOffset = 0, showArrow = true, arrowClassName } = _a, props = __rest$u(_a, ["className", "variant", "align", "side", "sideOffset", "alignOffset", "showArrow", "arrowClassName"]);
    return (jsxRuntime.jsxs(TooltipPrimitive__namespace.Content, Object.assign({ ref: ref, align: align, sideOffset: sideOffset, alignOffset: alignOffset, side: side, className: cn('relative z-[49] w-fit max-w-72 text-xs mx-4 px-3 py-2 text-left rounded-lg shadow-modal-bolder ', 'outline-none delay-0 data-[state=open]:animate-in [&[data-state=open]>span]:animate-none data-[state=open]:fade-in-0 ', 'data-[state=delayed-open]:animate-in [&[data-state=delayed-open]>span]:animate-none data-[state=delayed-open]:fade-in-0 ', 'data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 ', 'data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2', variant === 'default'
            ? 'bg-alpha-100 text-default'
            : variant === 'info'
                ? 'bg-surface-accent-yellow-subtle text-warning-bolder'
                : 'bg-utility-sky-blue-500 text-default', className) }, props, { children: [props.children, showArrow && (jsxRuntime.jsx(TooltipArrow, { width: 12, height: 6, className: cn(variant === 'default'
                    ? 'fill-alpha-100'
                    : variant === 'info'
                        ? 'fill-surface-accent-yellow-subtle'
                        : 'fill-utility-sky-blue-500', arrowClassName) }))] })));
});
TooltipContent.displayName = TooltipPrimitive__namespace.Content.displayName;

var __rest$t = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const iconButtonVariants = classVarianceAuthority.cva('shrink-0 inline-flex items-center justify-center whitespace-nowrap rounded-full font-medium transition-colors ring-offset-surface-default focus-visible:outline-none focus-visible:shadow-none focus-visible:ring-2 focus-visible:ring-brand focus-visible:ring-offset-1 disabled:pointer-events-none disabled:opacity-30 disabled:shadow-none', {
    variants: {
        variant: {
            primary: 'bg-surface-primary-default text-icon-static shadow-button-primary hover:bg-surface-primary-hovered active:bg-surface-primary-pressed',
            outline: 'border border-default text-icon-subtle shadow-button-basic hover:bg-surface-hovered focus:bg-surface-pressed active:shadow-button-pressed',
            ghost: 'text-icon hover:bg-surface-hovered active:bg-surface-pressed'
        },
        color: {
            default: '',
            brand: '',
            warning: '',
            error: '',
            gray: '',
            static: 'text-icon-static hover:bg-transparent active:bg-transparent'
        },
        size: {
            xs: 'h-5 w-5 text-xs',
            sm: 'h-7 w-7 text-sm',
            m: 'h-8 w-8 text-sm',
            md: 'h-9 w-9 text-sm',
            lg: 'h-11 w-11'
        }
    },
    compoundVariants: [
        {
            variant: 'primary',
            color: 'default',
            className: 'text-icon-brand bg-surface-search-field border border-default hover:bg-surface-hovered active:bg-surface-pressed shadow-button-basic disabled:bg-surface-disabled disabled:text-surface-accent-blue-subtle [&>svg]:disabled:text-surface-accent-blue-subtle disabled:opacity-100'
        },
        {
            variant: 'primary',
            color: 'brand',
            className: 'bg-surface-primary-default hover:bg-surface-primary-hovered active:bg-surface-primary-pressed'
        },
        {
            variant: 'primary',
            color: 'warning',
            className: 'bg-surface-warning-default hover:bg-surface-warning-hovered active:bg-surface-warning-pressed'
        },
        {
            variant: 'primary',
            color: 'error',
            className: 'bg-surface-critical-default hover:bg-surface-critical-hovered active:bg-surface-critical-pressed'
        },
        {
            variant: 'primary',
            color: 'gray',
            className: 'text-icon-default bg-surface-search-field border border-default hover:bg-surface-hovered active:bg-surface-pressed shadow-button-basic disabled:bg-surface-disabled disabled:text-disabled disabled:opacity-100 [&>svg]:disabled:text-icon-disabled'
        },
        {
            variant: 'outline',
            color: 'default',
            className: 'border-default text-icon shadow-button-basic active:shadow-button-pressed'
        },
        {
            variant: 'outline',
            color: 'brand',
            className: 'border-surface-primary-default text-icon-brand'
        },
        {
            variant: 'outline',
            color: 'warning',
            className: 'border-surface-warning-default text-icon-warning hover:bg-surface-warning-subtle-hovered active:bg-surface-warning-subtle-pressed'
        },
        {
            variant: 'outline',
            color: 'error',
            className: 'border-surface-critical-default text-icon-critical hover:bg-surface-critical-subtle-hovered active:bg-surface-critical-subtle-pressed'
        },
        {
            variant: 'outline',
            color: 'gray',
            className: 'text-icon-subtle hover:bg-surface-hovered active:shadow-button-pressed'
        },
        {
            variant: 'ghost',
            color: 'default',
            className: 'text-icon'
        },
        {
            variant: 'ghost',
            color: 'brand',
            className: 'text-icon-brand'
        },
        {
            variant: 'ghost',
            color: 'warning',
            className: 'text-icon-warning focus:shadow-rings-warning'
        },
        {
            variant: 'ghost',
            color: 'error',
            className: 'text-icon-critical focus:shadow-rings-error'
        },
        {
            variant: 'ghost',
            color: 'gray',
            className: 'text-icon-default hover:text-icon-default'
        }
    ],
    defaultVariants: {
        variant: 'primary',
        color: 'brand',
        size: 'lg'
    }
});
const IconButton = React__namespace.forwardRef((_a, ref) => {
    var { className, variant, size, color, asChild = false, loading = false, children, icon: IconEle, disabled, hoverText } = _a, passProps = __rest$t(_a, ["className", "variant", "size", "color", "asChild", "loading", "children", "icon", "disabled", "hoverText"]);
    const Comp = asChild ? reactSlot.Slot : 'button';
    const iconCls = cn({
        'w-3 h-3': size === 'xs',
        'w-4.5 h-4.5': size === 'sm',
        'w-5.5 h-5.5': size === 'md',
        'w-6 h-6': size === 'lg'
    });
    const disable = disabled || loading;
    return (jsxRuntime.jsx(Tooltip, { sideOffset: 4, size: "md", description: hoverText, children: jsxRuntime.jsx(Comp, Object.assign({ className: cn(iconButtonVariants({ variant, size, color }), disable && 'cursor-not-allowed !pointer-events-auto', className), ref: ref, disabled: disable }, passProps, { children: loading ? (jsxRuntime.jsx(lucideReact.Loader2, { className: cn('animate-spin', iconCls) })) : IconEle ? (jsxRuntime.jsx(IconEle, { className: iconCls })) : React__namespace.isValidElement(children) ? (React__namespace.cloneElement(children, {
                className: cn(iconCls, children.props.className)
            })) : null })) }));
});

function CustomNotificationElement({ tProps, customProps }) {
    const { type, title, content, isClosable = false, translateInToast } = customProps;
    const { id } = tProps;
    const t = nextIntl.useTranslations();
    const displayedContent = !isString(content) ? JSON.stringify(content) : content;
    return (jsxRuntime.jsx("div", { children: jsxRuntime.jsx("div", { id: id, className: "z-[10000000] min-h-10 w-fit max-w-[90vw] md:max-w-[560px] rounded-full bg-surface-search-field border-opaque border shadow-modal-default py-2 px-3", children: jsxRuntime.jsxs("div", { className: "flex items-center justify-center w-full space-x-2", children: [type && (jsxRuntime.jsxs("div", { className: "flex-shrink-0 flex items-center", children: [type === 'info' && jsxRuntime.jsx(ForwardRef$h, { className: "text-surface-info-default w-6 h-6" }), type === 'success' && jsxRuntime.jsx(ForwardRef$W, { className: "text-surface-success-default w-6 h-6" }), type === 'warning' && jsxRuntime.jsx(ForwardRef$i, { className: "text-surface-warning-default w-6 h-6" }), type === 'error' && jsxRuntime.jsx(ForwardRef$V, { className: "text-icon-critical w-6 h-6" })] })), jsxRuntime.jsxs("div", { className: "flex flex-col flex-grow overflow-hidden space-y-1", children: [title && (jsxRuntime.jsx("div", { children: jsxRuntime.jsx(Text, { size: "sm", weight: "regular", color: "default", children: title }) })), jsxRuntime.jsx("div", { children: jsxRuntime.jsx(Text, { size: "sm", weight: "regular", color: "default", children: translateInToast ? t(displayedContent) : displayedContent }) })] }), isClosable && (jsxRuntime.jsx(IconButton, { variant: "ghost", icon: ForwardRef$j, onClick: () => reactHotToast.toast.dismiss(id), className: "w-4 h-4 text-icon-subtlest" }))] }) }) }));
}

function useNotification() {
    const addToast = React.useCallback((config, duration) => {
        if (config.id) {
            reactHotToast.toast.remove(config.id);
        }
        reactHotToast.toast.custom((t) => {
            return jsxRuntime.jsx(CustomNotificationElement, { tProps: Object.assign(Object.assign({}, t), { duration }), customProps: config });
        }, {
            id: config.id
        });
    }, []);
    const message = React.useCallback((config) => addToast(Object.assign({}, config)), []);
    const success = React.useCallback((config) => addToast(Object.assign(Object.assign({}, config), { type: 'success' })), []);
    const error = React.useCallback((config) => addToast(Object.assign(Object.assign({}, config), { type: 'error' })), []);
    const warning = React.useCallback((config) => addToast(Object.assign(Object.assign({}, config), { type: 'warning' })), []);
    const info = React.useCallback((config, duration) => addToast(Object.assign(Object.assign({}, config), { type: 'info' }), duration), []);
    const close = React.useCallback((id) => {
        reactHotToast.toast.dismiss(id);
    }, []);
    return { addToast, success, error, warning, info, close, message };
}
class Message {
    static _toast(config) {
        if (config.id) {
            reactHotToast.toast.remove(config.id);
        }
        const addToast = () => {
            reactHotToast.toast.custom((t) => {
                return jsxRuntime.jsx(CustomNotificationElement, { tProps: t, customProps: config });
            }, {
                id: config.id
            });
        };
        addToast();
    }
    static success(config) {
        return this._toast(Object.assign(Object.assign({}, config), { type: 'success' }));
    }
    static error(config) {
        return this._toast(Object.assign(Object.assign({}, config), { type: 'error' }));
    }
    static info(config) {
        return this._toast(Object.assign(Object.assign({}, config), { type: 'info' }));
    }
    static warning(config) {
        return this._toast(Object.assign(Object.assign({}, config), { type: 'warning' }));
    }
    static close(id) {
        reactHotToast.toast.dismiss(id);
    }
}

var useNotification$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Message: Message,
    useNotification: useNotification
});

function useRedeemAndUseSeasonPass() {
    const [acting, setActing] = React.useState(false);
    const { warning } = useNotification();
    const handleRedeemAndUseSeasonPass = async (successCb) => {
        try {
            setActing(true);
            const { success, data, msg } = await claimAndUseSeasonPass();
            if (!success) {
                warning({
                    content: msg !== null && msg !== void 0 ? msg : ''
                });
                return;
            }
            successCb && successCb(data);
        }
        catch (e) {
        }
        finally {
            setActing(false);
        }
    };
    return {
        acting,
        handleRedeemAndUseSeasonPass
    };
}

function InlineVideoPlayer({ src }) {
    return (jsxRuntime.jsx("video", { src: src, loop: true, autoPlay: true, muted: true, playsInline: true, disablePictureInPicture: true, className: "w-full h-full block object-cover" }));
}

// packages/react/compose-refs/src/composeRefs.tsx
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}
function useComposedRefs(...refs) {
  return React__namespace.useCallback(composeRefs(...refs), refs);
}

// packages/react/primitive/src/Primitive.tsx
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node = React__namespace.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? reactSlot.Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntime.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node };
}, {});

// packages/react/use-callback-ref/src/useCallbackRef.tsx
function useCallbackRef(callback) {
  const callbackRef = React__namespace.useRef(callback);
  React__namespace.useEffect(() => {
    callbackRef.current = callback;
  });
  return React__namespace.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}

var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = React__namespace.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = React__namespace.useState(null);
  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);
  const lastFocusedElementRef = React__namespace.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = React__namespace.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  React__namespace.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  React__namespace.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = React__namespace.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntime.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index = updatedArray.indexOf(item);
  if (index !== -1) {
    updatedArray.splice(index, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}

var __rest$s = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const iconVariants$1 = classVarianceAuthority.cva('inline-flex shrink-0', {
    variants: {
        size: {
            '2xs': 'w-3 h-3',
            xs: 'w-3.5 h-3.5',
            sm: 'w-4 h-4',
            md: 'w-4.5 h-4.5',
            lg: 'w-5 h-5',
            xl: 'w-5.5 h-5.5',
            '2xl': 'w-6 h-6',
            '3xl': 'w-7 h-7',
            '4xl': 'w-8 h-8',
            '5xl': 'w-9 h-9',
            '6xl': 'w-10 h-10',
            '7xl': 'w-12 h-12'
        },
        color: {
            default: 'text-default',
            subtle: 'text-subtle',
            subtlest: 'text-subtlest',
            disabled: 'text-disabled',
            inverse: 'text-inverse',
            static: 'text-static',
            brand: 'text-brand',
            critical: 'text-critical',
            warning: 'text-warning',
            success: 'text-success'
        },
        rotate: {
            '45': 'rotate-45',
            '90': 'rotate-90',
            '-45': '-rotate-45',
            '-90': '-rotate-90',
            '180': 'rotate-180'
        }
    },
    defaultVariants: {
        size: 'sm',
        color: 'default'
    }
});
const Icon = React__namespace.forwardRef((props, ref) => {
    const { children, component, size, color, rotate, className } = props, passProps = __rest$s(props, ["children", "component", "size", "color", "rotate", "className"]);
    const Com = component || 'span';
    return (jsxRuntime.jsx(Com, Object.assign({ ref: ref }, passProps, { className: cn(iconVariants$1({ size, color, rotate }), className), children: children })));
});
Icon.displayName = 'Icon';

var __rest$r = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const imageVariants = classVarianceAuthority.cva('', {
    variants: {
        rounded: {
            none: 'rounded-none',
            sm: 'rounded-sm',
            default: 'rounded',
            md: 'rounded-md',
            lg: 'rounded-lg',
            xl: 'rounded-xl',
            '2xl': 'rounded-2xl',
            '3xl': 'rounded-3xl',
            full: 'rounded-full'
        },
        object: {
            contain: 'object-contain',
            cover: 'object-cover',
            fill: 'object-fill',
            none: 'object-none'
        }
    },
    defaultVariants: {
        rounded: 'none'
    }
});
function Image$3(_a) {
    var { className, imgClassName, placeholder = true, width = '100%', height = '100%', src, rounded = 'none', fallback = '', object = 'cover', isBackgroud = false } = _a, otherProps = __rest$r(_a, ["className", "imgClassName", "placeholder", "width", "height", "src", "rounded", "fallback", "object", "isBackgroud"]);
    return (jsxRuntime.jsx(RCImage__default.default, Object.assign({ placeholder: placeholder, width: width, height: height, src: src, fallback: fallback ||
            'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMIAAADDCAYAAADQvc6UAAABRWlDQ1BJQ0MgUHJvZmlsZQAAKJFjYGASSSwoyGFhYGDIzSspCnJ3UoiIjFJgf8LAwSDCIMogwMCcmFxc4BgQ4ANUwgCjUcG3awyMIPqyLsis7PPOq3QdDFcvjV3jOD1boQVTPQrgSkktTgbSf4A4LbmgqISBgTEFyFYuLykAsTuAbJEioKOA7DkgdjqEvQHEToKwj4DVhAQ5A9k3gGyB5IxEoBmML4BsnSQk8XQkNtReEOBxcfXxUQg1Mjc0dyHgXNJBSWpFCYh2zi+oLMpMzyhRcASGUqqCZ16yno6CkYGRAQMDKMwhqj/fAIcloxgHQqxAjIHBEugw5sUIsSQpBobtQPdLciLEVJYzMPBHMDBsayhILEqEO4DxG0txmrERhM29nYGBddr//5/DGRjYNRkY/l7////39v///y4Dmn+LgeHANwDrkl1AuO+pmgAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAwqADAAQAAAABAAAAwwAAAAD9b/HnAAAHlklEQVR4Ae3dP3PTWBSGcbGzM6GCKqlIBRV0dHRJFarQ0eUT8LH4BnRU0NHR0UEFVdIlFRV7TzRksomPY8uykTk/zewQfKw/9znv4yvJynLv4uLiV2dBoDiBf4qP3/ARuCRABEFAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghggQAQZQKAnYEaQBAQaASKIAQJEkAEEegJmBElAoBEgghgg0Aj8i0JO4OzsrPv69Wv+hi2qPHr0qNvf39+iI97soRIh4f3z58/u7du3SXX7Xt7Z2enevHmzfQe+oSN2apSAPj09TSrb+XKI/f379+08+A0cNRE2ANkupk+ACNPvkSPcAAEibACyXUyfABGm3yNHuAECRNgAZLuYPgEirKlHu7u7XdyytGwHAd8jjNyng4OD7vnz51dbPT8/7z58+NB9+/bt6jU/TI+AGWHEnrx48eJ/EsSmHzx40L18+fLyzxF3ZVMjEyDCiEDjMYZZS5wiPXnyZFbJaxMhQIQRGzHvWR7XCyOCXsOmiDAi1HmPMMQjDpbpEiDCiL358eNHurW/5SnWdIBbXiDCiA38/Pnzrce2YyZ4//59F3ePLNMl4PbpiL2J0L979+7yDtHDhw8vtzzvdGnEXdvUigSIsCLAWavHp/+qM0BcXMd/q25n1vF57TYBp0a3mUzilePj4+7k5KSLb6gt6ydAhPUzXnoPR0dHl79WGTNCfBnn1uvSCJdegQhLI1vvCk+fPu2ePXt2tZOYEV6/fn31dz+shwAR1sP1cqvLntbEN9MxA9xcYjsxS1jWR4AIa2Ibzx0tc44fYX/16lV6NDFLXH+YL32jwiACRBiEbf5KcXoTIsQSpzXx4N28Ja4BQoK7rgXiydbHjx/P25TaQAJEGAguWy0+2Q8PD6/Ki4R8EVl+bzBOnZY95fq9rj9zAkTI2SxdidBHqG9+skdw43borCXO/ZcJdraPWdv22uIEiLA4q7nvvCug8WTqzQveOH26fodo7g6uFe/a17W3+nFBAkRYENRdb1vkkz1CH9cPsVy/jrhr27PqMYvENYNlHAIesRiBYwRy0V+8iXP8+/fvX11Mr7L7ECueb/r48eMqm7FuI2BGWDEG8cm+7G3NEOfmdcTQw4h9/55lhm7DekRYKQPZF2ArbXTAyu4kDYB2YxUzwg0gi/41ztHnfQG26HbGel/crVrm7tNY+/1btkOEAZ2M05r4FB7r9GbAIdxaZYrHdOsgJ/wCEQY0J74TmOKnbxxT9n3FgGGWWsVdowHtjt9Nnvf7yQM2aZU/TIAIAxrw6dOnAWtZZcoEnBpNuTuObWMEiLAx1HY0ZQJEmHJ3HNvGCBBhY6jtaMoEiJB0Z29vL6ls58vxPcO8/zfrdo5qvKO+d3Fx8Wu8zf1dW4p/cPzLly/dtv9Ts/EbcvGAHhHyfBIhZ6NSiIBTo0LNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiECRCjUbEPNCRAhZ6NSiAARCjXbUHMCRMjZqBQiQIRCzTbUnAARcjYqhQgQoVCzDTUnQIScjUohAkQo1GxDzQkQIWejUogAEQo121BzAkTI2agUIkCEQs021JwAEXI2KoUIEKFQsw01J0CEnI1KIQJEKNRsQ80JECFno1KIABEKNdtQcwJEyNmoFCJAhELNNtScABFyNiqFCBChULMNNSdAhJyNSiEC/wGgKKC4YMA4TAAAAABJRU5ErkJggg==', preview: false, rootClassName: cn(imageVariants({ rounded, object }), isBackgroud && 'absolute top-0 left-0 z-0 w-full h-full object-cover', className), className: imgClassName }, otherProps)));
}

var __rest$q = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const Separator = React__namespace.forwardRef((_a, ref) => {
    var { className, orientation = 'horizontal', decorative = true } = _a, props = __rest$q(_a, ["className", "orientation", "decorative"]);
    return (jsxRuntime.jsx(SeparatorPrimitive__namespace.Root, Object.assign({ ref: ref, decorative: decorative, orientation: orientation, className: cn('shrink-0 border-default', orientation === 'horizontal' ? 'border-b w-full ' : 'h-full  border-r', className) }, props)));
});
Separator.displayName = SeparatorPrimitive__namespace.Root.displayName;

var __rest$p = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const buttonVariants = classVarianceAuthority.cva('relative shrink-0 inline-flex items-center justify-center whitespace-nowrap rounded-full font-medium transition-colors ring-offset-surface-default focus-visible:outline-none focus-visible:shadow-none focus-visible:ring-2 focus-visible:ring-brand focus-visible:ring-offset-1 disabled:pointer-events-none disabled:opacity-30 disabled:shadow-none', {
    variants: {
        variant: {
            primary: 'text-static [&>span>svg]:text-icon-static [&>span>span>svg]:text-icon-static bg-surface-primary-default shadow-button-primary hover:bg-surface-primary-hovered active:bg-surface-primary-pressed',
            outline: 'border hover:bg-surface-hovered active:bg-surface-pressed',
            static: 'bg-static border hover:bg-surface-hoverd-static active:bg-surface-pressed-static',
            link: 'rounded-none font-normal underline-offset-4 hover:underline active:underline',
            plain: 'rounded-md font-medium hover:bg-surface-hovered active:bg-surface-pressed'
        },
        color: {
            default: '',
            brand: '',
            warning: '',
            error: '',
            gray: '',
            chat: ''
        },
        size: {
            lg: '',
            md: '',
            sm: ''
        }
    },
    compoundVariants: [
        {
            variant: 'primary',
            size: 'lg',
            className: 'h-11 min-w-11 px-6'
        },
        {
            variant: 'primary',
            size: 'md',
            className: 'h-9 min-w-9 px-4 text-sm'
        },
        {
            variant: 'primary',
            size: 'sm',
            className: 'h-7 min-w-7 px-3 text-sm'
        },
        {
            variant: 'primary',
            color: 'default',
            className: 'text-brand [&>span>svg]:text-icon-brand [&>span>span>svg]:text-icon-brand disabled:bg-surface-disabled disabled:text-surface-accent-blue-subtle [&>span>svg]:disabled:text-surface-accent-blue-subtle disabled:opacity-100 bg-surface-search-field border border-default hover:bg-surface-hovered active:bg-surface-pressed active:shadow-button-pressed shadow-button-basic'
        },
        {
            variant: 'primary',
            color: 'brand',
            className: 'bg-surface-primary-default hover:bg-surface-primary-hovered active:bg-surface-primary-pressed'
        },
        {
            variant: 'primary',
            color: 'warning',
            className: 'bg-surface-warning-default hover:bg-surface-warning-hovered active:bg-surface-warning-pressed'
        },
        {
            variant: 'primary',
            color: 'error',
            className: 'bg-surface-critical-default hover:bg-surface-critical-hovered active:bg-surface-critical-pressed'
        },
        {
            variant: 'primary',
            color: 'gray',
            className: 'text-subtle [&>span>svg]:text-icon-subtle bg-surface-search-field border border-default hover:bg-surface-hovered active:bg-surface-pressed shadow-button-basic disabled:bg-surface-disabled disabled:text-disabled disabled:opacity-100 [&>span>svg]:disabled:text-icon-disabled'
        },
        {
            variant: 'primary',
            color: 'chat',
            className: 'shadow-none text-subtle [&>span>svg]:text-icon-subtle bg-surface-accent-gray-subtlest border border-default hover:bg-surface-accent-gray-subtler active:bg-surface-accent-gray-subtler active:shadow-button-pressed disabled:bg-surface-accent-gray-subtlest disabled:text-disabled disabled:opacity-100 [&>span>svg]:disabled:text-icon-disabled'
        },
        {
            variant: 'static',
            color: 'default',
            className: 'text-static-black [&>span>svg]:text-icon-static-black'
        },
        {
            variant: 'static',
            color: 'brand',
            className: 'text-brand [&>span>svg]:text-icon-brand'
        },
        {
            variant: 'static',
            color: 'warning',
            className: 'text-warning [&>span>svg]:text-icon-warning'
        },
        {
            variant: 'static',
            color: 'error',
            className: 'text-critical [&>span>svg]:text-icon-critical'
        },
        {
            variant: 'static',
            color: 'gray',
            className: 'text-subtler'
        },
        {
            variant: 'outline',
            color: 'default',
            className: 'border-default text-subtle [&>span>svg]:text-icon-subtle shadow-button-basic active:shadow-button-pressed'
        },
        {
            variant: 'outline',
            color: 'brand',
            className: 'border-surface-primary-default text-brand [&>span>svg]:text-icon-brand'
        },
        {
            variant: 'outline',
            color: 'warning',
            className: 'border-surface-warning-default text-warning [&>span>svg]:text-icon-warning hover:bg-surface-warning-subtle-hovered active:bg-surface-warning-subtle-pressed'
        },
        {
            variant: 'outline',
            color: 'error',
            className: 'border-surface-critical-default text-critical [&>span>svg]:text-icon-critical hover:bg-surface-critical-subtle-hovered active:bg-surface-critical-subtle-pressed'
        },
        {
            variant: 'outline',
            color: 'gray',
            className: 'text-subtle [&>span>svg]:text-icon-subtle hover:bg-surface-hovered active:shadow-button-pressed'
        },
        {
            variant: 'outline',
            size: 'lg',
            className: 'h-11 min-w-11 px-6'
        },
        {
            variant: 'outline',
            size: 'md',
            className: 'h-9 min-w-9 px-4 text-sm'
        },
        {
            variant: 'outline',
            size: 'sm',
            className: 'h-7 min-w-7 px-3 text-sm'
        },
        {
            variant: 'static',
            size: 'lg',
            className: 'h-11 min-w-11 px-6'
        },
        {
            variant: 'static',
            size: 'md',
            className: 'h-9 min-w-9 px-4 text-sm'
        },
        {
            variant: 'static',
            size: 'sm',
            className: 'h-7 min-w-7 px-3 text-sm'
        },
        {
            variant: 'link',
            className: 'h-fit w-fit min-w-auto px-0.5 py-0.5'
        },
        {
            variant: 'link',
            color: 'default',
            className: 'text-default [&>span>svg]:text-icon-default'
        },
        {
            variant: 'link',
            color: 'brand',
            className: 'text-brand [&>span>svg]:text-icon-brand'
        },
        {
            variant: 'link',
            color: 'warning',
            className: 'text-warning [&>span>svg]:text-icon-warning'
        },
        {
            variant: 'link',
            color: 'error',
            className: 'text-critical [&>span>svg]:text-icon-critical'
        },
        {
            variant: 'link',
            color: 'gray',
            className: 'text-subtler hover:text-subtler'
        },
        {
            variant: 'link',
            size: 'lg',
            className: 'h-fit w-fit px-0.5 py-0.5 text-base'
        },
        {
            variant: 'link',
            size: 'md',
            className: 'h-fit w-fit px-0.5 py-0.5 text-sm'
        },
        {
            variant: 'link',
            size: 'sm',
            className: 'h-fit w-fit px-0.5 py-0.5 text-xs'
        },
        {
            variant: 'plain',
            className: 'h-fit w-fit min-w-auto px-0.5 py-0.5'
        },
        {
            variant: 'plain',
            color: 'default',
            className: 'text-default [&>span>svg]:text-icon'
        },
        {
            variant: 'plain',
            color: 'brand',
            className: 'text-brand [&>span>svg]:text-icon-brand'
        },
        {
            variant: 'plain',
            color: 'warning',
            className: 'text-warning [&>span>svg]:text-icon-warning'
        },
        {
            variant: 'plain',
            color: 'error',
            className: 'text-critical [&>span>svg]:text-icon-critical'
        },
        {
            variant: 'plain',
            color: 'gray',
            className: 'text-subtler hover:text-subtle active:text-subtle'
        },
        {
            variant: 'plain',
            size: 'lg',
            className: 'h-fit w-fit px-0.5 py-0.5 text-base'
        },
        {
            variant: 'plain',
            size: 'md',
            className: 'h-fit w-fit px-0.5 py-0.5 text-sm'
        },
        {
            variant: 'plain',
            size: 'sm',
            className: 'h-fit w-fit px-0.5 py-0.5 text-xs'
        }
    ],
    defaultVariants: {
        variant: 'primary',
        color: 'default',
        size: 'lg'
    }
});
const iconVariants = classVarianceAuthority.cva('relative shrink-0 text-inherit inline-flex items-center justify-center whitespace-nowrap transition-colors ring-offset-surface-default', {
    variants: {
        variant: {
            primary: '',
            outline: '',
            link: 'font-normal',
            plain: 'font-medium',
            static: ''
        },
        size: {
            lg: 'text-base w-5 h-5',
            md: 'text-sm w-4.5 h-4.5',
            sm: 'text-sm w-4 h-4'
        }
    },
    compoundVariants: [
        {
            variant: 'plain',
            size: 'lg',
            className: 'text-base w-4.5 h-4.5'
        },
        {
            variant: 'plain',
            size: 'md',
            className: 'text-sm w-4 h-4'
        },
        {
            variant: 'plain',
            size: 'md',
            className: 'text-sm'
        }
    ],
    defaultVariants: {
        variant: 'primary',
        size: 'lg'
    }
});
const Button$1 = React__namespace.forwardRef((_a, ref) => {
    var { className = '', iconClassName, variant, color = 'brand', icon, iconDirection = 'left', size, asChild = false, loading = false, noStyle = false, iconOutBox = false, isBlock = false, disabled, children, autoFocus, asset, assetNumber = 0 } = _a, props = __rest$p(_a, ["className", "iconClassName", "variant", "color", "icon", "iconDirection", "size", "asChild", "loading", "noStyle", "iconOutBox", "isBlock", "disabled", "children", "autoFocus", "asset", "assetNumber"]);
    const Comp = asChild ? reactSlot.Slot : 'button';
    const disable = disabled || loading;
    return (jsxRuntime.jsxs(Comp, Object.assign({ className: noStyle
            ? className
            : cn(buttonVariants({ variant, color, size, className }), disable && 'cursor-not-allowed !pointer-events-auto', isBlock && 'w-full'), ref: ref, disabled: disable, autoFocus: autoFocus }, props, { children: [loading && (jsxRuntime.jsx("span", { className: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex items-center justify-center", children: jsxRuntime.jsx(lucideReact.Loader2, { className: cn(iconVariants({ variant, size }), 'animate-spin', size === 'lg' ? 'w-6 h-6' : size === 'md' ? 'w-5 h-5' : 'w-4.5 h-4.5') }) })), !asset &&
                icon &&
                iconOutBox &&
                iconDirection === 'left' &&
                renderIcon(icon, 'left', { loading, noStyle, iconClassName, variant, color, size }), jsxRuntime.jsxs("span", { className: cn('w-full inline-flex items-center justify-center', loading ? 'opacity-0' : 'opacity-100', variant === 'plain' && 'font-medium'), children: [!asset &&
                        icon &&
                        !iconOutBox &&
                        iconDirection === 'left' &&
                        renderIcon(icon, 'left', { loading, noStyle, iconClassName, variant, color, size }), children, asset ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Separator, { orientation: "vertical", className: cn('mx-1.5 h-3', variant === 'primary' && color === 'brand'
                                    ? 'border-alpha-facetime-white'
                                    : 'border-alpha-facetime-black') }), jsxRuntime.jsx(Image$3, { src: asset === 'energy' ? getAssetsUrl('image/bot/tag/20231214/1719340128612116720.png') : '', alt: asset, width: 16, height: 16, className: "flex-shrink-0" }), jsxRuntime.jsx(Text, { size: "xs", className: cn('text-inherit ml-0.5', variant === 'primary' && color === 'brand' ? 'text-static' : 'text-default'), children: assetNumber })] })) : null, !asset &&
                        icon &&
                        !iconOutBox &&
                        iconDirection === 'right' &&
                        renderIcon(icon, 'right', { loading, noStyle, iconClassName, variant, color, size })] }), !asset &&
                icon &&
                iconOutBox &&
                iconDirection === 'right' &&
                renderIcon(icon, 'right', { loading, noStyle, iconClassName, variant, color, size })] })));
});
const renderIcon = (icon, direction, { loading, noStyle, iconClassName, variant = 'primary', color = 'brand', size = 'lg' }) => (jsxRuntime.jsx(Icon, { component: icon, className: noStyle
        ? iconClassName
        : cn(iconVariants({ variant, size }), variant === 'plain' || variant === 'link'
            ? direction === 'left'
                ? 'mr-0.5'
                : 'ml-0.5'
            : direction === 'left'
                ? 'mr-1.5'
                : 'ml-1.5', iconClassName, loading ? 'opacity-0' : 'opacity-100') }));
Button$1.displayName = 'Button';

var __rest$o = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const ModalOverlay = React__namespace.forwardRef((_a, ref) => {
    var { className, onClick } = _a, props = __rest$o(_a, ["className", "onClick"]);
    return (jsxRuntime.jsx(DialogPrimitive__namespace.Overlay, Object.assign({ ref: ref, className: cn('fixed inset-0 z-50 bg-alpha-mask-desktop data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0', className), onClick: e => {
            onClick && onClick(e);
        } }, props)));
});
ModalOverlay.displayName = DialogPrimitive__namespace.Overlay.displayName;
const DrawerOverlay = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$o(_a, ["className"]);
    return (jsxRuntime.jsx(vaul.Drawer.Overlay, Object.assign({ ref: ref, className: cn('fixed inset-0 z-50 bg-alpha-mask-desktop', className) }, props)));
});
DrawerOverlay.displayName = vaul.Drawer.Overlay.displayName;
const ModalContent = React__namespace.forwardRef((_a, ref) => {
    var { className, children } = _a, props = __rest$o(_a, ["className", "children"]);
    return (jsxRuntime.jsx(DialogPrimitive__namespace.Content, Object.assign({ className: cn('absolute left-1/2 top-1/2 z-50 -translate-x-1/2 -translate-y-1/2 !touch-auto !select-text', 'duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] focus:outline-none', className) }, props, { children: children })));
});
const ModalRoot = (_a) => {
    var { children } = _a, props = __rest$o(_a, ["children"]);
    return (jsxRuntime.jsx(DialogPrimitive__namespace.Dialog, Object.assign({}, props, { children: jsxRuntime.jsx(DialogPrimitive__namespace.Portal, { children: children }) })));
};
const ModalTitle = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$o(_a, ["className"]);
    const isMobile = useGlobalStore(state => state.isMobile);
    if (isMobile) {
        return (jsxRuntime.jsx(vaul.Drawer.Title, Object.assign({ ref: ref }, props, { className: cn('text-xl text-default font-medium line-clamp-1', className) })));
    }
    return (jsxRuntime.jsx(DialogPrimitive__namespace.Title, Object.assign({ ref: ref }, props, { className: cn('text-xl text-default font-medium line-clamp-1', className) })));
});
ModalTitle.displayName = DialogPrimitive__namespace.Title.displayName;
const modalVariants = classVarianceAuthority.cva('', {
    variants: {
        size: {
            lg: 'w-[750px] max-h-[640px]',
            md: 'w-[620px] max-h-[640px]',
            sm: 'w-[380px] max-h-[640px]'
        },
        zIndex: {
            9: 'z-[9]',
            99: 'z-[99]',
            999: 'z-[999]',
            9999: 'z-[9999]'
        }
    },
    defaultVariants: {
        size: 'lg',
        zIndex: 99
    }
});
const Modal = (_a) => {
    var { title, description, size = 'lg', zIndex = 99, hideClose = false, overlayClose = true, modalOnly = true, contentClassName, overlayClassName, iconClassName, closeClassName, fullScreen = false, focusScopeOptions, isLogin = false, isNotification = false, isHorizontal = false, state, showCancel = true, confirmLoading = false, cancelText, confirmText, children, onClose, onConfirm } = _a, props = __rest$o(_a, ["title", "description", "size", "zIndex", "hideClose", "overlayClose", "modalOnly", "contentClassName", "overlayClassName", "iconClassName", "closeClassName", "fullScreen", "focusScopeOptions", "isLogin", "isNotification", "isHorizontal", "state", "showCancel", "confirmLoading", "cancelText", "confirmText", "children", "onClose", "onConfirm"]);
    const isMobile = useGlobalStore(state => state.isMobile);
    if (isMobile && !modalOnly && !isNotification) {
        const drawerContent = (jsxRuntime.jsxs(vaul.Drawer.Content, { className: cn('fixed inset-x-0 bottom-0 z-50 h-auto overflow-hidden no-scrollbar bg-surface-default shadow-modal-default focus:outline-none', fullScreen ? 'rounded-t-none max-h-full' : 'rounded-t-2xl max-h-[85vh]', contentClassName), children: [title ? (jsxRuntime.jsx(ModalHeader, { children: jsxRuntime.jsx(ModalTitle, { children: title }) })) : null, jsxRuntime.jsx("div", { className: cn(isLogin ? 'overflow-y-scroll' : 'overflow-y-auto', fullScreen
                        ? title
                            ? 'max-h-[calc(100vh-60px)]'
                            : 'max-h-[100vh]'
                        : title
                            ? 'max-h-[calc(85vh-60px)]'
                            : 'max-h-[85vh]'), children: children }), !hideClose && (jsxRuntime.jsx(vaul.Drawer.Close, { asChild: true, children: jsxRuntime.jsxs("div", { className: cn('absolute right-4 top-3', closeClassName), onClick: () => {
                            onClose && onClose();
                        }, children: [jsxRuntime.jsx(IconButton, { icon: ForwardRef$j, size: "md", variant: "ghost", color: "default", className: iconClassName }), jsxRuntime.jsx("span", { className: "sr-only", children: "Close" })] }) }))] }));
        return (jsxRuntime.jsx(vaul.Drawer.Root, Object.assign({}, props, { repositionInputs: false, children: jsxRuntime.jsxs(vaul.Drawer.Portal, { children: [jsxRuntime.jsx(DrawerOverlay, { onClick: () => {
                            overlayClose && onClose && onClose();
                        }, className: overlayClassName }), focusScopeOptions ? jsxRuntime.jsx(FocusScope, Object.assign({}, focusScopeOptions, { children: drawerContent })) : drawerContent] }) })));
    }
    const renderIcon = (state) => {
        switch (state) {
            case 'info':
                return jsxRuntime.jsx(ForwardRef$U, { className: "text-icon-brand w-6 h-6" });
            case 'success':
                return jsxRuntime.jsx(ForwardRef$K, { className: "text-icon-success w-6 h-6" });
            case 'warning':
                return jsxRuntime.jsx(ForwardRef$C, { className: "text-icon-warning w-6 h-6" });
            case 'error':
                return jsxRuntime.jsx(ForwardRef$k, { className: "text-icon-critical w-6 h-6" });
        }
    };
    const getBackgroundColor = (state) => {
        switch (state) {
            case 'info':
                return 'bg-surface-accent-blue-subtler';
            case 'success':
                return 'bg-surface-accent-green-subtler';
            case 'warning':
                return 'bg-surface-accent-yellow-subtler';
            case 'error':
                return 'bg-surface-accent-red-subtler';
        }
    };
    const commonT = nextIntl.useTranslations('common');
    const dialogContent = (jsxRuntime.jsxs(ModalContent, { className: cn('rounded-2xl bg-surface-default shadow-modal-default overflow-hidden', !isMobile ? modalVariants({ size, zIndex }) : isLogin ? 'w-[90%]' : 'w-[80%]', isNotification && 'w-[312px] md:w-[380px]', contentClassName), children: [isNotification ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(ModalHeader, { className: cn(isNotification && 'border-none !pb-3'), children: state && (jsxRuntime.jsx("div", { className: cn('flex items-center justify-center w-10 h-10 rounded-full flex-shrink-0 flex-grow-0', getBackgroundColor(state)), children: renderIcon(state) })) }), jsxRuntime.jsxs("div", { className: "space-y-1.5", children: [title ? (jsxRuntime.jsx("div", { className: "px-5", children: jsxRuntime.jsx(Display$1, { size: "sm", children: title }) })) : null, children ||
                                (description ? (jsxRuntime.jsx("div", { className: "px-5", children: jsxRuntime.jsx(Text, { size: "sm", weight: "regular", children: description }) })) : null)] }), jsxRuntime.jsxs(ModalFooter, { className: cn('gap-x-5 min-h-[76px] p-5 border-none justify-center w-full'), children: [showCancel && (jsxRuntime.jsx(Button$1, { variant: "primary", color: "gray", onClick: onClose, className: "flex-1", children: cancelText || commonT('cancel') })), jsxRuntime.jsx(Button$1, { variant: "primary", onClick: onConfirm, loading: confirmLoading, color: state === 'error' ? 'error' : state === 'warning' ? 'warning' : 'brand', className: "flex-1", children: confirmText || commonT('confirm') })] })] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [title ? (jsxRuntime.jsx(ModalHeader, { children: jsxRuntime.jsx(ModalTitle, { children: title }) })) : null, children] })), !hideClose && (jsxRuntime.jsx(DialogPrimitive__namespace.Close, { asChild: true, children: jsxRuntime.jsxs("div", { onClick: () => {
                        onClose && onClose();
                    }, className: cn('absolute right-4 top-4', isNotification && 'top-5', closeClassName), children: [jsxRuntime.jsx(IconButton, { icon: ForwardRef$j, size: "md", variant: "ghost", color: "default", className: iconClassName }), jsxRuntime.jsx("span", { className: "sr-only", children: "Close" })] }) }))] }));
    return (jsxRuntime.jsxs(ModalRoot, Object.assign({}, props, { children: [jsxRuntime.jsx(ModalOverlay, { onClick: () => {
                    overlayClose && onClose && onClose();
                }, className: overlayClassName }), focusScopeOptions ? jsxRuntime.jsx(FocusScope, Object.assign({}, focusScopeOptions, { children: dialogContent })) : dialogContent] })));
};
function ModalHeader(_a) {
    var { className, children } = _a, props = __rest$o(_a, ["className", "children"]);
    return (jsxRuntime.jsx("div", Object.assign({ className: cn('border-b border-default flex flex-col py-4 md:py-5 px-4 justify-center', className) }, props, { children: children })));
}
ModalHeader.displayName = 'ModalHeader';
function ModalFooter(_a) {
    var { className, children } = _a, props = __rest$o(_a, ["className", "children"]);
    return (jsxRuntime.jsx("div", Object.assign({ className: cn('border-t border-default flex justify-end p-4', className) }, props, { children: children })));
}
ModalFooter.displayName = 'ModalFooter';
function ModalBody(_a) {
    var { className, children } = _a, props = __rest$o(_a, ["className", "children"]);
    return (jsxRuntime.jsx("div", Object.assign({ className: cn('py-3', className) }, props, { children: children })));
}
ModalBody.displayName = 'ModalBody';

const UserStoreContext = React.createContext(undefined);
let store$1;
const UserStoreProvider = ({ children, user, isLogin, language }) => {
    const storeRef = React.useRef();
    if (!storeRef.current) {
        storeRef.current = createUserStore({
            user: user || null,
            isLogin,
            language
        });
        store$1 = storeRef.current;
    }
    return (jsxRuntime.jsxs(UserStoreContext.Provider, { value: storeRef.current, children: [children, jsxRuntime.jsx(Script__default.default, { strategy: "afterInteractive", children: `
          window.$global.userId = '${user === null || user === void 0 ? void 0 : user.id}';
        ` })] }));
};
const useUserStore = (selector) => {
    const userStoreContext = React.useContext(UserStoreContext);
    if (!userStoreContext) {
        throw new Error(`userStoreContext must be used within userStoreProvider`);
    }
    return zustand.useStore(userStoreContext, selector);
};
useUserStore.getState = () => {
    return store$1 === null || store$1 === void 0 ? void 0 : store$1.getState();
};

function useGetEnergyInfo() {
    const setEnergyInfo = useUserStore(state => state.setEnergyInfo);
    const userId = useUserStore(state => state.userId);
    const getEnergyInfo = async (needSet = true) => {
        try {
            const { data } = await getUserEnergyInfo(userId);
            needSet && setEnergyInfo(data);
        }
        catch (e) {
        }
    };
    return {
        getEnergyInfo
    };
}

function useUpdateUserProfile() {
    const setUser = useUserStore(state => state.setUser);
    const queryUserProfile = async () => {
        try {
            const { data } = await getUserProfile();
            setUser(data);
            return data;
        }
        catch (e) {
            throw new Error(e.response.data.message);
        }
    };
    return {
        queryUserProfile
    };
}

function UseSeasonPassSuccessModal({ isOpen, onClose, rewardInfo, isLoading = false }) {
    var _a;
    const t = nextIntl.useTranslations('common');
    const cT = nextIntl.useTranslations('chat');
    const { getEnergyInfo } = useGetEnergyInfo();
    const { queryUserProfile } = useUpdateUserProfile();
    const setNewlyPropsCount = useTaskStore(state => state.setNewlyPropsCount);
    const [querying, setQuerying] = React.useState(false);
    const handleClose = async () => {
        setNewlyPropsCount(0);
        try {
            setQuerying(true);
            await Promise.all([getEnergyInfo(), queryUserProfile()]);
            onClose();
        }
        catch (e) {
        }
        finally {
            setQuerying(false);
        }
    };
    return (jsxRuntime.jsxs(ModalRoot, { open: isOpen, children: [jsxRuntime.jsx(ModalOverlay, { onClick: onClose, children: jsxRuntime.jsx("div", { className: "w-full h-full", children: jsxRuntime.jsx("img", { src: RewardSuccessBg__default.default.src, className: "w-full h-full object-cover", alt: "success background" }) }) }), jsxRuntime.jsx(ModalContent, { children: jsxRuntime.jsxs("div", { className: "flex flex-col items-center w-[350px]", children: [jsxRuntime.jsxs("div", { className: "flex flex-col items-center text-center space-y-1.5", children: [jsxRuntime.jsx(Display$1, { size: "lg", className: "text-static", children: t('congratulations') }), jsxRuntime.jsx(Text, { size: "sm", weight: "regular", color: "static", className: "opacity-80", children: cT('claim_season_pass_success_desc', {
                                        name: rewardInfo === null || rewardInfo === void 0 ? void 0 : rewardInfo.name
                                    }) })] }), jsxRuntime.jsx("div", { className: "aspect-square w-full relative mt-5 rounded-xl overflow-hidden", children: jsxRuntime.jsx("div", { className: "aspect-square h-[358px] md:h-[350px] rounded-xl overflow-hidden relative flex-shrink-0", children: isVideo(getFileExtension((_a = rewardInfo === null || rewardInfo === void 0 ? void 0 : rewardInfo.mediaUrl) !== null && _a !== void 0 ? _a : '')) ? (jsxRuntime.jsx(InlineVideoPlayer, { src: getAssetsUrl(rewardInfo === null || rewardInfo === void 0 ? void 0 : rewardInfo.mediaUrl) })) : (jsxRuntime.jsx(Image$3, { src: getAssetsUrl(rewardInfo === null || rewardInfo === void 0 ? void 0 : rewardInfo.mediaUrl), alt: "img" })) }) }), jsxRuntime.jsx(Text, { size: "lg", weight: "medium", color: "static", className: "mt-2 text-center w-full", children: rewardInfo === null || rewardInfo === void 0 ? void 0 : rewardInfo.name }), jsxRuntime.jsx("div", { className: "w-full mt-5", children: jsxRuntime.jsx(Button$1, { size: "lg", onClick: handleClose, loading: isLoading || querying, isBlock: true, children: t('got_it') }) })] }) })] }));
}

var __rest$n = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const alertVariants = classVarianceAuthority.cva('relative rounded-xl border flex justify-center flex-col md:flex-row md:justify-between items-center gap-3 py-2 px-3 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-default', {
    variants: {
        variant: {
            default: 'bg-surface-default text-default',
            destructive: 'border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive',
            warning: 'bg-surface-accent-yellow-subtlest border-surface-accent-yellow-subtle text-default',
            info: 'bg-surface-accent-blue-subtlest border-surface-accent-blue-subtle text-default',
            error: 'bg-surface-accent-red-subtlest border-surface-accent-red-subtle text-default'
        }
    },
    defaultVariants: {
        variant: 'default'
    }
});
const Alert = React__namespace.forwardRef((_a, ref) => {
    var { className, variant } = _a, props = __rest$n(_a, ["className", "variant"]);
    return (jsxRuntime.jsx("div", Object.assign({ ref: ref, role: "alert", className: cn(alertVariants({ variant }), className) }, props)));
});
Alert.displayName = 'Alert';
const AlertTitle = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$n(_a, ["className"]);
    return (jsxRuntime.jsx("h5", Object.assign({ ref: ref, className: cn('mb-1 font-medium leading-none tracking-tight', className) }, props)));
});
AlertTitle.displayName = 'AlertTitle';
const AlertDescription = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$n(_a, ["className"]);
    return (jsxRuntime.jsx("div", Object.assign({ ref: ref, className: cn('text-base [&_p]:leading-relaxed', className) }, props)));
});
AlertDescription.displayName = 'AlertDescription';

function ClaimPasscard({ onClose, type }) {
    const t = nextIntl.useTranslations('chat');
    const [usedItem, setUsedItem] = React.useState();
    const [seasonPassUseSuccessModalVisible, setSeasonPassUseSuccessModalVisible] = React.useState(false);
    const [beforeCloseLoading, setBeforeCloseLoading] = React.useState(false);
    const { acting, handleRedeemAndUseSeasonPass } = useRedeemAndUseSeasonPass();
    const { getEnergyInfo } = useGetEnergyInfo();
    const { queryUserProfile } = useUpdateUserProfile();
    const handleClaimSeasonPasscard = () => {
        handleRedeemAndUseSeasonPass((item) => {
            setUsedItem(item);
            setSeasonPassUseSuccessModalVisible(true);
        });
    };
    const handleClose = async () => {
        try {
            setBeforeCloseLoading(true);
            await Promise.all([getEnergyInfo(), queryUserProfile()]);
            setSeasonPassUseSuccessModalVisible(false);
            onClose === null || onClose === void 0 ? void 0 : onClose();
        }
        catch (e) {
        }
        finally {
            setBeforeCloseLoading(false);
        }
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(Alert, { variant: "warning", className: "w-full flex-col md:flex-col lg:flex-row", children: [jsxRuntime.jsx(AlertDescription, { children: jsxRuntime.jsxs("div", { className: "flex gap-[6px]", children: [jsxRuntime.jsx(ForwardRef$U, { className: "hidden md:block shrink-0 size-6 text-icon-warning" }), jsxRuntime.jsx(Text, { children: type === 'action' ? t('action_claim_season_passcard_tip') : t('claim_season_passcard_tip') })] }) }), jsxRuntime.jsx(Button$1, { size: "md", color: "warning", onClick: handleClaimSeasonPasscard, className: "md:flex-none w-full md:w-fit self-end lg:self-auto", loading: acting, children: t('claim_season_passcard_btn_text') })] }), seasonPassUseSuccessModalVisible && (jsxRuntime.jsx(UseSeasonPassSuccessModal, { isOpen: seasonPassUseSuccessModalVisible, onClose: handleClose, rewardInfo: usedItem, isLoading: beforeCloseLoading }))] }));
}

var __rest$m = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function Link$1(_a) {
    var { className, href, scroll = false, replace = false, prefetch = true, children, onClick } = _a, props = __rest$m(_a, ["className", "href", "scroll", "replace", "prefetch", "children", "onClick"]);
    const externalLink = /^(https?:\/\/)/.test(typeof href === 'string' ? href : `${href.pathname}`);
    return (jsxRuntime.jsx(LinkComponent__default.default, Object.assign({ href: href, scroll: scroll, replace: replace, prefetch: prefetch, onClick: onClick, className: cn(className), rel: externalLink ? 'nofollow,noreferrer' : 'dofollow', target: externalLink ? '_blank' : undefined }, props, { children: children })));
}

function getValueFromSubType(subType) {
    const match = subType.match(/\d+/);
    return !!(match === null || match === void 0 ? void 0 : match.length) ? match[(match === null || match === void 0 ? void 0 : match.length) - 1] : '';
}

function useCheckEnergyPack() {
    const t = nextIntl.useTranslations('common');
    const { warning } = useNotification();
    const myProps = useTaskStore(state => state.myProps);
    const setNoEnergyWithUsablePropModalVisible = useGlobalStore(state => state.setNoEnergyWithUsablePropModalVisible);
    const usableEnergyPack = React.useMemo(() => {
        const ownEnergyPack = myProps.filter(prop => prop.propType === PropTypeEnum.energyPack && (!prop.endDate || dayjs__default.default().isBefore(dayjs__default.default(prop.endDate))));
        if (!ownEnergyPack.length) {
            return null;
        }
        else {
            return ownEnergyPack.reduce((min, current) => {
                return Number(getValueFromSubType(current === null || current === void 0 ? void 0 : current.subType)) < Number(getValueFromSubType(min === null || min === void 0 ? void 0 : min.subType))
                    ? current
                    : min;
            });
        }
    }, [myProps]);
    const getIsNoEnergy = React.useCallback(() => {
        if (usableEnergyPack) {
            return true;
        }
        else {
            warning({
                content: t('no_enough_energy_for_current_action'),
                id: 'reach-limitation-warning'
            });
            return false;
        }
    }, [setNoEnergyWithUsablePropModalVisible, usableEnergyPack]);
    const checkBeforePopupNoEnergy = React.useCallback(() => {
        if (usableEnergyPack) {
            setNoEnergyWithUsablePropModalVisible(true);
        }
        else {
            warning({
                content: t('no_enough_energy_for_current_action'),
                id: 'reach-limitation-warning'
            });
            return;
        }
    }, [setNoEnergyWithUsablePropModalVisible, usableEnergyPack]);
    return {
        usableEnergyPack,
        checkBeforePopupNoEnergy,
        getIsNoEnergy
    };
}

function SuccessTipModal({ isOpen, onClose, rewardInfo, count, isLoading = false }) {
    const commonT = nextIntl.useTranslations('common');
    const t = nextIntl.useTranslations('reward_center.reward_redemption_content.rewards');
    return (jsxRuntime.jsx(Modal, { open: isOpen, onClose: onClose, size: "sm", modalOnly: true, children: jsxRuntime.jsxs(ModalBody, { className: "p-5", children: [jsxRuntime.jsxs("div", { className: "flex flex-col", children: [jsxRuntime.jsx(Display$1, { size: "xl", children: `🎉` }), jsxRuntime.jsx(Display$1, { size: "sm", className: "mt-3", children: commonT('congrats_verb') }), jsxRuntime.jsx(Text, { className: "mt-1.5", children: rewardInfo.propType === PropTypeEnum.seasonBadge ||
                                (rewardInfo.propType === PropTypeEnum.standardBattlePass && !rewardInfo.subType.includes('m')) ||
                                (rewardInfo.propType === PropTypeEnum.energyPack && !rewardInfo.subType.includes('bonus'))
                                ? t(`${camelToSnake(rewardInfo.propType)}.use_success_tip`, {
                                    count: Number(getValueFromSubType(rewardInfo.subType)) * count
                                })
                                : t(`${camelToSnake(rewardInfo.subType)}.use_success_tip`, {
                                    count: Number(getValueFromSubType(rewardInfo.subType)) * count
                                }) })] }), jsxRuntime.jsx("div", { className: "w-full flex justify-center items-center mt-5", children: jsxRuntime.jsx(Button$1, { variant: "primary", size: "lg", isBlock: true, loading: isLoading, onClick: onClose, tabIndex: -1, children: commonT('got_it') }) })] }) }));
}

function getProps() {
    return APIFetch.post('/v1/backpack/list', {
        isGoLang: true,
        adapter: (res) => {
            return res.items.map(item => ({
                id: item.item.id,
                name: item.item.name,
                description: item.item.description,
                media: getAssetsUrl(item.item.mediaUrl),
                count: item.count,
                propType: item.item.itemType,
                subType: item.item.subType,
                startDate: Number(item.item.usableStartDateUnix) ? dayjs__default.default(Number(item.item.usableStartDateUnix)) : undefined,
                endDate: Number(item.item.usableEndDateUnix) ? dayjs__default.default(Number(item.item.usableEndDateUnix)) : undefined,
                status: item.status
            }));
        }
    });
}
function onUseProp(propId, count) {
    return APIFetch.post('/v1/backpack/use_backpack_item', {
        body: {
            backpackItemId: propId,
            count
        },
        isGoLang: true
    });
}
function getShellCoinExchange() {
    return APIFetch.post('/v1/season/reward/get_season_point_to_shell_coin_exchange_info', {
        isGoLang: true,
        adapter: (res) => {
            return res.exchangeRatios.map(({ point, pointText, pointType, ratio, targetAmount, targetAmountText }) => ({
                point,
                text: pointText,
                type: pointType,
                ratio,
                targetAmount,
                targetAmountText
            }));
        }
    });
}
function exchangeShellCoin() {
    return APIFetch.post('/v1/season/reward/exchange_shell_coin_with_season_points', {
        isGoLang: true,
        withMyShellSecurityToken: true,
        adapter: (res) => {
            return res.order;
        }
    });
}
function getUserHoldBadge() {
    return APIFetch.post('/v1/shell_coins/get_badge_exchange_shell_coin_info', {
        isGoLang: true,
        adapter: (res) => {
            return res.badgeShellCoinExchangeInfo;
        }
    });
}
function badgeToShellCoin(exchangeBadges) {
    return APIFetch.post('/v1/shell_coins/exchange_shell_coin_with_badges', {
        body: {
            wantExchangeBadgeInfos: exchangeBadges
        },
        isGoLang: true,
        withMyShellSecurityToken: true,
        adapter: (res) => {
            return res.orders;
        }
    });
}

function useGetProps() {
    const setMyProps = useTaskStore(state => state.setMyProps);
    const myProps = useTaskStore(state => state.myProps);
    const querying = useTaskStore(state => state.myPropsQuerying);
    const setMyPropsQuerying = useTaskStore(state => state.setMyPropsQuerying);
    const queryProps = async () => {
        try {
            setMyPropsQuerying(true);
            const { data } = await getProps();
            setMyProps(data !== null && data !== void 0 ? data : []);
        }
        catch (e) {
        }
        finally {
            setMyPropsQuerying(false);
        }
    };
    return { querying, queryProps, myProps };
}

function useUseProp() {
    const [acting, setActing] = React.useState(false);
    const { queryProps } = useGetProps();
    const handleUseProp = React.useCallback(async (propId, prop, count, successCb) => {
        try {
            setActing(true);
            await onUseProp(propId, count);
            successCb && successCb();
            queryProps();
        }
        catch (e) {
        }
        finally {
            setActing(false);
        }
    }, [queryProps]);
    return {
        acting,
        handleUseProp
    };
}

function EnergyPackUseTip({ onClose, type }) {
    const { acting: usingProp, handleUseProp } = useUseProp();
    const tempEnergyItem = React.useRef();
    const { usableEnergyPack } = useCheckEnergyPack();
    const commonT = nextIntl.useTranslations('common');
    const rT = nextIntl.useTranslations('reward_center');
    const [energyPackUsedModalVisible, setEnergyPackUsedModalVisible] = React.useState(false);
    const [beforeCloseLoading, setBeforeCloseLoading] = React.useState(false);
    const { getEnergyInfo } = useGetEnergyInfo();
    const usePropHandler = React.useCallback(() => {
        tempEnergyItem.current = usableEnergyPack;
        handleUseProp(usableEnergyPack.id, usableEnergyPack, 1, () => {
            setEnergyPackUsedModalVisible(true);
        });
    }, [handleUseProp, usableEnergyPack]);
    const handleClose = React.useCallback(async () => {
        try {
            setBeforeCloseLoading(true);
            await getEnergyInfo();
            onClose === null || onClose === void 0 ? void 0 : onClose();
            tempEnergyItem.current = undefined;
            setEnergyPackUsedModalVisible(false);
        }
        catch (e) {
            console.error(e);
        }
        finally {
            setBeforeCloseLoading(false);
        }
    }, [getEnergyInfo]);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [usableEnergyPack ? (jsxRuntime.jsxs(Alert, { variant: "warning", className: "w-full flex-col md:flex-col lg:flex-row", children: [jsxRuntime.jsx(AlertDescription, { children: jsxRuntime.jsxs("div", { className: "flex gap-[6px]", children: [jsxRuntime.jsx(ForwardRef$U, { className: "hidden md:block shrink-0 size-6 text-icon-warning" }), jsxRuntime.jsx(Text, { children: commonT('usable_energy_pack.desc', {
                                        value: getValueFromSubType(usableEnergyPack.subType)
                                    }) })] }) }), jsxRuntime.jsx(Button$1, { size: "md", color: "warning", onClick: usePropHandler, loading: usingProp, className: "w-full md:w-fit shrink-0 self-end lg:self-auto", children: commonT('use') })] })) : (jsxRuntime.jsxs(Alert, { variant: "warning", className: "w-full flex-col md:flex-col lg:flex-row", children: [jsxRuntime.jsx(AlertDescription, { children: jsxRuntime.jsxs("div", { className: "flex gap-[6px]", children: [jsxRuntime.jsx(ForwardRef$U, { className: "hidden md:block shrink-0 size-6 text-icon-warning" }), jsxRuntime.jsx(Text, { children: commonT(type === 'action' ? 'action_energy_pack_in_reward_center' : 'explore_energy_pack_in_reward_center') })] }) }), jsxRuntime.jsx(Link$1, { href: "/rewards-center/reward-redemption", className: "w-full md:w-fit self-end lg:self-auto md:flex-none", children: jsxRuntime.jsx(Button$1, { size: "md", color: "warning", className: "w-full", children: rT('title') }) })] })), energyPackUsedModalVisible && (jsxRuntime.jsx(SuccessTipModal, { isOpen: energyPackUsedModalVisible, onClose: handleClose, rewardInfo: tempEnergyItem.current, count: 1, isLoading: beforeCloseLoading }))] }));
}

var __rest$l = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const Dialog = DialogPrimitive__namespace.Root;
const DialogPortal = DialogPrimitive__namespace.Portal;
const DialogTrigger = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$l(_a, ["className"]);
    return (jsxRuntime.jsx(DialogPrimitive__namespace.Trigger, Object.assign({ ref: ref, className: cn('ring-offset-surface-default focus-visible:outline-none focus-visible:shadow-none focus-visible:ring-2 focus-visible:ring-brand focus-visible:ring-offset-1', className) }, props)));
});
DialogTrigger.displayName = DialogPrimitive__namespace.Trigger.displayName;
const DialogOverlay = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$l(_a, ["className"]);
    return (jsxRuntime.jsx(DialogPrimitive__namespace.Overlay, Object.assign({ ref: ref, className: cn('fixed inset-0 z-50 bg-opacity-90 md:bg-opacity-75 bg-alpha-mask-desktop data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0', className) }, props)));
});
DialogOverlay.displayName = DialogPrimitive__namespace.Overlay.displayName;
const DialogContent = React__namespace.forwardRef((_a, ref) => {
    var { className, children, hideClose = false, maskClosable = true, overlayClose = true, onClose, overlayClassName, iconClassName } = _a, props = __rest$l(_a, ["className", "children", "hideClose", "maskClosable", "overlayClose", "onClose", "overlayClassName", "iconClassName"]);
    return (jsxRuntime.jsxs(DialogPortal, { children: [jsxRuntime.jsx(DialogOverlay, { onClick: () => {
                    maskClosable && overlayClose && onClose && onClose();
                }, className: overlayClassName }), jsxRuntime.jsxs(DialogPrimitive__namespace.Content, Object.assign({ ref: ref, className: cn('fixed left-[50%] top-[50%] z-50 grid w-[90%] rounded-4xl max-w-lg translate-x-[-50%] translate-y-[-50%] bg-surface-default shadow-modal-default duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] ring-offset-surface-default focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand focus-visible:ring-offset-1 focus-visible:outline-0', className) }, props, { children: [children, !hideClose && (jsxRuntime.jsxs(DialogPrimitive__namespace.Close, { className: cn('w-9 h-9 absolute right-5 top-3 flex justify-center items-center focus-visible:outline-0 rounded-full hover:bg-surface-hovered', iconClassName), onClick: () => {
                            onClose && onClose();
                        }, children: [jsxRuntime.jsx(lucideReact.X, { className: "w-6 h-6 text-icon-subtle" }), jsxRuntime.jsx("span", { className: "sr-only", children: "Close" })] }))] }))] }));
});
DialogContent.displayName = DialogPrimitive__namespace.Content.displayName;
function DialogHeader(_a) {
    var { className } = _a, props = __rest$l(_a, ["className"]);
    return jsxRuntime.jsx("div", Object.assign({ className: cn('flex flex-col p-4', className) }, props));
}
DialogHeader.displayName = 'DialogHeader';
function DialogFooter(_a) {
    var { className } = _a, props = __rest$l(_a, ["className"]);
    return jsxRuntime.jsx("div", Object.assign({ className: cn('flex justify-end p-4', className) }, props));
}
DialogFooter.displayName = 'DialogFooter';
const DialogTitle = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$l(_a, ["className"]);
    return (jsxRuntime.jsx(DialogPrimitive__namespace.Title, Object.assign({ ref: ref, className: cn('text-xl font-normal', className) }, props)));
});
DialogTitle.displayName = DialogPrimitive__namespace.Title.displayName;
const DialogDescription = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$l(_a, ["className"]);
    return (jsxRuntime.jsx(DialogPrimitive__namespace.Description, Object.assign({ ref: ref, className: cn('text-sm text-subtle p-4', className) }, props)));
});
DialogDescription.displayName = DialogPrimitive__namespace.Description.displayName;

const spinnerVariants = classVarianceAuthority.cva('animate-spin', {
    variants: {
        size: {
            '2xs': 'h-3.5 w-3.5',
            xs: 'h-4 w-4',
            sm: 'h-5 w-5',
            md: 'h-6 w-6',
            xl: 'h-7 w-7',
            lg: 'h-9 w-9'
        },
        speed: {
            slow: 'duration-2000',
            default: 'duration-600',
            fast: 'duration-500'
        },
        color: {
            default: 'text-default',
            brand: 'text-brand',
            static: 'text-static',
            warning: 'text-warning',
            success: 'text-success'
        }
    },
    defaultVariants: {
        size: 'md',
        speed: 'default',
        color: 'default'
    }
});
function Spinner(props) {
    const { size, speed, color, className } = props;
    return jsxRuntime.jsx(lucideReact.Loader2, { className: cn(spinnerVariants({ size, speed, color }), className) });
}

const useCopyClipboard = (text, successText, onSuccess, notice = true) => {
    const [value, copy] = usehooksTs.useCopyToClipboard();
    const { success, error } = useNotification();
    const commonT = nextIntl.useTranslations('common');
    const onCopyImage = (url) => {
        let _text = text;
        if (url) {
            _text = url;
        }
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = _text;
        img.onload = () => {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(img, 0, 0);
                canvas.toBlob(blob => {
                    if (blob) {
                        const item = new ClipboardItem({ 'image/png': blob });
                        navigator.clipboard.write([item]);
                        success({ content: commonT('copied') });
                    }
                });
            }
            catch (e) {
                error({ content: `${commonT('copy_failed')} ${e === null || e === void 0 ? void 0 : e.message}` });
            }
        };
    };
    const onCopy = (value) => {
        let _text = text;
        if (value) {
            _text = value;
        }
        copy(_text);
        if (notice) {
            success({ content: successText || commonT('copied'), id: 'text-copied' });
        }
        if (typeof onSuccess === 'function') {
            onSuccess();
        }
    };
    return {
        onCopy,
        onCopyImage,
        value
    };
};

(undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
dayjs__default.default.extend(duration__default.default);
const convertSecondsToMinutesAndSeconds = (seconds) => {
    const duration = dayjs__default.default.duration(seconds, 'seconds');
    const minutes = Math.floor(duration.asMinutes());
    const remainingSeconds = duration.seconds();
    if (minutes > 0) {
        return `${minutes}min${remainingSeconds}s`;
    }
    return `${remainingSeconds}s`;
};
const generateWidgetRunningText = (widgetInfoInProconfig) => {
    const { widgetName, status, endTimeTimestamp, startTimeTimestamp } = widgetInfoInProconfig;
    const seconds = status === 'PROCESSING'
        ? dayjs__default.default().valueOf() / 1000 - Number(startTimeTimestamp)
        : Number(endTimeTimestamp) - Number(startTimeTimestamp);
    return `${widgetName} (${convertSecondsToMinutesAndSeconds(seconds)})`;
};

const getErrorMsgByType$1 = (requestErrorTranslations, type) => {
    switch (type) {
        case MessageRunningErrorType.RUNNING_ERROR_TYPE_ENGINE_ERROR:
            return requestErrorTranslations('chat_error_tip');
        case MessageRunningErrorType.RUNNING_ERROR_TYPE_INNER_COMPONENT_ERROR:
            return requestErrorTranslations('inner_component_error_tip');
        case MessageRunningErrorType.RUNNING_ERROR_TYPE_LLM_TOKEN_TOO_LONG:
            return requestErrorTranslations('exceeded_token_error_tip');
        default:
            return '';
    }
};
const RunningError$1 = ({ chat }) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const t = nextIntl.useTranslations('chat');
    const errorT = nextIntl.useTranslations('request.error');
    const [isOpen, setIsOpen] = React.useState(false);
    const setMessageHandled = useChatStore(state => state.setMessageHandled);
    const { onCopy } = useCopyClipboard(((_a = chat === null || chat === void 0 ? void 0 : chat.runningError) === null || _a === void 0 ? void 0 : _a.errorDetail) || '');
    const isVisitor = useUserStore(user => user.isVisitor);
    const level = useUserStore(state => { var _a; return (_a = state.user) === null || _a === void 0 ? void 0 : _a.level; });
    const energy = useUserStore(state => state.energy);
    const onConfirm = () => {
        onCopy();
        setIsOpen(false);
    };
    const onShowDetail = () => {
        setIsOpen(true);
    };
    const onClose = () => {
        setIsOpen(false);
    };
    const onIgnore = () => {
        setMessageHandled({ botId: chat.botId, msgId: chat.id });
    };
    const errorMessage = React.useMemo(() => { var _a; return getErrorMsgByType$1(errorT, (_a = chat === null || chat === void 0 ? void 0 : chat.runningError) === null || _a === void 0 ? void 0 : _a.errorType); }, [(_b = chat === null || chat === void 0 ? void 0 : chat.runningError) === null || _b === void 0 ? void 0 : _b.errorType]);
    if (((_c = chat === null || chat === void 0 ? void 0 : chat.runningError) === null || _c === void 0 ? void 0 : _c.errorType) === MessageRunningErrorType.RUNNING_ERROR_TYPE_ENERGY_INSUFFICIANT) {
        if (energy > (((_d = chat === null || chat === void 0 ? void 0 : chat.runningError) === null || _d === void 0 ? void 0 : _d.requireEnergyToUse) || 0)) {
            return null;
        }
        if (isVisitor === 2 && level === 1) {
            return (jsxRuntime.jsx("li", { className: "last:animate-slideIn list-none", children: jsxRuntime.jsx(ClaimPasscard, { type: "action", onClose: onIgnore }) }));
        }
        return (jsxRuntime.jsx("li", { className: "last:animate-slideIn list-none", children: jsxRuntime.jsx(EnergyPackUseTip, { type: "action", onClose: onIgnore }) }));
    }
    const hiddenDetail = ((_e = chat.runningError) === null || _e === void 0 ? void 0 : _e.errorType) === MessageRunningErrorType.RUNNING_ERROR_TYPE_LLM_TOKEN_TOO_LONG;
    if (chat.handled) {
        return null;
    }
    return (jsxRuntime.jsxs("div", { className: "mt-4 md:mt-6 md:mx-10", children: [jsxRuntime.jsxs(Alert, { variant: "error", children: [jsxRuntime.jsx(AlertDescription, { children: errorMessage }), jsxRuntime.jsxs("div", { className: "w-full gap-x-2 md:w-auto flex justify-center", children: [hiddenDetail ? null : (jsxRuntime.jsx(Button$1, { className: "flex-1 md:flex-none", color: "error", size: "md", onClick: onShowDetail, children: t('view_details') })), jsxRuntime.jsx(Button$1, { className: "flex-1 md:flex-none", color: "error", size: "md", variant: hiddenDetail ? undefined : 'outline', onClick: onIgnore, children: t('ignore') })] })] }), jsxRuntime.jsx(Dialog, { open: isOpen, children: jsxRuntime.jsxs(DialogContent, { className: "w-310px md:w-[380px]", onClose: onClose, maskClosable: false, children: [jsxRuntime.jsx(DialogHeader, { className: "px-5 h-[68px] flex justify-center", children: jsxRuntime.jsx(DialogTitle, { children: jsxRuntime.jsx(Heading, { size: "h2", children: t('error_detail') }) }) }), jsxRuntime.jsx(DialogDescription, { className: "px-5 pt-1 pb-3 grid gap-y-1.5 overflow-y-auto max-h-96", children: jsxRuntime.jsx(Text, { className: "break-all", dangerous: true, children: ((_g = (_f = chat.runningError) === null || _f === void 0 ? void 0 : _f.errorDetail) === null || _g === void 0 ? void 0 : _g.replaceAll('\n', '<br />')) || '' }) }), jsxRuntime.jsx(DialogFooter, { className: "gap-x-5 min-h-[76px]", children: jsxRuntime.jsxs(Button$1, { className: "w-full", onClick: onConfirm, color: "error", children: [jsxRuntime.jsx(lucideReact.Copy, { className: "w-5 h-5 mr-1.5 mt-0.5" }), t('copy_error_message')] }) })] }) })] }));
};

let encoding = null;
async function getTokenCount(content) {
    if (!encoding) {
        try {
            const tiktoken = await import('js-tiktoken');
            const { getEncoding } = tiktoken;
            encoding = getEncoding('cl100k_base');
        }
        catch (error) {
            console.error('Error loading js-tiktoken:', error);
            throw new Error('Failed to load tokenizer');
        }
    }
    return encoding.encode(content !== null && content !== void 0 ? content : '').length;
}

function useSensors() {
    return {
        track: (eventName, eventProps) => {
            var _a;
            (_a = window === null || window === void 0 ? void 0 : window.sensors) === null || _a === void 0 ? void 0 : _a.track(eventName, Object.assign({}, (eventProps || {})));
        },
        setOnceProfile: (props) => {
            var _a;
            (_a = window === null || window === void 0 ? void 0 : window.sensors) === null || _a === void 0 ? void 0 : _a.setOnceProfile(Object.assign({}, (props || {})));
        },
        setProfile: (props) => {
            var _a;
            (_a = window === null || window === void 0 ? void 0 : window.sensors) === null || _a === void 0 ? void 0 : _a.setProfile(Object.assign({}, (props || {})));
        },
        login: (userId) => {
            var _a;
            (_a = window === null || window === void 0 ? void 0 : window.sensors) === null || _a === void 0 ? void 0 : _a.login(userId);
        }
    };
}

var __rest$k = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const fileQueue = limitQueue(1);
const messagesUnique = (currentData, newData) => {
    const messageMap = {};
    (currentData !== null && currentData !== void 0 ? currentData : []).forEach((message, index) => {
        messageMap[message.id] = Object.assign(Object.assign({}, message), { originalIndex: index });
    });
    newData.forEach((message, index) => {
        messageMap[message.id] = Object.assign(Object.assign({}, message), { originalIndex: message.id in messageMap ? messageMap[message.id].originalIndex : currentData.length + index });
    });
    const uniqueMessages = Object.values(messageMap);
    const sortedMessages = uniqueMessages.sort((a, b) => {
        var _a, _b;
        const timestampA = a.createdDateUnix;
        const timestampB = b.createdDateUnix;
        if (timestampA !== timestampB) {
            return Number(timestampA) - Number(timestampB);
        }
        return ((_a = a.originalIndex) !== null && _a !== void 0 ? _a : 0) - ((_b = b.originalIndex) !== null && _b !== void 0 ? _b : 0);
    });
    return sortedMessages.map((_a) => {
        var message = __rest$k(_a, ["originalIndex"]);
        return message;
    });
};
const DEFAULT_STATE$2 = {
    messageListMap: {},
    lastMsgIdMap: {},
    lastUserInteractionMsgIdMap: {},
    draftReplyMessageMap: {},
    localDraftMessageMap: {},
    localErrorMessageMap: {},
    localFiles: {},
    exceptionsForTextDisplay: {},
    fileUpload: {
        uploading: null,
        deletedList: [],
        alert: {
            visible: false,
            data: []
        }
    }
};
const persistConfig$1 = {
    name: 'chat-storage',
    version: 2,
    storage: createJSONStorage(() => localStorage),
    partialize: state => ({
        localDraftMessageMap: state.localDraftMessageMap,
        exceptionsForTextDisplay: state.exceptionsForTextDisplay,
        localErrorMessageMap: state.localErrorMessageMap
    }),
    merge: (persistedState, currentState) => (Object.assign(Object.assign({}, currentState), { localDraftMessageMap: Object.assign(Object.assign({}, currentState.localDraftMessageMap), persistedState.localDraftMessageMap), exceptionsForTextDisplay: Object.assign(Object.assign({}, currentState.exceptionsForTextDisplay), persistedState.exceptionsForTextDisplay), localErrorMessageMap: Object.assign(Object.assign({}, currentState.localErrorMessageMap), persistedState.localErrorMessageMap) }))
};
const createChatStore = (messageList) => {
    const createChatSlice = (set, get) => {
        return Object.assign(Object.assign({}, DEFAULT_STATE$2), { messageListMap: Object.assign({}, messageList), sendDraftMessage: (type, id, message) => {
                set(state => {
                    var _a, _b, _c, _d;
                    const mapKey = `${type}-${id}`;
                    state.lastUserInteractionMsgIdMap[mapKey] = message.id;
                    state.messageListMap[mapKey] = [...((_a = state.messageListMap[mapKey]) !== null && _a !== void 0 ? _a : []), message];
                    state.lastMsgIdMap[mapKey] = (_c = (_b = state.messageListMap[mapKey].at(-1)) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : '';
                    if ((_d = message.embedObjs) === null || _d === void 0 ? void 0 : _d.length) {
                        state.localFiles[mapKey] = [];
                    }
                });
            }, replaceDraftMessage: (type, id, message) => {
                set(state => {
                    var _a, _b, _c, _d, _e;
                    const mapKey = `${type}-${id}`;
                    const lastUserInteractionMsgId = state.lastUserInteractionMsgIdMap[mapKey];
                    if (!lastUserInteractionMsgId) {
                        state.messageListMap[mapKey] = [...((_a = state.messageListMap[mapKey]) !== null && _a !== void 0 ? _a : []), message];
                        state.lastMsgIdMap[mapKey] = (_c = (_b = state.messageListMap[mapKey].at(-1)) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : '';
                    }
                    else {
                        const msgIdxInList = ((_d = state.messageListMap[mapKey]) !== null && _d !== void 0 ? _d : []).findIndex(msg => msg.id === lastUserInteractionMsgId);
                        if (msgIdxInList >= 0) {
                            (_e = state.messageListMap[mapKey]) === null || _e === void 0 ? void 0 : _e.splice(msgIdxInList, 1, message);
                            state.lastMsgIdMap[mapKey] = message.id;
                            state.lastUserInteractionMsgIdMap[mapKey] = message.id;
                        }
                        else {
                            console.error('logic error');
                        }
                    }
                });
            }, updateReply: (type, id, message) => {
                set(state => {
                    var _a, _b, _c, _d, _e;
                    const mapKey = `${type}-${id}`;
                    const draftReplyMessageId = state.draftReplyMessageMap[mapKey];
                    if (!draftReplyMessageId) {
                        const msgIdx = ((_a = state.messageListMap[mapKey]) !== null && _a !== void 0 ? _a : []).findIndex(msg => msg.id === message.id);
                        if (msgIdx >= 0) {
                            state.messageListMap[mapKey][msgIdx] = message;
                        }
                    }
                    else {
                        const msgIdxInList = ((_b = state.messageListMap[mapKey]) !== null && _b !== void 0 ? _b : []).findIndex(msg => msg.id === draftReplyMessageId);
                        if (msgIdxInList >= 0) {
                            (_c = state.messageListMap[mapKey]) === null || _c === void 0 ? void 0 : _c.splice(msgIdxInList, 1, message);
                            state.draftReplyMessageMap[mapKey] = '';
                        }
                        else {
                            console.error('logic error');
                        }
                    }
                    state.lastMsgIdMap[mapKey] = (_e = (_d = state.messageListMap[mapKey].at(-1)) === null || _d === void 0 ? void 0 : _d.id) !== null && _e !== void 0 ? _e : '';
                });
            }, prependMessages: (type, id, messages) => {
                set(state => {
                    var _a, _b, _c;
                    const mapKey = `${type}-${id}`;
                    state.messageListMap[mapKey] = [...messages, ...((_a = state.messageListMap[mapKey]) !== null && _a !== void 0 ? _a : [])];
                    state.lastMsgIdMap[mapKey] = (_c = (_b = state.messageListMap[mapKey].at(-1)) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : '';
                });
            }, appendMessages: (type, id, messages) => {
                set(state => {
                    var _a, _b, _c;
                    const mapKey = `${type}-${id}`;
                    const msgList = Array.isArray(messages) ? messages : [messages];
                    const draftReplyMessage = msgList.find(message => message.type === 'PENDING_FOR_RESPONSE');
                    if (draftReplyMessage) {
                        state.draftReplyMessageMap[mapKey] = draftReplyMessage.id;
                    }
                    state.messageListMap[mapKey] = [...((_a = state.messageListMap[mapKey]) !== null && _a !== void 0 ? _a : []), ...msgList];
                    state.lastMsgIdMap[mapKey] = (_c = (_b = state.messageListMap[mapKey].at(-1)) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : '';
                });
            }, mixMessages: (type, id, messages) => {
                set(state => {
                    var _a, _b, _c;
                    const mapKey = `${type}-${id}`;
                    const msgList = Array.isArray(messages) ? messages : [messages];
                    state.messageListMap[mapKey] = messagesUnique([...((_a = state.messageListMap[mapKey]) !== null && _a !== void 0 ? _a : [])], msgList);
                    state.lastMsgIdMap[mapKey] = (_c = (_b = state.messageListMap[mapKey].at(-1)) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : '';
                });
            }, addTextStream(type, id, messageId, content, isLlmBot) {
                set(state => {
                    const mapKey = `${type}-${id}`;
                    const messageIndex = state.messageListMap[mapKey].findIndex(msg => msg.id === messageId);
                    if (messageIndex >= 0) {
                        const messageDetail = state.messageListMap[mapKey][messageIndex];
                        state.messageListMap[mapKey][messageIndex] = Object.assign(Object.assign({}, messageDetail), { text: (messageDetail.text || '') + content, isLlmBot });
                    }
                });
            },
            addAudioStream(type, id, messageId, audioChunk) {
                set(state => {
                    const mapKey = `${type}-${id}`;
                    const messageIndex = state.messageListMap[mapKey].findIndex(msg => msg.id === messageId);
                    if (messageIndex >= 0) {
                        const messageDetail = state.messageListMap[mapKey][messageIndex];
                        state.messageListMap[mapKey][messageIndex] = Object.assign(Object.assign({}, messageDetail), { audioBuffer: messageDetail.audioBuffer ? [...messageDetail.audioBuffer, audioChunk] : [audioChunk] });
                    }
                });
            },
            addTranslationStream(type, id, messageId, translation) {
                set(state => {
                    const mapKey = `${type}-${id}`;
                    const messageIndex = state.messageListMap[mapKey].findIndex(msg => msg.id === messageId);
                    if (messageIndex >= 0) {
                        const messageDetail = state.messageListMap[mapKey][messageIndex];
                        state.messageListMap[mapKey][messageIndex] = Object.assign(Object.assign({}, messageDetail), { translation: (messageDetail.translation || '') + translation });
                    }
                });
            }, updateMessage: (type, id, message) => {
                set(state => {
                    var _a;
                    const mapKey = `${type}-${id}`;
                    const messageIndex = state.messageListMap[mapKey].findIndex(msg => msg.id === message.id);
                    if (messageIndex >= 0) {
                        const originMessage = state.messageListMap[mapKey][messageIndex];
                        if ((originMessage.status === 'CANCELING' && message.status !== 'CANCELED') ||
                            originMessage.status === 'CANCELED') {
                            return;
                        }
                        state.messageListMap[mapKey][messageIndex] = Object.assign(Object.assign(Object.assign({}, originMessage), message), { imageGenMessageResponse: (_a = message === null || message === void 0 ? void 0 : message.imageGenMessageResponse) !== null && _a !== void 0 ? _a : originMessage === null || originMessage === void 0 ? void 0 : originMessage.imageGenMessageResponse });
                    }
                });
            }, replaceMessage: (type, id, oldMessageId, newMessage) => {
                set(state => {
                    var _a, _b;
                    const mapKey = `${type}-${id}`;
                    const messageIndex = state.messageListMap[mapKey].findIndex(msg => msg.id === oldMessageId);
                    if (messageIndex >= 0) {
                        state.messageListMap[mapKey][messageIndex] = newMessage;
                    }
                    state.lastMsgIdMap[mapKey] = (_b = (_a = state.messageListMap[mapKey].at(-1)) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : '';
                });
            }, partialUpdateMessage(type, id, messageId, partialDetail) {
                set(state => {
                    const mapKey = `${type}-${id}`;
                    const messageIndex = state.messageListMap[mapKey].findIndex(msg => msg.id === messageId);
                    if (messageIndex >= 0) {
                        const message = state.messageListMap[mapKey][messageIndex];
                        if (message) {
                            if ((message.status === 'CANCELING' && partialDetail.status !== 'CANCELED') ||
                                message.status === 'CANCELED')
                                return;
                            state.messageListMap[mapKey][messageIndex] = Object.assign(Object.assign({}, message), partialDetail);
                        }
                    }
                });
            },
            partialUpdateRegenMessage(type, id, messageId, regenMessageId, partialDetail) {
                set(state => {
                    var _a, _b;
                    const mapKey = `${type}-${id}`;
                    const messageIndex = state.messageListMap[mapKey].findIndex(msg => msg.id === messageId);
                    if (messageIndex >= 0) {
                        const message = state.messageListMap[mapKey][messageIndex];
                        if (message) {
                            if ((message.status === 'CANCELING' && partialDetail.status !== 'CANCELED') ||
                                message.status === 'CANCELED')
                                return;
                            const regenMessageIndex = ((_a = message.regeneratedMessages) !== null && _a !== void 0 ? _a : []).findIndex(msg => regenMessageId === msg.id);
                            if (regenMessageIndex >= 0) {
                                const regenMessage = ((_b = message.regeneratedMessages) !== null && _b !== void 0 ? _b : [])[regenMessageIndex];
                                state.messageListMap[mapKey][messageIndex].regeneratedMessages[regenMessageIndex] = Object.assign(Object.assign({}, regenMessage), partialDetail);
                            }
                        }
                    }
                });
            },
            setLocalDraftMessage(type, id, draftText) {
                set(state => {
                    const mapKey = `${type}-${id}`;
                    if (draftText) {
                        state.localDraftMessageMap[mapKey] = draftText;
                    }
                    else {
                        delete state.localDraftMessageMap[mapKey];
                    }
                    state.localDraftMessageMap = Object.assign({}, state.localDraftMessageMap);
                });
            },
            deleteSpecifiedMessage(type, id, msgId) {
                set(state => {
                    var _a, _b, _c;
                    const mapKey = `${type}-${id}`;
                    if (!msgId) {
                        state.messageListMap[mapKey] = [];
                    }
                    else {
                        state.messageListMap[mapKey] = [...((_a = state.messageListMap[mapKey]) !== null && _a !== void 0 ? _a : [])].filter(msg => msg.id !== msgId);
                    }
                    state.lastMsgIdMap[mapKey] = (_c = (_b = state.messageListMap[mapKey].at(-1)) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : '';
                });
            },
            addTextDisplayException(type, id, msgId) {
                set(state => {
                    var _a;
                    const mapKey = `${type}-${id}`;
                    const exceptions = (_a = state.exceptionsForTextDisplay[mapKey]) !== null && _a !== void 0 ? _a : [];
                    const newExceptions = [...exceptions, msgId];
                    state.exceptionsForTextDisplay = Object.assign(Object.assign({}, state.exceptionsForTextDisplay), { [mapKey]: newExceptions });
                });
            },
            handleInteractionError(type, id, error) {
                set(state => {
                    var _a, _b, _c, _d, _e, _f;
                    const mapKey = `${type}-${id}`;
                    const lastUserInteractionMsgId = state.lastUserInteractionMsgIdMap[mapKey];
                    const draftReplyMessageId = state.draftReplyMessageMap[mapKey];
                    const lastUserInteractionMessageIndex = ((_a = state.messageListMap[mapKey]) !== null && _a !== void 0 ? _a : []).findIndex(msg => msg.id === lastUserInteractionMsgId);
                    const draftReplyMessage = ((_b = state.messageListMap[mapKey]) !== null && _b !== void 0 ? _b : []).find(msg => msg.id === draftReplyMessageId);
                    if (lastUserInteractionMessageIndex >= 0) {
                        const lastUserInteractionMessage = state.messageListMap[mapKey][lastUserInteractionMessageIndex];
                        const newMessage = Object.assign(Object.assign({}, lastUserInteractionMessage), { status: error });
                        state.messageListMap[mapKey][lastUserInteractionMessageIndex] = newMessage;
                        state.localErrorMessageMap[mapKey] = [...((_c = state.localErrorMessageMap[mapKey]) !== null && _c !== void 0 ? _c : []), newMessage];
                        if (draftReplyMessageId && draftReplyMessage && draftReplyMessage.type === 'PENDING_FOR_RESPONSE') {
                            state.messageListMap[mapKey] = [...((_d = state.messageListMap[mapKey]) !== null && _d !== void 0 ? _d : [])].filter(msg => msg.id !== draftReplyMessageId);
                            state.lastMsgIdMap[mapKey] = (_f = (_e = state.messageListMap[mapKey].at(-1)) === null || _e === void 0 ? void 0 : _e.id) !== null && _f !== void 0 ? _f : '';
                            state.draftReplyMessageMap[mapKey] = '';
                        }
                    }
                });
            },
            removeLocalErrorMessage(type, id, msgId) {
                set(state => {
                    var _a;
                    const mapKey = `${type}-${id}`;
                    const newLocalErrorMessageMap = [...state.localErrorMessageMap[mapKey]];
                    const msgIndex = (newLocalErrorMessageMap !== null && newLocalErrorMessageMap !== void 0 ? newLocalErrorMessageMap : []).findIndex(m => m.id === msgId);
                    if (msgIndex >= 0) {
                        newLocalErrorMessageMap.splice(msgIndex, 1);
                    }
                    const indexInIdList = ((_a = state.messageListMap[mapKey]) !== null && _a !== void 0 ? _a : []).findIndex(m => m.id === msgId);
                    if (indexInIdList >= 0) {
                        state.messageListMap[mapKey].splice(indexInIdList, 1);
                    }
                    state.localErrorMessageMap[mapKey] = newLocalErrorMessageMap;
                });
            },
            clearDraftMessage(type, id) {
                set(state => {
                    var _a, _b;
                    const mapKey = `${type}-${id}`;
                    const lastUserInteractionMsgId = state.lastUserInteractionMsgIdMap[mapKey];
                    const draftReplyMessageId = state.draftReplyMessageMap[mapKey];
                    if (lastUserInteractionMsgId) {
                        const index = ((_a = state.messageListMap[mapKey]) !== null && _a !== void 0 ? _a : []).findIndex(m => m.id === lastUserInteractionMsgId);
                        if (index >= 0) {
                            state.messageListMap[mapKey].splice(index, 1);
                        }
                    }
                    if (draftReplyMessageId) {
                        const index = ((_b = state.messageListMap[mapKey]) !== null && _b !== void 0 ? _b : []).findIndex(m => m.id === draftReplyMessageId);
                        if (index >= 0) {
                            state.messageListMap[mapKey].splice(index, 1);
                        }
                    }
                    state.lastUserInteractionMsgIdMap[mapKey] = '';
                    state.draftReplyMessageMap[mapKey] = '';
                });
            },
            async uploadFiles(type, id, files, retry, overrideUploadFileToS3WithProgress) {
                const mapKey = `${type}-${id}`;
                set(state => {
                    const localDraftFiles = state.localFiles[mapKey] || [];
                    if (retry) {
                        const newFiles = localDraftFiles.map(file => {
                            if (file.id === files[0].id) {
                                return files[0];
                            }
                            return file;
                        });
                        state.localFiles[mapKey] = [...newFiles];
                    }
                    else {
                        state.localFiles[mapKey] = [...localDraftFiles, ...files];
                    }
                });
                files.forEach(file => {
                    fileQueue(async () => {
                        const { deletedList } = get().fileUpload;
                        if (deletedList.includes(file.id)) {
                            set(state => {
                                state.fileUpload.deletedList = state.fileUpload.deletedList.filter(id => id !== file.id);
                            });
                            return;
                        }
                        set(state => {
                            state.fileUpload.uploading = file;
                        });
                        let res;
                        if (typeof overrideUploadFileToS3WithProgress === 'function') {
                            res = await overrideUploadFileToS3WithProgress(file.file);
                        }
                        else {
                            res = await uploadFileToS3WithProgress({
                                scenario: Scenario.SCENARIO_IM_CHAT,
                                contentType: file.uiData.contentType,
                                onProgress: value => {
                                    set(state => {
                                        state.fileUpload.uploading = Object.assign(Object.assign({}, file), { progress: value });
                                    });
                                },
                                file: file.file,
                                cancelToken: (cancel) => {
                                    set(state => {
                                        const localDraftFiles = state.localFiles[mapKey] || [];
                                        const newFiles = localDraftFiles.map(draftFile => {
                                            if (draftFile.id === file.id) {
                                                return Object.assign(Object.assign({}, draftFile), { cancelToken: {
                                                        cancel
                                                    } });
                                            }
                                            return draftFile;
                                        });
                                        state.localFiles[mapKey] = [...newFiles];
                                    });
                                }
                            });
                        }
                        const deletedListAfter = get().fileUpload.deletedList;
                        if (deletedListAfter.includes(file.id)) {
                            set(state => {
                                state.fileUpload.deletedList = state.fileUpload.deletedList.filter(id => id !== file.id);
                                state.fileUpload.uploading = null;
                            });
                            return;
                        }
                        set(state => {
                            if (fileQueue.pendingCount === 0) {
                                state.fileUpload.uploading = null;
                            }
                            const { deletedList } = state.fileUpload;
                            if (deletedList.includes(file.id)) {
                                state.fileUpload.uploading = null;
                            }
                            const localDraftFiles = state.localFiles[mapKey] || [];
                            const newFiles = localDraftFiles.map(f => {
                                if (f.id === file.id) {
                                    return Object.assign(Object.assign({}, f), { status: (res === null || res === void 0 ? void 0 : res.objectAccessUrl) ? 'SUCCESS' : 'ERROR', url: res === null || res === void 0 ? void 0 : res.objectAccessUrl });
                                }
                                return f;
                            });
                            state.localFiles[mapKey] = [...newFiles];
                        });
                    });
                });
            },
            deleteUploadFile(type, id, fileId) {
                const mapKey = `${type}-${id}`;
                set(state => {
                    const localFiles = state.localFiles[mapKey] || [];
                    if (fileId) {
                        state.localFiles[mapKey] = [...(localFiles !== null && localFiles !== void 0 ? localFiles : []).filter(file => file.id !== fileId)];
                        const deleteFile = localFiles.find(file => file.id === fileId);
                        if (deleteFile === null || deleteFile === void 0 ? void 0 : deleteFile.cancelToken.cancel) {
                            deleteFile.cancelToken.cancel();
                        }
                        state.fileUpload.deletedList = [...state.fileUpload.deletedList, id];
                    }
                    else {
                        state.localFiles[mapKey] = [];
                    }
                });
            },
            setFileAlert(data) {
                set(state => {
                    state.fileUpload.alert = data;
                });
            } });
    };
    return zustand.createStore()(immer(devtools(persist(createChatSlice, persistConfig$1), { store: 'new-chat' })));
};

const ChatStoreContext = React.createContext(undefined);
let store;
const ChatStoreProvider = ({ children, type, id, messages }) => {
    const storeRef = React.useRef();
    if (!storeRef.current) {
        storeRef.current = createChatStore(type && id && (messages === null || messages === void 0 ? void 0 : messages.length)
            ? {
                [`${type}-${id}`]: messages
            }
            : undefined);
        store = storeRef.current;
    }
    return jsxRuntime.jsx(ChatStoreContext.Provider, { value: storeRef.current, children: children });
};
const useNewChatStore = (selector) => {
    const chatStoreContext = React.useContext(ChatStoreContext);
    if (!chatStoreContext) {
        throw new Error(`chatStoreContext must be used within chatStoreProvider`);
    }
    return zustand.useStore(chatStoreContext, selector);
};
useNewChatStore.getState = () => {
    return store === null || store === void 0 ? void 0 : store.getState();
};

function Termination({ onTerminate, loading }) {
    return (jsxRuntime.jsx(Button$1, { variant: "primary", color: "default", size: "md", onClick: onTerminate, loading: loading, children: jsxRuntime.jsxs("span", { className: "inline-flex space-x-[6px]", children: [jsxRuntime.jsx(ForwardRef$m, { className: "w-5 h-5" }), jsxRuntime.jsx("span", { className: "text-sm", children: "Stop" })] }) }));
}

function PauseIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M6.75 5.25a.75.75 0 0 1 .75-.75H9a.75.75 0 0 1 .75.75v13.5a.75.75 0 0 1-.75.75H7.5a.75.75 0 0 1-.75-.75V5.25Zm7.5 0A.75.75 0 0 1 15 4.5h1.5a.75.75 0 0 1 .75.75v13.5a.75.75 0 0 1-.75.75H15a.75.75 0 0 1-.75-.75V5.25Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$g = /*#__PURE__*/ React__namespace.forwardRef(PauseIcon$1);

function PlayIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M4.5 5.653c0-1.427 1.529-2.33 2.779-1.643l11.54 6.347c1.295.712 1.295 2.573 0 3.286L7.28 19.99c-1.25.687-2.779-.217-2.779-1.643V5.653Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$f = /*#__PURE__*/ React__namespace.forwardRef(PlayIcon$1);

function StopIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M4.5 7.5a3 3 0 0 1 3-3h9a3 3 0 0 1 3 3v9a3 3 0 0 1-3 3h-9a3 3 0 0 1-3-3v-9Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$e = /*#__PURE__*/ React__namespace.forwardRef(StopIcon);

function XMarkIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M5.47 5.47a.75.75 0 0 1 1.06 0L12 10.94l5.47-5.47a.75.75 0 1 1 1.06 1.06L13.06 12l5.47 5.47a.75.75 0 1 1-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 0 1-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 0 1 0-1.06Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$d = /*#__PURE__*/ React__namespace.forwardRef(XMarkIcon);

function KeyboardIcon({ className }) {
    return (jsxRuntime.jsxs("svg", { strokeWidth: "0", viewBox: "0 0 24 24", className: className, focusable: "false", height: "24", width: "24", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("path", { fill: "none", d: "M0 0h24v24H0V0zm0 0h24v24H0V0z" }), jsxRuntime.jsx("path", { d: "M20 7v10H4V7h16m0-2H4c-1.1 0-1.99.9-1.99 2L2 17c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-9 3h2v2h-2zm0 3h2v2h-2zM8 8h2v2H8zm0 3h2v2H8zm-3 0h2v2H5zm0-3h2v2H5zm3 6h8v2H8zm6-3h2v2h-2zm0-3h2v2h-2zm3 3h2v2h-2zm0-3h2v2h-2z", fill: "currentColor" })] }));
}

var __rest$j = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const DropdownMenu = DropdownMenuPrimitive__namespace.Root;
const DropdownMenuTrigger = DropdownMenuPrimitive__namespace.Trigger;
const DropdownMenuSubTrigger = React__namespace.forwardRef((_a, ref) => {
    var { className, inset, children } = _a, props = __rest$j(_a, ["className", "inset", "children"]);
    return (jsxRuntime.jsxs(DropdownMenuPrimitive__namespace.SubTrigger, Object.assign({ ref: ref, className: cn('flex cursor-default select-none items-center rounded-lg px-3 py-2 outline-none focus:bg-surface-container-selected-default data-[state=open]:bg-surface-container-selected-default', inset && 'pl-8', className) }, props, { children: [children, jsxRuntime.jsx(lucideReact.ChevronRight, { className: "ml-auto h-4 w-4" })] })));
});
DropdownMenuSubTrigger.displayName = DropdownMenuPrimitive__namespace.SubTrigger.displayName;
const DropdownMenuSubContent = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$j(_a, ["className"]);
    return (jsxRuntime.jsx(DropdownMenuPrimitive__namespace.SubContent, Object.assign({ ref: ref, className: cn('z-50 min-w-[8rem] overflow-hidden rounded-xl border border-alpha bg-surface-search-field p-2 text-default shadow-modal-default data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2', className) }, props)));
});
DropdownMenuSubContent.displayName = DropdownMenuPrimitive__namespace.SubContent.displayName;
const DropdownMenuContent = React__namespace.forwardRef((_a, ref) => {
    var { className, sideOffset = 4 } = _a, props = __rest$j(_a, ["className", "sideOffset"]);
    return (jsxRuntime.jsx(DropdownMenuPrimitive__namespace.Content, Object.assign({ ref: ref, sideOffset: sideOffset, className: cn('z-[100] min-w-[8rem] overflow-hidden rounded-xl border border-opaque bg-surface-default p-1 text-default shadow-modal-default data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2', className) }, props)));
});
DropdownMenuContent.displayName = DropdownMenuPrimitive__namespace.Content.displayName;
const DropdownMenuItem = React__namespace.forwardRef((_a, ref) => {
    var { className, inset } = _a, props = __rest$j(_a, ["className", "inset"]);
    return (jsxRuntime.jsx(DropdownMenuPrimitive__namespace.Item, Object.assign({ ref: ref, className: cn('relative flex cursor-default select-none items-center rounded-lg px-2 py-1 outline-none transition-colors focus:bg-surface-container-selected-default data-[disabled]:pointer-events-none data-[disabled]:opacity-30', inset && 'pl-8', className) }, props)));
});
DropdownMenuItem.displayName = DropdownMenuPrimitive__namespace.Item.displayName;
const DropdownMenuCheckboxItem = React__namespace.forwardRef((_a, ref) => {
    var { className, children, checked } = _a, props = __rest$j(_a, ["className", "children", "checked"]);
    return (jsxRuntime.jsxs(DropdownMenuPrimitive__namespace.CheckboxItem, Object.assign({ ref: ref, className: cn('relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-slate-100 focus:text-slate-900 data-[disabled]:pointer-events-none data-[disabled]:opacity-30', className), checked: checked }, props, { children: [jsxRuntime.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: jsxRuntime.jsx(DropdownMenuPrimitive__namespace.ItemIndicator, { children: jsxRuntime.jsx(lucideReact.Check, { className: "h-4 w-4" }) }) }), children] })));
});
DropdownMenuCheckboxItem.displayName = DropdownMenuPrimitive__namespace.CheckboxItem.displayName;
const DropdownMenuRadioItem = React__namespace.forwardRef((_a, ref) => {
    var { className, children } = _a, props = __rest$j(_a, ["className", "children"]);
    return (jsxRuntime.jsxs(DropdownMenuPrimitive__namespace.RadioItem, Object.assign({ ref: ref, className: cn('relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-slate-100 focus:text-slate-900 data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-slate-800 dark:focus:text-slate-50', className) }, props, { children: [jsxRuntime.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: jsxRuntime.jsx(DropdownMenuPrimitive__namespace.ItemIndicator, { children: jsxRuntime.jsx(lucideReact.Circle, { className: "h-2 w-2 fill-current" }) }) }), children] })));
});
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive__namespace.RadioItem.displayName;
const DropdownMenuLabel = React__namespace.forwardRef((_a, ref) => {
    var { className, inset } = _a, props = __rest$j(_a, ["className", "inset"]);
    return (jsxRuntime.jsx(DropdownMenuPrimitive__namespace.Label, Object.assign({ ref: ref, className: cn('px-3 py-1 text-sm font-medium', inset && 'pl-8', className) }, props)));
});
DropdownMenuLabel.displayName = DropdownMenuPrimitive__namespace.Label.displayName;
const DropdownMenuSeparator = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$j(_a, ["className"]);
    return (jsxRuntime.jsx(DropdownMenuPrimitive__namespace.Separator, Object.assign({ ref: ref, className: cn('my-1 h-px bg-[var(--border)]', className) }, props)));
});
DropdownMenuSeparator.displayName = DropdownMenuPrimitive__namespace.Separator.displayName;

function removeRoomFromList(id) {
    return APIFetch.post(`/v1/channel/chat/list/delete/${id}`, {
        isGoLang: true
    });
}
function clearHistory(type, id) {
    return APIFetch.post('/v1/chat/deleteAllHistory', {
        body: {
            bizId: id,
            bizType: type === 'widget' ? 'HISTORY_OPERATION_BIZ_TYPE_WIDGET' : 'HISTORY_OPERATION_BIZ_TYPE_BOT'
        },
        isGoLang: true
    });
}
function deleteHistory(type, msgId) {
    return APIFetch.post('/v1/chat/deleteHistoryByMsgId', {
        body: {
            msgIdList: [msgId],
            bizType: type === 'widget' ? 'HISTORY_OPERATION_BIZ_TYPE_WIDGET' : 'HISTORY_OPERATION_BIZ_TYPE_BOT'
        },
        isGoLang: true
    });
}
function messageReport(action, messageId) {
    const feedbackStateMap = {
        Liked: 1,
        Dislike: 2,
        Normal: 3
    };
    return APIFetch.post('/v1/feedback/message', {
        body: {
            action: feedbackStateMap[action],
            messageId
        },
        isGoLang: true
    });
}
function messageFeedback(issueType, messageId, issues, otherDetail) {
    return APIFetch.post('/v1/feedback/issue', {
        body: {
            entityId: messageId,
            issueType,
            content: JSON.stringify({
                issues,
                othersContent: otherDetail
            })
        },
        isGoLang: true
    });
}
function ttsRegen(msgId) {
    return APIFetch.post('/v1/bot/chat/regenerate_tts', {
        body: {
            msgId
        },
        isGoLang: true,
        adapter: (res) => {
            return {
                duration: res.audioFileDurationSeconds,
                audioSpeed: res.audioSpeed,
                audioUrl: res.voiceUrl,
                energyInfo: res.userEnergyInfo
            };
        }
    });
}
function markMessageAsHandled(msgId) {
    return APIFetch.post('/v1/bot/chat/set_message_handled', {
        body: {
            msgId
        },
        isGoLang: true
    });
}
function editMessage(msgId, content) {
    return APIFetch.post('/v1/bot/chat/edit_message', {
        body: {
            msgId,
            content
        },
        isGoLang: true
    });
}

function useClearHistory(type, id, getList, deleteSpecifiedMessageId) {
    const t = nextIntl.useTranslations('workshop');
    const [clearing, setClearing] = reactUse.useToggle(false);
    const { success, error } = useNotification();
    const deleteAll = async () => {
        try {
            setClearing(true);
            const { success: apiSuccess } = await clearHistory(type, id);
            if (apiSuccess) {
                success({
                    content: t('delete_widget_success')
                });
                getList();
                deleteSpecifiedMessageId === null || deleteSpecifiedMessageId === void 0 ? void 0 : deleteSpecifiedMessageId();
            }
            else {
                error({
                    content: t('delete_widget_error')
                });
            }
        }
        catch (e) {
            console.error(e);
            error({
                content: t('delete_widget_error')
            });
        }
        finally {
            setClearing(false);
        }
    };
    return {
        clearing,
        clearHistory: deleteAll
    };
}

function ClearHistory({ type, id, disabled = false, onSuccess }) {
    const { getList } = React.useContext(StaticContext);
    const { deleteSpecifiedMessageId } = React.useContext(MessageContext);
    const [confirming, setConfirming] = reactUse.useBoolean(false);
    const chatLocale = nextIntl.useTranslations('chat');
    const { clearing, clearHistory: handleClearHistory } = useClearHistory(type, id, getList, deleteSpecifiedMessageId);
    const { clearHistory = handleClearHistory } = React.useContext(MessageContext);
    const onClick = () => {
        setConfirming(true);
    };
    const confirmHandler = async () => {
        try {
            await clearHistory();
            onSuccess();
        }
        catch (e) {
            console.error(e);
        }
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(DropdownMenuItem, { disabled: disabled, className: "cursor-pointer flex items-center gap-3 relative text-critical", onSelect: e => e.preventDefault(), onClick: onClick, children: [jsxRuntime.jsx(ForwardRef$l, { className: "size-5 stroke-critical" }), chatLocale('delete_chat_history')] }), confirming && (jsxRuntime.jsx(Modal, { overlayClassName: "z-[100]", contentClassName: "z-[110]", state: "warning", isNotification: true, open: confirming, onClose: () => setConfirming(false), onConfirm: confirmHandler, title: chatLocale('delete_confirmation.header'), description: chatLocale('delete_confirmation.delete_all_content', {
                    entity: type
                }), confirmLoading: clearing }))] }));
}

function msgDisplayTypeParser(type) {
    let msgDisplayType;
    switch (type) {
        case 'TEXT':
        case 'VOICE':
        case 'REPLY':
        case 'GREETING':
        case 'VOICE_CALL_TEXT':
        case 'VOICE_CALL_VOICE':
        case 'VOICE_CALL_REPLY':
        case 'BUTTON_INTERACTION':
            msgDisplayType = 'NORMAL';
            break;
        case 'PROMPT_UPDATED':
        case 'WIDGET_PROMPT_UPDATED':
        case 'NEED_TO_REGISTER':
        case 'VOICE_CALL_END':
        case 'LLM_MODERATION_REQUEST':
        case 'ROOM_CLOSED':
        case 'OTHER_SIDE_LEFT':
        case 'OTHER_SIDE_NO_ENOUGH_ENERGY':
        case 'VISITOR_DISABLED':
        case 'CLAIM_PASSCARD':
        case 'USE_ENERGY_PACK':
            msgDisplayType = 'NOTIFICATION';
            break;
        case 'RESET':
            msgDisplayType = 'INFO';
            break;
        default:
            msgDisplayType = 'NORMAL';
    }
    return msgDisplayType;
}
function draftOrLocalMessageParser(message) {
    return {
        id: message.id,
        text: message.text,
        audioUrl: message.audioUrl,
        status: message.status,
        type: message.type,
        userId: message.userId,
        createdDateUnix: message.createdDateUnix,
        updatedDateUnix: message.updatedDateUnix,
        entityId: message.entityId,
        embedObjs: message.embedObjs,
        slashCommandInput: message.slashCommandInput,
        requestParams: message.requestParams
    };
}
function serverMessageParser(message, type) {
    var _a, _b, _c;
    return {
        id: message.id,
        userId: message.userId,
        referenceText: message.referenceText,
        text: message.text,
        audioUrl: message.voiceUrl,
        duration: message.voiceFileDurationSeconds,
        audioSpeed: message.audioSpeed,
        status: message.status,
        type: message.type,
        createdDateUnix: message.createdDateUnix,
        updatedDateUnix: message.updatedDateUnix,
        entityId: type === 'widget' ? (_a = message.widgetId) !== null && _a !== void 0 ? _a : '' : message.botId,
        replyId: message.replyId,
        feedbackState: message.feedbackState,
        feedbackIssues: message.feedbackIssues,
        asyncJobInfo: message.asyncJobInfo,
        runningWidgetInfo: (_b = message.extraInfo) === null || _b === void 0 ? void 0 : _b.runningWidgetInfo,
        runningError: message.runningError,
        handled: message.handled,
        imageGenMessageResponse: message.imageGenMessageResponse,
        inputSetting: message.inputSetting,
        uploadSetting: message.uploadSetting,
        componentContainer: message.componentContainer,
        embedObjs: message.embedObjs,
        slashCommandInput: message.imSlashCommandInput,
        referenceSource: message.referenceSource,
        recommendatioQuestions: message.recommendationQuestion,
        regeneratedMessages: ((_c = message.regeneratedMessages) !== null && _c !== void 0 ? _c : []).map(m => serverMessageParser(m, type)),
        extraInfo: message.extraInfo,
        isLlmBot: message.isLlmBot
    };
}
function anyTypeMessageParser(message, type) {
    if (message.status === 'DRAFT' || message.status === 'LOCAL_ERROR' || message.status === 'NETWORK_ERROR') {
        return draftOrLocalMessageParser(message);
    }
    return serverMessageParser(message, type);
}
function messageSourceJudgment(messageUserId, userId, messageType) {
    let source = 'OTHER';
    if (messageType === 'TEXT' ||
        messageType === 'VOICE' ||
        messageType === 'BUTTON_INTERACTION' ||
        messageType === 'VOICE_CALL_TEXT') {
        if (messageUserId === userId) {
            source = 'USER';
        }
        else {
            source = 'OTHER_USER';
        }
    }
    return source;
}
function messageAvatarJudgement(message, memberInfoMap) {
    var _a;
    const isEntityMessage = message.type !== 'TEXT' && message.type !== 'VOICE' && message.type !== 'BUTTON_INTERACTION';
    return (_a = memberInfoMap.get(`${isEntityMessage ? 'entity' : 'user'}-${isEntityMessage ? message.entityId : message.userId}`)) === null || _a === void 0 ? void 0 : _a.avatar;
}
function messageMemberNameJudgement(message, memberInfoMap, visitorNameParser) {
    var _a;
    const isEntityMessage = message.type !== 'TEXT' && message.type !== 'VOICE' && message.type !== 'BUTTON_INTERACTION';
    if (!isEntityMessage) {
        const matchedUserInfo = memberInfoMap.get(`user-${message.userId}`);
        if (matchedUserInfo === null || matchedUserInfo === void 0 ? void 0 : matchedUserInfo.isVisitor) {
            return visitorNameParser ? visitorNameParser(matchedUserInfo.nameTag) : matchedUserInfo.name;
        }
        return matchedUserInfo === null || matchedUserInfo === void 0 ? void 0 : matchedUserInfo.name;
    }
    return (_a = memberInfoMap.get(`entity-${message.entityId}`)) === null || _a === void 0 ? void 0 : _a.name;
}
function messageReplyToMemberNameJudgement(message, memberInfoMap) {
    if (message.replyId && message.replyId !== '0') {
        return memberInfoMap.get(`user-${message.userId}`);
    }
    return undefined;
}
function MessageToDisplayParser(message, userId, memberInfoMap, showReplyTo = false, visitorNameParser) {
    var _a;
    return Object.assign(Object.assign({}, message), { avatar: messageAvatarJudgement(message, memberInfoMap), name: messageMemberNameJudgement(message, memberInfoMap, visitorNameParser), replyTo: showReplyTo ? messageReplyToMemberNameJudgement(message, memberInfoMap) : undefined, source: messageSourceJudgment(message.userId, userId, message.type), msgDisplayType: msgDisplayTypeParser(message.type), regeneratedMessages: ((_a = message.regeneratedMessages) !== null && _a !== void 0 ? _a : []).map(msg => MessageToDisplayParser(msg, userId, memberInfoMap, showReplyTo, visitorNameParser)) });
}

function clearMemory(type, id) {
    return APIFetch.post('/v1/chat/reset', {
        body: {
            bizId: id,
            bizType: type === 'widget' ? 'HISTORY_OPERATION_BIZ_TYPE_WIDGET' : 'HISTORY_OPERATION_BIZ_TYPE_BOT'
        },
        isGoLang: true,
        adapter: (res) => {
            return res.messages.map(message => anyTypeMessageParser(message, type));
        }
    });
}

function useClearMemory(type, id, appendMessages, name) {
    const [loading, setLoading] = reactUse.useBoolean(false);
    const commonT = nextIntl.useTranslations('common');
    const t = nextIntl.useTranslations('workshop');
    const { success, error } = useNotification();
    const handleClearMemory = async (successCb) => {
        try {
            setLoading(true);
            const { success: apiSuccess, data } = await clearMemory(type, id);
            if (apiSuccess) {
                success({
                    content: `${name !== null && name !== void 0 ? name : ''} ${commonT('memory_cleared_with')}`
                });
                successCb === null || successCb === void 0 ? void 0 : successCb();
                appendMessages(data !== null && data !== void 0 ? data : [], true);
            }
        }
        catch (e) {
            error({
                content: t('clear_widget_error')
            });
        }
        finally {
            setLoading(false);
        }
    };
    return {
        loading,
        handleClearMemory
    };
}

function ClearMemory({ type, id, disabled = false, onSuccess }) {
    const { entityInfo } = React.useContext(StaticContext);
    const { name } = entityInfo;
    const { appendMessages } = React.useContext(MessageContext);
    const chatLocale = nextIntl.useTranslations('chat');
    const { loading, handleClearMemory } = useClearMemory(type, id, appendMessages, name);
    const { clearMemory = handleClearMemory } = React.useContext(MessageContext);
    const onClick = async () => {
        try {
            clearMemory(onSuccess);
        }
        catch (e) {
            console.error(e);
        }
    };
    return (jsxRuntime.jsxs(DropdownMenuItem, { disabled: disabled || loading, className: "cursor-pointer flex items-center gap-3 relative", onSelect: e => e.preventDefault(), onClick: onClick, children: [loading ? (jsxRuntime.jsx(Spinner, { size: "sm", color: "default" })) : (jsxRuntime.jsx("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsxRuntime.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.3712 5.57263V3.83542C9.3712 3.36599 9.75175 2.98543 10.2212 2.98543C10.6906 2.98543 11.0712 3.36598 11.0712 3.83542V5.57263C11.0712 7.02921 12.252 8.21 13.7085 8.21H16.2957V9.90999H4.14666V8.21H6.73383C8.19041 8.21 9.3712 7.02921 9.3712 5.57263ZM6.73383 6.89131C7.46212 6.89131 8.05252 6.30092 8.05252 5.57263V3.83542C8.05252 2.6377 9.02346 1.66675 10.2212 1.66675C11.4189 1.66675 12.3899 2.6377 12.3899 3.83542V5.57263C12.3899 6.30092 12.9803 6.89131 13.7085 6.89131H16.5076C17.1188 6.89131 17.6144 7.38686 17.6144 7.99814V10.1218C17.6144 10.5432 17.3789 10.9096 17.0324 11.0965L17.6513 14.7292C17.9724 16.6135 16.5207 18.3334 14.6092 18.3334H5.58673C3.67531 18.3334 2.2236 16.6135 2.54463 14.7292L3.17353 11.0378L3.36378 11.0702C3.04269 10.8764 2.82798 10.5242 2.82798 10.1218V7.99814C2.82798 7.38686 3.32352 6.89131 3.93481 6.89131H6.73383ZM4.25575 11.2287L3.62792 14.9138C3.42121 16.127 4.35596 17.2345 5.58673 17.2345H7.01902C7.01323 17.2025 7.0102 17.1696 7.0102 17.136V14.1932C7.0102 13.8898 7.2562 13.6438 7.55965 13.6438C7.86311 13.6438 8.1091 13.8898 8.1091 14.1932V17.136C8.1091 17.1696 8.10608 17.2025 8.10029 17.2345H11.3071C11.3013 17.2025 11.2983 17.1696 11.2983 17.136V14.1932C11.2983 13.8898 11.5443 13.6438 11.8477 13.6438C12.1512 13.6438 12.3972 13.8898 12.3972 14.1932V17.136C12.3972 17.1696 12.3941 17.2025 12.3884 17.2345H14.6092C15.84 17.2345 16.7748 16.127 16.568 14.9138L15.9402 11.2287H4.25575Z", fill: "currentColor" }) })), chatLocale('clear_memory')] }));
}

function MessagesShare({ disabled = false, onSuccess }) {
    const { setEditorMode } = React.useContext(MessageContext);
    const chatLocale = nextIntl.useTranslations('chat');
    const onClick = () => {
        setEditorMode === null || setEditorMode === void 0 ? void 0 : setEditorMode('SHARE');
        onSuccess();
    };
    return (jsxRuntime.jsxs(DropdownMenuItem, { disabled: disabled, className: "cursor-pointer flex items-center gap-3 relative", onSelect: e => e.preventDefault(), onClick: onClick, children: [jsxRuntime.jsx(ForwardRef$O, { className: "size-5" }), chatLocale('share_chat_records')] }));
}

const defaultLocale = 'en';

const useIsMobile = () => {
    const isMobile = useGlobalStore(state => state.isMobile);
    return isMobile;
};
const usePathLocale = () => {
    const pathname = navigation.usePathname() || '';
    const isMobile = useGlobalStore(state => state.isMobile);
    const pathLocale = React.useMemo(() => {
        const allCookies = typeof document !== 'undefined' ? document.cookie : '';
        const localeMatch = allCookies.match(/(^|;\s*)NEXT_LOCALE=([^;]+)/);
        const locale = (localeMatch && (localeMatch === null || localeMatch === void 0 ? void 0 : localeMatch[2])) || 'en';
        return {
            defaultLocale,
            locale,
            pathname,
            isMobile
        };
    }, [pathname, isMobile]);
    return pathLocale;
};

function useRemoveFromList(type, id, getList, partialUpdateDetail) {
    const router = navigation.useRouter();
    const { isMobile } = usePathLocale();
    const getApiFn = () => {
        let apiFn;
        switch (type) {
            case 'bot':
                apiFn = removeBotFromChatList;
                break;
            case 'widget':
                apiFn = removeWidgetFromChatList;
                break;
            case 'room':
                apiFn = removeRoomFromList;
                break;
            default:
                apiFn = removeBotFromChatList;
        }
        return apiFn;
    };
    const [removing, setRemoving] = reactUse.useToggle(false);
    const removeSuccessRedirect = (list) => {
        if (isMobile) {
            let targetPath;
            switch (type) {
                case 'bot':
                case 'room':
                    targetPath = `/m/chat`;
                    break;
                case 'widget':
                    targetPath = `/m/workshop`;
                    break;
                default:
                    targetPath = `/m/chat`;
            }
            router.replace(targetPath);
            return;
        }
        let targetPath;
        const firstItem = list[0];
        switch (type) {
            case 'widget':
                targetPath = list.length ? `/robot-workshop/widget/${list[0].id}` : `/robot-workshop`;
                break;
            case 'bot':
            case 'room':
            default:
                if (firstItem) {
                    targetPath = `/${firstItem.type === 'bot' ? 'chat' : 'room'}/${firstItem.id}`;
                }
                else {
                    targetPath = `/explore`;
                }
                break;
        }
        router.replace(targetPath);
    };
    const remove = async () => {
        try {
            setRemoving(true);
            const { success } = await getApiFn()(id);
            if (success) {
                const data = await getList('remove');
                partialUpdateDetail === null || partialUpdateDetail === void 0 ? void 0 : partialUpdateDetail({
                    pinned: false
                });
                removeSuccessRedirect(data);
            }
            else {
                throw new Error();
            }
        }
        catch (e) {
            console.error(e);
            throw new Error();
        }
        finally {
            setRemoving(false);
        }
    };
    return {
        removing,
        remove
    };
}

function RemoveFromList({ type, id, disabled = false, onSuccess }) {
    const { getList, partialUpdateDetail } = React.useContext(StaticContext);
    const chatLocale = nextIntl.useTranslations('chat');
    const { removing, remove } = useRemoveFromList(type, id, getList, partialUpdateDetail);
    const onClick = async () => {
        try {
            await remove();
            onSuccess();
        }
        catch (e) {
            console.error(e);
        }
    };
    return (jsxRuntime.jsxs(DropdownMenuItem, { disabled: disabled || removing, className: "cursor-pointer flex items-center gap-3 relative", onSelect: e => e.preventDefault(), onClick: onClick, children: [removing ? jsxRuntime.jsx(Spinner, { size: "sm" }) : jsxRuntime.jsx(ForwardRef$k, { className: "size-5" }), chatLocale('remove_from_list')] }));
}

function MenuList$1() {
    const isDesktop = !useGlobalStore(state => state.isMobile);
    const [open, setOpen] = reactUse.useToggle(false);
    const { type, entityInfo, menuDisabled, menuFunctions, customMenuFunction } = React.useContext(StaticContext);
    const { id } = entityInfo;
    const closeMenu = () => {
        setOpen(false);
    };
    return (jsxRuntime.jsxs(DropdownMenu, { open: open, children: [jsxRuntime.jsx(DropdownMenuTrigger, { asChild: true, children: jsxRuntime.jsx(IconButton, { variant: "ghost", color: "brand", size: "md", icon: open ? ForwardRef$j : ForwardRef$L, className: "data-[state=open]:bg-surface-hovered", onClick: () => setOpen(!open), disabled: menuDisabled || (!menuFunctions.length && !(customMenuFunction === null || customMenuFunction === void 0 ? void 0 : customMenuFunction.length)) }) }), jsxRuntime.jsxs(DropdownMenuContent, { className: "w-[calc(100vw-32px)] md:w-fit", side: "top", align: "start", sideOffset: isDesktop ? 8 : 56, collisionPadding: { left: 16, right: 16 }, onInteractOutside: () => setOpen(false), onCloseAutoFocus: e => e.preventDefault(), children: [menuFunctions.map(fn => (jsxRuntime.jsxs(React.Fragment, { children: [fn.menuFunction === exports.MenuFunctionEnum.REMOVE_FROM_LIST && (jsxRuntime.jsx(RemoveFromList, { type: type, id: id, onSuccess: closeMenu })), fn.menuFunction === exports.MenuFunctionEnum.SHARE && jsxRuntime.jsx(MessagesShare, { onSuccess: closeMenu }), fn.menuFunction === exports.MenuFunctionEnum.CLEAR_MEMORY && (jsxRuntime.jsx(ClearMemory, { type: type, id: id, onSuccess: closeMenu })), fn.menuFunction === exports.MenuFunctionEnum.CLEAR_HISTORY && (jsxRuntime.jsx(ClearHistory, { type: type, id: id, onSuccess: closeMenu }))] }, fn.menuFunction))), (customMenuFunction !== null && customMenuFunction !== void 0 ? customMenuFunction : []).map((menu, index) => {
                        const Ele = React.cloneElement(menu, {
                            onSuccess: closeMenu
                        });
                        return jsxRuntime.jsx(React.Fragment, { children: Ele }, index);
                    })] })] }));
}

function CountdownTips() {
    const toast = react.useToast();
    const timerRef = React.useRef(null);
    const toastIdRef = React.useRef(null);
    React.useEffect(() => {
        let time = 10;
        function addToast() {
            toastIdRef.current = toast({
                position: 'top',
                title: 'Warning!',
                description: `Stop recording after ${time} s`,
                status: 'warning',
                duration: 10000,
                isClosable: true
            });
        }
        addToast();
        timerRef.current = setInterval(() => {
            if (time >= 0) {
                if (toastIdRef.current) {
                    time--;
                    toast.update(toastIdRef.current, {
                        position: 'top',
                        title: 'Warning!',
                        description: `Stop recording after ${time} s`,
                        status: 'warning',
                        duration: 10000,
                        isClosable: true
                    });
                }
            }
        }, 1000);
        return () => {
            clearInterval(timerRef.current);
        };
    }, []);
    return jsxRuntime.jsx(jsxRuntime.Fragment, {});
}

var EventTypes;
(function (EventTypes) {
    EventTypes["DELETE_MEMORY"] = "DELETE_MEMORY";
    EventTypes["SHOW_BOT_MODAL"] = "SHOW_BOT_MODAL";
    EventTypes["SHOW_BOT_POPUP"] = "SHOW_BOT_POPUP";
    EventTypes["AWAIT_RECORD_COMPLETE"] = "AWAIT_RECORD_COMPLETE";
    EventTypes["TRANSLATE"] = "TRANSLATE";
    EventTypes["SHOW_WIDGET_MODAL"] = "SHOW_WIDGET_MODAL";
    EventTypes["SHOW_WIDGET_POPUP"] = "SHOW_WIDGET_POPUP";
    EventTypes["DELETE_WIDGET_MEMORY"] = "DELETE_WIDGET_MEMORY";
})(EventTypes || (EventTypes = {}));

const maxRecordingTime = 90;
var RecordStateEnum;
(function (RecordStateEnum) {
    RecordStateEnum["Idle"] = "Idle";
    RecordStateEnum["Recording"] = "Recording";
    RecordStateEnum["Stopped"] = "Stopped";
    RecordStateEnum["Playing"] = "Playing";
    RecordStateEnum["Completed"] = "Completed";
    RecordStateEnum["CallUping"] = "CallUping";
})(RecordStateEnum || (RecordStateEnum = {}));
var RecordActionType;
(function (RecordActionType) {
    RecordActionType["INIT"] = "INIT";
    RecordActionType["SET_RECORDER"] = "SET_RECORDER";
    RecordActionType["SET_TIME"] = "SET_TIME";
    RecordActionType["SET_TIME_UPDATE"] = "SET_TIME_UPDATE";
})(RecordActionType || (RecordActionType = {}));
const initialState$1 = {
    status: RecordStateEnum.Idle,
    timeLeft: maxRecordingTime,
    duration: 0,
    recordBlob: null,
    recordBlobDataURI: '',
    recorder: null,
    chunks: [],
    audioUrl: '',
    callUping: false,
    timeUpdate: 0,
    mimeType: ''
};
const reducer$1 = (state, action) => {
    const { type, payload = {} } = action;
    switch (type) {
        case RecordActionType.INIT:
            return Object.assign({}, initialState$1);
        case RecordStateEnum.CallUping:
            return Object.assign(Object.assign({}, state), payload);
        case RecordStateEnum.Recording:
            return Object.assign(Object.assign(Object.assign({}, state), { chunks: [], status: RecordStateEnum.Recording }), payload);
        case RecordStateEnum.Stopped:
            return Object.assign(Object.assign(Object.assign({}, state), { status: RecordStateEnum.Stopped }), payload);
        case RecordStateEnum.Playing:
            return Object.assign(Object.assign(Object.assign({}, state), { status: RecordStateEnum.Playing }), payload);
        case RecordStateEnum.Completed:
            return Object.assign(Object.assign(Object.assign({}, state), { status: RecordStateEnum.Completed }), payload);
        case RecordActionType.SET_RECORDER:
            return Object.assign(Object.assign({}, state), payload);
        case RecordActionType.SET_TIME: {
            const newTimeLeft = state.timeLeft - 1;
            const needStop = newTimeLeft === 0;
            const status = needStop ? RecordStateEnum.Stopped : state.status;
            return Object.assign(Object.assign({}, state), { duration: state.duration + 1, status, timeLeft: newTimeLeft });
        }
        case RecordActionType.SET_TIME_UPDATE:
            return Object.assign(Object.assign({}, state), payload);
        default:
            return state;
    }
};
function useRecorder({ onChangePlayingAudio, onChangeInputType, onRecordEnd }) {
    const isMobile = useGlobalStore(state => state.isMobile);
    const commonT = nextIntl.useTranslations('common');
    const { error } = useNotification();
    const [state, dispatch] = React.useReducer(reducer$1, initialState$1);
    const [supportedType, setSupportedType] = React.useState('');
    const timerRef = React.useRef();
    const destoryRef = React.useRef(false);
    const timeLeftRef = React.useRef(state.timeLeft);
    React.useMemo(() => {
        timeLeftRef.current = state.timeLeft;
    }, [state.timeLeft]);
    React.useEffect(() => {
        setSupportedType(checkSupportedMimeType());
    }, []);
    const destroyAudioRecorder = React.useCallback(async () => {
        if (state.recorder && state.recorder.state === 'recording') {
            return new Promise(resolve => {
                if (state.recorder) {
                    state.recorder.stop();
                    state.recorder.stream.getTracks().forEach((track) => {
                        track.stop();
                    });
                    const cb = (data) => {
                        dispatch({
                            type: RecordStateEnum.Stopped,
                            payload: {
                                recorder: null
                            }
                        });
                        resolve(data);
                    };
                    EventEmitter.subscribe(EventTypes.AWAIT_RECORD_COMPLETE, cb, true);
                }
            });
        }
    }, [state.recorder]);
    const startRecording = React.useCallback(async () => {
        destoryRef.current = false;
        if (state.recorder) {
            await destroyAudioRecorder();
        }
        dispatch({
            type: RecordStateEnum.CallUping,
            payload: {
                callUping: true,
                status: isMobile ? RecordStateEnum.Recording : RecordStateEnum.Idle
            }
        });
        setTimeout(() => {
            if (checkAudioRecordSupport()) {
                requestAudioRecordAccess().then(stm => {
                    try {
                        if (supportedType) {
                            dispatch({
                                type: RecordActionType.SET_RECORDER,
                                payload: {
                                    recorder: new MediaRecorder(stm, {
                                        mimeType: supportedType
                                    }),
                                    mimeType: supportedType
                                }
                            });
                        }
                        else {
                            dispatch({
                                type: RecordActionType.SET_RECORDER,
                                payload: {
                                    recorder: new MediaRecorder(stm)
                                }
                            });
                        }
                    }
                    catch (e) {
                        error({
                            content: "The browser doesn't support mediaRecorder",
                            id: 'mediaRecorder'
                        });
                        dispatch({
                            type: RecordStateEnum.CallUping,
                            payload: {
                                callUping: false
                            }
                        });
                    }
                }, err => {
                    error({ content: JSON.stringify(err.message), id: JSON.stringify(err.message) });
                    dispatch({
                        type: RecordStateEnum.CallUping,
                        payload: {
                            callUping: false
                        }
                    });
                    destroyAudioRecorder();
                });
            }
            else {
                dispatch({
                    type: RecordStateEnum.CallUping,
                    payload: {
                        callUping: false
                    }
                });
                error({ content: commonT('not_support_record'), id: commonT('not_support_record') });
            }
        });
    }, [destroyAudioRecorder, error, state.recorder, supportedType, isMobile]);
    const stopRecording = React.useCallback(async () => {
        return destroyAudioRecorder();
    }, [destroyAudioRecorder]);
    React.useEffect(() => {
        if (state.recorder) {
            state.recorder.start();
        }
    }, [state.recorder]);
    React.useEffect(() => {
        if (isMobile) {
            startRecording();
        }
    }, [isMobile]);
    React.useEffect(() => {
        if (state.recorder) {
            state.recorder.ondataavailable = (event) => {
                state.chunks.push(event.data);
            };
        }
    }, [state.recorder, state.chunks]);
    React.useEffect(() => {
        if (state.recorder) {
            state.recorder.onstop = async () => {
                clearInterval(timerRef.current);
                const blob = new Blob(state.chunks, { type: supportedType });
                const payload = {
                    timeLeft: maxRecordingTime,
                    chunks: [],
                    recordBlob: blob,
                    audioUrl: URL.createObjectURL(blob),
                    mimeType: supportedType
                };
                dispatch({
                    type: RecordStateEnum.Completed,
                    payload
                });
                EventEmitter.dispatch(EventTypes.AWAIT_RECORD_COMPLETE, payload);
            };
        }
    }, [state.chunks, state.recorder, supportedType]);
    React.useEffect(() => {
        if (state.recorder) {
            state.recorder.onerror = (err) => {
                error({ content: err.toString(), id: err.toString() });
                destroyAudioRecorder();
            };
        }
    }, [destroyAudioRecorder, error, state.recorder]);
    const onStart = React.useCallback(() => {
        onChangeInputType('audio');
        onChangePlayingAudio();
        dispatch({
            type: RecordStateEnum.Recording
        });
        if (timerRef.current) {
            clearInterval(timerRef.current);
        }
        timerRef.current = window.setInterval(() => {
            if (timeLeftRef.current) {
                const newTimeLeft = timeLeftRef.current - 1;
                if (newTimeLeft === 0) {
                    stopRecording();
                }
            }
            dispatch({
                type: RecordActionType.SET_TIME
            });
        }, 1000);
    }, [onChangeInputType, onChangePlayingAudio, stopRecording]);
    React.useEffect(() => {
        if (state.recorder) {
            state.recorder.onstart = () => {
                onStart();
            };
        }
    }, [state.recorder, onStart]);
    const clearRecord = React.useCallback(async () => {
        destoryRef.current = true;
        await stopRecording();
        return new Promise(resolve => {
            setTimeout(() => {
                dispatch({
                    type: RecordActionType.INIT
                });
                resolve(true);
            }, 50);
        });
    }, [state.recorder, stopRecording]);
    React.useEffect(() => {
        const keydownHandler = async (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            if (e.code === 'Space') {
                e.preventDefault();
                if (state.status === RecordStateEnum.Idle) {
                    startRecording();
                }
                if (state.status === RecordStateEnum.Recording) {
                    const recordData = (await stopRecording());
                    await onRecordEnd(recordData);
                }
                if (state.status === RecordStateEnum.Stopped) {
                    await onRecordEnd(state);
                }
            }
            if (e.code === 'Enter') {
                e.preventDefault();
                if (state.status === RecordStateEnum.Completed) {
                    await onRecordEnd(state);
                }
            }
            if (e.code === 'Escape') {
                e.preventDefault();
                if (state.status === RecordStateEnum.Recording) {
                    stopRecording();
                }
                clearRecord();
            }
        };
        window.addEventListener('keydown', keydownHandler);
        return () => {
            window.removeEventListener('keydown', keydownHandler);
        };
    }, [clearRecord, state, onRecordEnd]);
    return {
        supportedType,
        startRecording,
        stopRecording,
        clearRecord,
        state,
        dispatch
    };
}

function AudioRecorder({ interacting = false, disabled = false, exitAudioInput, scrollLayoutToTop, onSend }) {
    const { setInputMode } = React.useContext(MessageContext);
    const t = nextIntl.useTranslations('chat');
    const audioPlayerRef = React.useRef(null);
    const isMobile = useGlobalStore(state => state.isMobile);
    const [sending, setSending] = React.useState(false);
    const onChangeInputType = () => { };
    const onRecordEnd = async (state) => { };
    const onChangePlayingAudio = () => { };
    const { clearRecord, state, startRecording, stopRecording, dispatch } = useRecorder({
        onChangeInputType,
        onRecordEnd,
        onChangePlayingAudio
    });
    const handleDelete = async () => {
        try {
            if (isMobile) {
                setInputMode === null || setInputMode === void 0 ? void 0 : setInputMode('TEXT');
            }
            await clearRecord();
        }
        catch (error) {
            console.error(error);
        }
    };
    const timeUpdate = React.useCallback(() => {
        if (audioPlayerRef.current) {
            const { currentTime } = audioPlayerRef.current;
            dispatch({
                type: RecordActionType.SET_TIME_UPDATE,
                payload: {
                    timeUpdate: currentTime
                }
            });
        }
    }, [dispatch]);
    const startPlaying = () => {
        dispatch({
            type: RecordStateEnum.Playing
        });
    };
    const stopPlaying = () => {
        dispatch({
            type: RecordStateEnum.Stopped
        });
    };
    const handleAudioPlay = () => {
        if (audioPlayerRef.current) {
            audioPlayerRef.current.addEventListener('timeupdate', timeUpdate);
            audioPlayerRef.current.play();
            startPlaying();
        }
    };
    const handleAudioPause = () => {
        var _a;
        if (audioPlayerRef.current) {
            audioPlayerRef.current.removeEventListener('timeupdate', timeUpdate);
            (_a = audioPlayerRef.current) === null || _a === void 0 ? void 0 : _a.pause();
            stopPlaying();
        }
    };
    const handleSend = () => {
        const { recordBlob, mimeType } = state;
        if (recordBlob) {
            onSend(recordBlob, mimeType);
            clearRecord();
        }
    };
    const handleMobileSend = async () => {
        setSending(true);
        const data = (await stopRecording());
        const { recordBlob, mimeType } = data;
        if (recordBlob) {
            onSend(recordBlob, mimeType);
            clearRecord();
            setSending(false);
            setInputMode === null || setInputMode === void 0 ? void 0 : setInputMode('TEXT');
        }
    };
    const onStart = () => {
        startRecording();
    };
    const renderRecordIdle = () => {
        return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(MenuList$1, {}), jsxRuntime.jsx("div", { className: clsx__default.default('w-full px-4 py-2 bg-surface-default text-center text-brand text-sm leading-6 border border-default rounded-xl hover:bg-surface-container-hovered cursor-pointer', { 'cursor-not-allowed': disabled }), onClick: onStart, children: t('record_top') }), jsxRuntime.jsx(IconButton, { variant: "ghost", size: "md", color: "brand", onClick: () => {
                        exitAudioInput === null || exitAudioInput === void 0 ? void 0 : exitAudioInput();
                    }, children: jsxRuntime.jsx(KeyboardIcon, { className: "w-6 h-6 text-brand" }) })] }));
    };
    const renderRecording = () => {
        return (jsxRuntime.jsxs("div", { className: "w-full flex items-center flex-col md:flex-row gap-x-2 px-4 md:px-0", children: [jsxRuntime.jsx(IconButton, { variant: "primary", color: "default", size: "md", icon: ForwardRef$d, className: "hidden md:inline-flex", onClick: handleDelete }), jsxRuntime.jsxs("div", { className: "relative w-full px-4 py-2 flex flex-row justify-between text-white text-sm leading-6 rounded-xl cursor-pointer overflow-hidden bg-surface-accent-blue-subtlest md:bg-surface-accent-red-subtlest", onClick: () => !isMobile && stopRecording(), children: [jsxRuntime.jsx("span", { className: "z-10 rounded-xl px-2 py-[2px] text-sm leading-[24px] bg-surface-accent-blue-subtle text-brand md:text-critical md:bg-surface-accent-red-subtle", children: durationFormatter(state.duration) }), sending ? (jsxRuntime.jsx("span", { className: "text-subtle text-sm z-10 self-center", children: t('sending') })) : (jsxRuntime.jsxs("span", { className: "text-sm self-center justify-center z-10 text-brand md:text-critical", children: [t('recording'), "..."] })), jsxRuntime.jsx("div", { className: "z-10 rounded-full bg-surface-accent-red-subtle w-7 h-7 md:flex justify-center items-center hidden", onClick: stopRecording, children: jsxRuntime.jsx(ForwardRef$e, { className: "size-4 text-critical" }) }), jsxRuntime.jsx(IconButton, { className: "md:hidden", variant: "primary", size: "sm", icon: ForwardRef$M, loading: interacting, onClick: handleMobileSend })] }), jsxRuntime.jsx(IconButton, { variant: "primary", color: "default", size: "md", icon: ForwardRef$d, className: "my-2 mx-4 md:hidden rounded-lg border-none bg-surface-pressed", onClick: handleDelete })] }));
    };
    const renderRecordStop = () => {
        return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(IconButton, { variant: "primary", color: "default", size: "md", icon: ForwardRef$d, className: "hidden md:inline-flex", onClick: handleDelete }), jsxRuntime.jsxs("div", { className: "relative w-full px-4 py-2 flex flex-row justify-between text-white text-sm leading-6 rounded-xl cursor-pointer overflow-hidden bg-surface-accent-blue-subtlest md:bg-surface-accent-gray-subtler", onClick: stopRecording, children: [jsxRuntime.jsx("span", { className: "z-10 rounded-xl px-2 py-[2px] text-sm leading-[24px] bg-surface-accent-blue-subtle text-brand md:text-subtle md:bg-surface-accent-gray-subtle", children: durationFormatter(state.duration) }), jsxRuntime.jsx(IconButton, { variant: "ghost", size: "md", onClick: handleAudioPlay, className: "text-brand z-10 bg-surface-accent-gray-subtle w-7 h-7 rounded-full hidden md:flex md:justify-center md:items-center", children: jsxRuntime.jsx(ForwardRef$f, { className: "w-4 h-4" }) }), state.timeUpdate > 0 && (jsxRuntime.jsx("div", { className: "absolute z-0 top-0 left-0 h-full bg-[#E0E0E0] dark:bg-[#595A63] opacity-60 rounded-l-xl", style: { width: `${getPercent(state.timeUpdate, state.duration) * 100}%` } }))] }), jsxRuntime.jsx(IconButton, { variant: "primary", size: "md", icon: ForwardRef$M, loading: interacting, onClick: handleSend })] }));
    };
    const renderRecordPlaying = () => {
        return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(IconButton, { variant: "primary", color: "default", size: "md", icon: ForwardRef$d, className: "hidden md:inline-flex", onClick: handleDelete }), jsxRuntime.jsxs("div", { className: "relative w-full px-4 py-2 flex flex-row justify-between text-white text-sm leading-6 rounded-xl cursor-pointer overflow-hidden bg-surface-accent-blue-subtlest md:bg-surface-accent-gray-subtler", children: [jsxRuntime.jsx("span", { className: "z-10 rounded-xl px-2 py-[2px] text-sm leading-[24px] bg-surface-accent-blue-subtle text-brand md:text-subtle md:bg-surface-accent-gray-subtle", children: durationFormatter(state.duration) }), jsxRuntime.jsx(IconButton, { variant: "ghost", size: "md", onClick: handleAudioPause, className: "text-brand  z-10 bg-surface-accent-gray-subtle w-7 h-7 rounded-full hidden md:flex md:justify-center md:items-center", children: jsxRuntime.jsx(ForwardRef$g, { className: "w-4 h-4" }) }), state.timeUpdate > 0 && (jsxRuntime.jsx("div", { className: "absolute z-0 top-0 left-0 h-full w-full bg-[#E0E0E0] dark:bg-[#595A63] opacity-60 rounded-l-xl", style: { width: `${getPercent(state.timeUpdate, state.duration) * 100}%` } }))] }), jsxRuntime.jsx(IconButton, { variant: "primary", size: "md", icon: ForwardRef$M, onClick: handleSend, loading: sending })] }));
    };
    React.useEffect(() => {
        if (state.status === RecordStateEnum.Recording) {
            scrollLayoutToTop === null || scrollLayoutToTop === void 0 ? void 0 : scrollLayoutToTop();
        }
    }, [scrollLayoutToTop, state.status]);
    return (jsxRuntime.jsxs("div", { className: "flex items-center justify-between", children: [jsxRuntime.jsxs("div", { className: "w-full flex space-x-2 items-center justify-between h-18", children: [state.status === RecordStateEnum.CallUping && jsxRuntime.jsx("div", { children: "111" }), state.status === RecordStateEnum.Idle && renderRecordIdle(), state.status === RecordStateEnum.Recording && renderRecording(), (state.status === RecordStateEnum.Completed || state.status === RecordStateEnum.Stopped) && renderRecordStop(), state.status === RecordStateEnum.Playing && renderRecordPlaying()] }), state.audioUrl && jsxRuntime.jsx("audio", { ref: audioPlayerRef, src: state.audioUrl, onEnded: stopPlaying }), state.timeLeft <= 10 && jsxRuntime.jsx(CountdownTips, {})] }));
}

function AudioInput({ onStart, disabled = false }) {
    return (jsxRuntime.jsx(IconButton, { onClick: onStart, variant: "ghost", color: "brand", size: "md", disabled: disabled, icon: ForwardRef$v }));
}

function DragMask() {
    const chatLocale = nextIntl.useTranslations('chat');
    const { resolvedTheme } = nextThemes.useTheme();
    const isDark = resolvedTheme === 'dark';
    return (jsxRuntime.jsxs("div", { className: "absolute top-0 bottom-0 left-0 right-0 z-10 rounded-3xl bg-alpha-80 flex justify-center items-center flex-col gap-2", children: [jsxRuntime.jsx(Image__default.default, { alt: "drop files", src: isDark ? '/images/file-drop-dark.png' : '/images/file-drop.png', width: 245, height: 116, className: "w-[245px] h-[116px]" }), jsxRuntime.jsx(Text, { children: chatLocale('panel.drop') })] }));
}

function ChevronLeftIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M7.72 12.53a.75.75 0 0 1 0-1.06l7.5-7.5a.75.75 0 1 1 1.06 1.06L9.31 12l6.97 6.97a.75.75 0 1 1-1.06 1.06l-7.5-7.5Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$c = /*#__PURE__*/ React__namespace.forwardRef(ChevronLeftIcon$1);

function ChevronRightIcon$1({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$b = /*#__PURE__*/ React__namespace.forwardRef(ChevronRightIcon$1);

function ArrowPathIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M4.755 10.059a7.5 7.5 0 0 1 12.548-3.364l1.903 1.903h-3.183a.75.75 0 1 0 0 1.5h4.992a.75.75 0 0 0 .75-.75V4.356a.75.75 0 0 0-1.5 0v3.18l-1.9-1.9A9 9 0 0 0 3.306 9.67a.75.75 0 1 0 1.45.388Zm15.408 3.352a.75.75 0 0 0-.919.53 7.5 7.5 0 0 1-12.548 3.364l-1.902-1.903h3.183a.75.75 0 0 0 0-1.5H2.984a.75.75 0 0 0-.75.75v4.992a.75.75 0 0 0 1.5 0v-3.18l1.9 1.9a9 9 0 0 0 15.059-4.035.75.75 0 0 0-.53-.918Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$a = /*#__PURE__*/ React__namespace.forwardRef(ArrowPathIcon);

const useDevice = () => {
    const [device, setDevice] = React.useState(isMobile__default.default());
    const [isWeixin, setIsWeixin] = React.useState(false);
    React.useEffect(() => {
        const device = isMobile__default.default();
        setDevice(device);
        setIsWeixin(navigator.userAgent.toLowerCase().indexOf('micromessenger') !== -1);
    }, []);
    return {
        isMobile: device.phone || device.tablet,
        isIos: device.apple.phone || device.apple.tablet || device.apple.ipod,
        isWeixin
    };
};

let audioAPI = null;
const getAudioAPI = () => {
    if (audioAPI)
        return audioAPI;
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const context = new AudioContext();
    const gainNode = context.createGain();
    gainNode.gain.value = 1;
    let currentSourceNode = null;
    window.addEventListener('touchstart', () => {
        const buffer = context.createBuffer(1, 1, 22050);
        const source = context.createBufferSource();
        source.buffer = buffer;
        source.connect(context.destination);
        source.start(0);
    }, { once: true });
    audioAPI = {
        play(arrayBuffer, start) {
            context.decodeAudioData(arrayBuffer.slice(0), audioBuffer => {
                if (context.state === 'suspended') {
                    if (currentSourceNode) {
                        currentSourceNode.stop();
                    }
                    context.resume();
                }
                if (gainNode.gain.value === 0) {
                    gainNode.gain.value = 1;
                }
                const source = context.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(context.destination);
                currentSourceNode = source;
                source.start(0, start);
            });
        },
        pause() {
            context.suspend();
        }
    };
    return audioAPI;
};
const IosAudioPlayer$2 = React.forwardRef((props, ref) => {
    const audioRef = React.useRef(null);
    const audioApi = getAudioAPI();
    const loadTask = React.useRef();
    React.useLayoutEffect(() => {
        return () => {
            audioApi.pause();
            if (audioRef.current) {
                audioRef.current.pause();
            }
        };
    }, []);
    const handlePlay = React.useCallback(async () => {
        var _a;
        if (!((_a = audioRef.current) === null || _a === void 0 ? void 0 : _a.paused))
            return Promise.reject();
        if (props.src && loadTask.current) {
            const arrayBuffer = await loadTask.current;
            if (arrayBuffer) {
                return audioApi.play(arrayBuffer, audioRef.current.currentTime);
            }
        }
        return Promise.resolve();
    }, []);
    const handleLoad = React.useCallback(async () => {
        if (props.src) {
            try {
                loadTask.current = window
                    .fetch(props.src)
                    .then(response => response.arrayBuffer())
                    .catch(error => {
                    console.error(error);
                });
            }
            catch (error) {
                console.error(error);
            }
        }
    }, []);
    React.useImperativeHandle(ref, () => {
        return {
            play: () => handlePlay()
                .then(() => {
                console.log('audioCompPlay');
                return audioRef.current.play();
            })
                .catch(() => {
            }),
            pause: () => {
                audioAPI === null || audioAPI === void 0 ? void 0 : audioAPI.pause();
                return audioRef.current.pause();
            },
            load: () => {
                handleLoad();
                return audioRef.current.load();
            },
            addEventListener: (type, listener, options) => {
                return audioRef.current.addEventListener(type, listener, options);
            },
            get currentTime() {
                return audioRef.current.currentTime;
            },
            set currentTime(value) {
                audioRef.current.currentTime = value;
            },
            get duration() {
                return audioRef.current.duration;
            },
            get paused() {
                return audioRef.current.paused;
            }
        };
    }, [handlePlay, handleLoad]);
    return jsxRuntime.jsx("audio", Object.assign({}, props, { muted: true, ref: audioRef }));
});
IosAudioPlayer$2.displayName = 'IosAudioPlayer';
const useAudioPlayer = () => {
    const { isIos } = useDevice();
    return !isIos ? 'audio' : IosAudioPlayer$2;
};

function AudioPlaying(props) {
    const playingRef = React.useRef(null);
    React.useEffect(() => {
        const lRef = playingRef.current;
        let animation;
        if (lRef) {
            animation = Lottie__default.default.loadAnimation({
                container: playingRef.current,
                renderer: 'svg',
                loop: true,
                autoplay: true,
                animationData: require('@/common/assets/audio-playing.json')
            });
        }
        return () => animation.destroy();
    }, []);
    return jsxRuntime.jsx("div", { ref: playingRef, className: "w-[12px]" });
}

function AudioPlayer$2(props) {
    const audioRef = React.useRef(null);
    const [duration, setDuration] = React.useState(0);
    const [isPlaying, setIsPlaying] = React.useState(false);
    const [currentTime, setCurrentTime] = React.useState(0);
    const [audioHasError, setAudioHasError] = React.useState(false);
    const src = props.preview;
    const { status } = props.data;
    const isError = status === 'error';
    const isPending = status === 'pending';
    const isSuccess = status === 'completed';
    nextIntl.useTranslations('chat');
    function afterPlayEnd() {
        if (audioRef.current) {
            audioRef.current.currentTime = 0;
        }
        setIsPlaying(false);
    }
    const AudioComponent = useAudioPlayer();
    const handleAudioLoad = () => {
        URL.revokeObjectURL(src);
        const audio = audioRef === null || audioRef === void 0 ? void 0 : audioRef.current;
        setDuration(audio.duration);
    };
    const handleAudioToggle = () => {
        var _a;
        if (audioRef.current) {
            if (audioRef.current.paused) {
                audioRef.current
                    .play()
                    .then(() => {
                    setIsPlaying(true);
                })
                    .catch(err => {
                    console.error(err, err === null || err === void 0 ? void 0 : err.stack);
                });
            }
            else {
                (_a = audioRef.current) === null || _a === void 0 ? void 0 : _a.pause();
                setIsPlaying(false);
            }
        }
    };
    const handleAudioTimeUpdate = () => {
        const audio = audioRef.current;
        if (audio) {
            setCurrentTime(audio.currentTime);
            if (!audio.paused) {
                requestAnimationFrame(handleAudioTimeUpdate);
            }
        }
    };
    const handleAudioError = () => {
        setAudioHasError(true);
    };
    const curDuration = duration;
    const UIDuration = !curDuration
        ? durationFormatter(0)
        : curDuration < 1
            ? durationFormatter(1)
            : durationFormatter(curDuration);
    return (jsxRuntime.jsxs("div", { className: clsx__default.default('audio-player flex flex-col justify-start items-start w-full'), children: [jsxRuntime.jsxs("div", { className: "w-full flex items-center justify-start space-x-2 text-xs", children: [isSuccess && (jsxRuntime.jsx("button", { className: "w-7 h-7 rounded-full bg-surface-primary-default flex justify-center items-center", onClick: handleAudioToggle, children: isPlaying ? jsxRuntime.jsx(AudioPlaying, {}) : jsxRuntime.jsx(ForwardRef$f, { className: "ml-[2px] fill-[#fefefe] w-[16px] h-[16px]" }) })), !isSuccess && (jsxRuntime.jsxs("div", { className: clsx__default.default({
                            'flex justify-center items-center p-1.5 rounded-lg mr-3': true,
                            'bg-[#D72C0D]': isError,
                            'bg-[#8C9196]': isPending
                        }), children: [isError && jsxRuntime.jsx(ForwardRef$a, { className: "w-4 h-4 text-white" }), isPending && (jsxRuntime.jsx("div", { className: "w-4 h-4 flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "sm", className: "text-static w-[14px] h-[14px]" }) }))] })), jsxRuntime.jsxs("div", { className: "flex-1 relative flex flex-col justify-center items-start h-[8px] w-[50px]", children: [jsxRuntime.jsx("div", { className: "relative w-full h-[2px] bg-[#DADFE5] dark:bg-[#383C52]" }), jsxRuntime.jsxs("div", { className: "absolute w-full flex flex-row justify-start items-center", children: [jsxRuntime.jsx("div", { className: "bg-[var(--text)] h-[2px] w-full items-start", style: { width: `${getPercent(currentTime, curDuration) * 100}%` } }), jsxRuntime.jsx("div", { className: "w-[7px] h-[7px] rounded-full bg-[var(--text)]" })] })] }), jsxRuntime.jsx("span", { className: "w-10 text-default bg-surface-container-default text-sm dark:text-brand", children: isPlaying ? durationFormatter(currentTime) : UIDuration })] }), jsxRuntime.jsx(AudioComponent, { ref: audioRef, src: src, onLoadedData: handleAudioLoad, onEnded: afterPlayEnd, onTimeUpdate: handleAudioTimeUpdate, onError: handleAudioError, autoPlay: false })] }));
}

const File$1 = React.memo(({ data, onDelete, onPreview, uploadFiles, index, isChoosingFile }) => {
    const { status, uiData, file, id } = data;
    const { mimeType, icon, iconUrl, bg, type, name, serverType, ex } = uiData || {};
    const isError = status === 'ERROR';
    const isPending = status === 'PENDING';
    const isSuccess = status === 'SUCCESS';
    const isFile = mimeType === 'APPLICATION' || mimeType === 'TEXT';
    const isImage = mimeType === 'IMAGE';
    const isAudio = mimeType === 'AUDIO';
    const isVideo = mimeType === 'VIDEO';
    const preview = React.useMemo(() => {
        if (file) {
            return ['IMAGE', 'AUDIO', 'VIDEO'].includes(mimeType) ? URL.createObjectURL(file) : '';
        }
        return '';
    }, [isPending, index]);
    const handlePreview = (index) => {
        if (isSuccess && (isImage || isVideo)) {
            onPreview(index);
            if (isChoosingFile) {
                isChoosingFile.current = true;
            }
        }
        if (isError) {
            uploadFiles === null || uploadFiles === void 0 ? void 0 : uploadFiles([Object.assign(Object.assign({}, data), { status: 'PENDING' })], true);
        }
    };
    const handleDelete = (e) => {
        var _a;
        e.stopPropagation();
        e.preventDefault();
        (_a = document.getElementById('mobileInput')) === null || _a === void 0 ? void 0 : _a.focus();
        onDelete === null || onDelete === void 0 ? void 0 : onDelete(id);
    };
    return (jsxRuntime.jsxs("div", { className: clsx__default.default('h-14 relative rounded-xl group/attach first:ml-3 last:mr-3 mr-2 cursor-default hover:cursor-pointer', isError ? 'border border-critical' : !(isImage || isVideo) && 'border border-default', {
            relative: isImage || isVideo,
            'flex justify-start items-center px-3 py-1.5': isFile,
            'w-[180px] flex justify-start items-center p-1.5 rounded-xl': isAudio
        }), onClick: e => {
            var _a;
            e.preventDefault();
            (_a = document.getElementById('mobileInput')) === null || _a === void 0 ? void 0 : _a.focus();
            handlePreview(index);
        }, children: [(isAudio || (!isSuccess && isFile)) && (jsxRuntime.jsxs("div", { className: clsx__default.default({
                    'absolute top-0 left-0 right-0 bottom-0 flex justify-center items-center': isImage || isVideo,
                    'size-8 rounded-lg mr-3': !(isImage || isVideo),
                    'bg-surface-critical-default': isError && !(isImage || isVideo),
                    'bg-surface-accent-gray-bolder': isPending && !(isImage || isVideo),
                    hidden: isAudio,
                    'flex justify-center items-center': isFile
                }), style: bg ? { background: bg } : {}, children: [isError && jsxRuntime.jsx(ForwardRef$a, { className: "size-5 text-white" }), isPending && (jsxRuntime.jsx("div", { className: "size-4 flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "sm", className: "text-static size-[14px]" }) }))] })), isSuccess && isFile && (jsxRuntime.jsx("div", { className: "size-8 rounded-lg mr-3", children: jsxRuntime.jsx("img", { src: iconUrl }) })), isFile && (jsxRuntime.jsxs("div", { className: "w-[116px] flex flex-col justify-center items-start", children: [jsxRuntime.jsx("span", { className: "text-xs text-default line-clamp-1 break-all font-medium", children: file.name }), jsxRuntime.jsx("span", { className: "text-xs text-subtle line-clamp-1 break-all", children: type })] })), isImage && (jsxRuntime.jsxs("div", { className: clsx__default.default('size-14 rounded-xl overflow-hidden', isError && 'border border-critical'), children: [jsxRuntime.jsx("img", { src: preview, className: "w-full h-full object-cover", onLoad: () => {
                            URL.revokeObjectURL(preview);
                        } }), !isSuccess && (jsxRuntime.jsxs("div", { className: clsx__default.default('absolute z-[1] left-0 top-0 bottom-0 right-0 rounded-xl flex justify-center items-center bg-beta-black-40'), children: [isPending && (jsxRuntime.jsx("div", { className: "w-4 h-4 flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "sm", className: "text-static w-[14px] h-[14px]" }) })), isError && jsxRuntime.jsx(ForwardRef$a, { className: "w-4 h-4 text-white" })] }))] })), isVideo && (jsxRuntime.jsxs("div", { className: clsx__default.default('relative size-14 rounded-xl overflow-hidden', isError && 'border border-critical'), children: [jsxRuntime.jsx("video", { src: preview, className: "w-full h-full object-fill overflow-hidden", onLoad: () => {
                            URL.revokeObjectURL(preview);
                        } }), jsxRuntime.jsxs("div", { className: clsx__default.default('absolute z-[1] left-0 top-0 bottom-0 right-0 flex justify-center items-center bg-beta-black-40'), children: [isSuccess && jsxRuntime.jsx(ForwardRef$f, { className: "w-5 h-5 text-white" }), isPending && (jsxRuntime.jsx("div", { className: "w-4 h-4 flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "sm", className: "text-static w-[14px] h-[14px]" }) })), isError && jsxRuntime.jsx(ForwardRef$a, { className: "w-4 h-4 text-white" })] })] })), isAudio && jsxRuntime.jsx(AudioPlayer$2, { data: data, preview: preview }), isError && (jsxRuntime.jsx("div", { className: "absolute z-[1] -right-[10px] -top-[10px] rounded-full error-icon bg-surface-container-default justify-center items-center flex group-hover/attach:hidden", children: jsxRuntime.jsx(ForwardRef$i, { className: "size-5 text-icon-critical" }) })), jsxRuntime.jsx(IconButton, { variant: "primary", color: "gray", size: "xs", icon: ForwardRef$d, onClick: handleDelete, className: "absolute z-10 -right-[10px] -top-[10px] flex md:hidden md:group-hover/attach:flex" })] }));
});
File$1.displayName = 'File';
const FileCard = React.memo((props) => (jsxRuntime.jsx(File$1, { data: props.data, onDelete: props.onDelete, onPreview: props.onPreview, uploadFiles: props.uploadFiles, index: props.index, isChoosingFile: props.isChoosingFile })));
FileCard.displayName = 'FileCard';

const ImgVideoPreview$3 = dynamic__default.default(() => Promise.resolve().then(function () { return ImgVideoPreview$1; }), {
    ssr: false
});
const Attachments = React.memo(() => {
    const scrollerRef = React.useRef(null);
    const scrollPositionRef = React.useRef(0);
    const timerRef = React.useRef();
    const { file } = React.useContext(MessageContext);
    const { uploadedFiles = [], uploadFiles, deleteFile, isChoosingFile } = file || {};
    const [scrollState, setScrollState] = React.useState({ canLeft: false, canRight: false });
    const [preview, setPreview] = React.useState({ visible: false, index: 0 });
    const imgVideoList = React.useMemo(() => {
        return uploadedFiles
            .filter(file => ['image', 'video'].includes(file.uiData.mimeType.toLocaleLowerCase()))
            .map(file => {
            var _a;
            return ({
                type: file.uiData.serverType,
                status: 'EMBED_OBJ_STATUS_DONE',
                title: file.uiData.name,
                url: file.url,
                id: file.id,
                iconUrl: (_a = file.uiData.iconUrl) !== null && _a !== void 0 ? _a : '',
                extensionName: file.uiData.ex.toUpperCase()
            });
        });
    }, [uploadedFiles]);
    const onSlide = (e, dir) => {
        var _a;
        e.preventDefault();
        (_a = document.getElementById('mobileInput')) === null || _a === void 0 ? void 0 : _a.focus();
        if (scrollerRef.current) {
            const pDistance = scrollerRef.current.clientWidth;
            const left = scrollPositionRef.current + (dir === 'left' ? -pDistance : pDistance);
            scrollerRef.current.scrollTo({ left, behavior: 'smooth' });
        }
    };
    const setChevronVisible = React.useCallback(() => {
        if (scrollerRef.current) {
            scrollPositionRef.current = scrollerRef.current.scrollLeft;
            const { scrollWidth, clientWidth } = scrollerRef.current;
            setScrollState({
                canLeft: scrollPositionRef.current > 20,
                canRight: clientWidth + scrollPositionRef.current + 10 < scrollWidth
            });
        }
    }, []);
    const onScroll = () => {
        clearTimeout(timerRef.current);
        timerRef.current = setTimeout(setChevronVisible, 100);
    };
    React.useEffect(() => {
        setChevronVisible();
    }, [uploadFiles === null || uploadFiles === void 0 ? void 0 : uploadFiles.length]);
    const onPreview = (index) => {
        setPreview({ visible: true, index });
    };
    const renderItems = (files) => {
        return (files || []).map((item, index) => (jsxRuntime.jsx(FileCard, { data: item, onDelete: deleteFile, onPreview: onPreview, uploadFiles: uploadFiles, index: index, isChoosingFile: isChoosingFile }, item.id)));
    };
    if (uploadedFiles.length === 0) {
        return null;
    }
    return (jsxRuntime.jsxs("div", { className: "attachments relative w-full overflow-x-hidden -ml-3 -mr-3 px-3", children: [jsxRuntime.jsx(IconButton, { variant: "outline", size: "lg", icon: ForwardRef$c, className: clsx__default.default('absolute left-0 top-1/2 -translate-y-1/2 z-10 mt-[5px]', scrollState.canLeft ? 'flex' : 'hidden'), onClick: e => onSlide(e, 'left') }), jsxRuntime.jsx("div", { className: "w-full flex overflow-x-scroll no-scrollbar pt-[10px]", ref: scrollerRef, onScroll: onScroll, children: renderItems(uploadedFiles) }), jsxRuntime.jsx(Button$1, { variant: "outline", size: "lg", icon: ForwardRef$b, className: clsx__default.default('absolute right-0 top-1/2 -translate-y-1/2 z-10 mt-[5px]', scrollState.canRight ? 'flex' : 'hidden'), onClick: e => onSlide(e, 'right') }), preview.visible && (jsxRuntime.jsx(ImgVideoPreview$3, { open: preview.visible, onClose: () => {
                    if (isChoosingFile) {
                        isChoosingFile.current = false;
                    }
                    setPreview({ visible: false, index: 0 });
                }, imgVideoList: imgVideoList, activeIndex: preview.index }))] }));
});
Attachments.displayName = 'Attachments';

var __rest$i = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function FileUploader({ disabled = false }) {
    const { uploadDisabled = false } = React.useContext(StaticContext);
    const { getClickRootProps, getInputProps, file } = React.useContext(MessageContext);
    const { isChoosingFile } = file || {};
    const _a = (getClickRootProps === null || getClickRootProps === void 0 ? void 0 : getClickRootProps()) || {}, { onClick } = _a, rest = __rest$i(_a, ["onClick"]);
    const handleClick = (e) => {
        e.preventDefault();
        if (disabled) {
            return;
        }
        if (isChoosingFile && !disabled) {
            isChoosingFile.current = true;
        }
        if (onClick) {
            onClick(e);
        }
    };
    return (jsxRuntime.jsxs("div", Object.assign({ onClick: handleClick }, rest, { children: [jsxRuntime.jsx("input", Object.assign({ className: "invisible w-0 h-0" }, getInputProps === null || getInputProps === void 0 ? void 0 : getInputProps())), jsxRuntime.jsx(IconButton, { disabled: disabled || uploadDisabled, variant: "ghost", color: "brand", size: "md", icon: ForwardRef$o })] })));
}

function PaperAirplaneIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    d: "M3.478 2.404a.75.75 0 0 0-.926.941l2.432 7.905H13.5a.75.75 0 0 1 0 1.5H4.984l-2.432 7.905a.75.75 0 0 0 .926.94 60.519 60.519 0 0 0 18.445-8.986.75.75 0 0 0 0-1.218A60.517 60.517 0 0 0 3.478 2.404Z"
  }));
}
const ForwardRef$9 = /*#__PURE__*/ React__namespace.forwardRef(PaperAirplaneIcon);

function SendButton({ loading = false, disabled = false, onSend, energyCost, showEnergyCostIcon }) {
    return (jsxRuntime.jsxs(Button$1, { loading: loading, disabled: disabled, variant: "primary", size: "md", onClick: onSend, className: "w-fit rounded-lg shrink-0", children: [jsxRuntime.jsx(ForwardRef$9, { className: "w-4.5 h-4.5" }), showEnergyCostIcon && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("hr", { className: "h-3 border-l-[0.5px] mx-1.5 border-[#FFFFFF33]" }), jsxRuntime.jsxs("div", { className: "space-x-[2px] items-center flex", children: [jsxRuntime.jsx(Image__default.default, { src: getAssetsUrl('image/website/icon/20240826/energy.png'), alt: "energy", width: 14, height: 14, className: "size-[14px]" }), jsxRuntime.jsx("span", { className: "text-xs font-medium", children: energyCost !== null && energyCost !== void 0 ? energyCost : 1 })] })] }))] }));
}

var __rest$h = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const TextInput = React.forwardRef((_a, ref) => {
    var { value, disabled, disabledReason, sendDisabled, onChange, onSend, placeholder, style, className, rows, autoFocus } = _a, props = __rest$h(_a, ["value", "disabled", "disabledReason", "sendDisabled", "onChange", "onSend", "placeholder", "style", "className", "rows", "autoFocus"]);
    const { onPastedFiles } = React.useContext(MessageContext);
    const t = nextIntl.useTranslations('chat');
    const inputRef = React.useRef(null);
    const compositionFlag = React.useRef(false);
    const handleCompositionStart = () => {
        compositionFlag.current = true;
    };
    const handleCompositionEnd = () => {
        compositionFlag.current = false;
    };
    const handlePaste = (e) => {
        const { clipboardData } = e;
        const { items } = clipboardData !== null && clipboardData !== void 0 ? clipboardData : {};
        const files = Array.from(items !== null && items !== void 0 ? items : [])
            .filter(item => item.kind === 'file')
            .map(item => item.getAsFile())
            .filter(Boolean);
        onPastedFiles === null || onPastedFiles === void 0 ? void 0 : onPastedFiles(files);
    };
    React.useImperativeHandle(ref, () => ({
        focus: () => {
            var _a;
            (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        },
        blur: () => {
            var _a;
            (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.blur();
        }
    }));
    const handleInputChange = React.useCallback(e => {
        var _a;
        if (((_a = e === null || e === void 0 ? void 0 : e.nativeEvent) === null || _a === void 0 ? void 0 : _a.inputType) !== 'insertLineBreak') {
            onChange === null || onChange === void 0 ? void 0 : onChange(e);
        }
    }, [onChange]);
    const handleSelectionRange = (range) => {
        var _a;
        (_a = inputRef === null || inputRef === void 0 ? void 0 : inputRef.current) === null || _a === void 0 ? void 0 : _a.setSelectionRange(range, range);
    };
    const handleEnterPress = React.useCallback(e => {
        var _a;
        if (!((_a = e.target) === null || _a === void 0 ? void 0 : _a.value)) {
            return;
        }
        if (e.key === 'Enter') {
            if (e.shiftKey) {
                const { value: v, selectionStart, selectionEnd } = e.target;
                const prev = v.slice(0, selectionStart);
                const next = v.slice(selectionEnd);
                onChange === null || onChange === void 0 ? void 0 : onChange({
                    target: {
                        value: `${prev}\n${next}`
                    }
                });
                const newRange = selectionStart + 1;
                setTimeout(() => {
                    handleSelectionRange(newRange);
                });
            }
            else {
                e.preventDefault();
                if (compositionFlag.current)
                    return;
                if (sendDisabled)
                    return;
                onSend === null || onSend === void 0 ? void 0 : onSend(value);
            }
        }
    }, [onChange, onSend, sendDisabled, value]);
    reactUse.useEffectOnce(() => {
        handleSelectionRange(value.length);
    });
    return (jsxRuntime.jsx(Tooltip, { align: "start", sideOffset: 8, alignOffset: 8, variant: "info", showArrow: false, triggerClassName: "cursor-text", description: disabled && disabledReason ? disabledReason : '', disabled: !disabled, children: jsxRuntime.jsx(TextareaAutosize__default.default, Object.assign({ ref: inputRef, className: cn('flex w-full resize-none p-2 bg-surface-default text-sm text-default placeholder:text-subtlest focus-visible:outline-none disabled:cursor-not-allowed disabled:placeholder:text-disabled max-h-full overflow-auto', className), rows: rows || 1, disabled: disabled, value: value, onChange: handleInputChange, autoFocus: autoFocus !== null && autoFocus !== void 0 ? autoFocus : true, onKeyDown: handleEnterPress, placeholder: disabledReason || placeholder || t('placeholder'), onCompositionStart: handleCompositionStart, onCompositionEnd: handleCompositionEnd, onPaste: handlePaste }, props)) }));
});
TextInput.displayName = 'TextInput';

const useDetectKeyboardOpen = ({ minKeyboardHeight = 300, defaultValue = false, callback }) => {
    const [isKeyboardOpen, setIsKeyboardOpen] = React.useState(defaultValue);
    const cbRef = React.useRef(callback);
    const isKeyboardOpenRef = React.useRef(isKeyboardOpen);
    React.useEffect(() => {
        cbRef.current = callback;
    }, [callback]);
    React.useEffect(() => {
        const listener = () => {
            const visualHeight = window.visualViewport.height;
            const screenHeight = window.screen.height;
            const newState = screenHeight - minKeyboardHeight > visualHeight;
            if (isKeyboardOpenRef.current !== newState) {
                setIsKeyboardOpen(newState);
                isKeyboardOpenRef.current = newState;
                if (cbRef.current) {
                    cbRef.current(newState, screenHeight, visualHeight);
                }
            }
        };
        if (typeof visualViewport !== 'undefined') {
            window.visualViewport.addEventListener('resize', listener);
        }
        return () => {
            if (typeof visualViewport !== 'undefined') {
                window.visualViewport.removeEventListener('resize', listener);
            }
        };
    }, []);
    return isKeyboardOpen;
};

var __rest$g = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const avatarVariants = classVarianceAuthority.cva('relative flex shrink-0 overflow-hidden bg-surface-container-hovered', {
    variants: {
        size: {
            xs: 'w-5 h-5 rounded',
            sm: 'w-6 h-6 rounded-md',
            md: 'w-8 h-8 rounded-lg',
            lg: 'w-9 h-9 rounded-lg',
            xl: 'w-12 h-12 rounded-xl',
            '2xl': 'w-14 h-14 rounded-xl',
            '3xl': 'w-16 h-16 rounded-xl',
            '4xl': 'w-18 h-18 rounded-2xl',
            '5xl': 'w-21 h-21 rounded-2xl',
            '6xl': 'w-30 h-30 rounded-4xl'
        }
    },
    defaultVariants: {
        size: 'md'
    }
});
const AvatarRoot = React__namespace.forwardRef((_a, ref) => {
    var { className, size = 'md' } = _a, passProps = __rest$g(_a, ["className", "size"]);
    return (jsxRuntime.jsx(Primitive.span, Object.assign({ ref: ref, className: cn(avatarVariants({ size }), className) }, passProps)));
});
AvatarRoot.displayName = 'Avatar';
const AvatarImage = React__namespace.forwardRef((_a, ref) => {
    var { className, onLoad, onError } = _a, props = __rest$g(_a, ["className", "onLoad", "onError"]);
    const [loadingStatus, setLoadingStatus] = React__namespace.useState('loading');
    const handleLoad = (event) => {
        setLoadingStatus('loaded');
        if (onLoad) {
            onLoad(event);
        }
    };
    const handleError = (event) => {
        setLoadingStatus('error');
        if (onError) {
            onError(event);
        }
    };
    return (loadingStatus !== 'error' ? (jsxRuntime.jsx(Primitive.img, Object.assign({ ref: ref, className: cn('aspect-square h-full w-full object-cover', className), onLoad: handleLoad, onError: handleError }, props))) : (jsxRuntime.jsx(Primitive.span, Object.assign({ ref: ref, className: cn('flex h-full w-full items-center justify-center bg-surface-container-pressed', className) }, props))));
});
AvatarImage.displayName = 'AvatarImage';
const Avatar = React__namespace.forwardRef((_a, ref) => {
    var { className, rootStyle, size, src, variant = 'bot' } = _a, passProps = __rest$g(_a, ["className", "rootStyle", "size", "src", "variant"]);
    const defaultSrc = variant === 'user'
        ? 'https://www.myshellstatic.com/cdn-cgi/image/quality=40,format=webp/image/user/avatar/default/20240715/avatar.png'
        : 'https://www.myshellstatic.com/cdn-cgi/image/quality=40,format=webp/image/bot/logo/20240106/default.png';
    return (jsxRuntime.jsx(AvatarRoot, { size: size, className: className, style: rootStyle, children: jsxRuntime.jsx(AvatarImage, Object.assign({ ref: ref }, passProps, { src: src || defaultSrc })) }));
});
Avatar.displayName = 'Avatar';

function MobileEntityInfo({ showMobileDetail }) {
    const { entityInfo } = React.useContext(StaticContext);
    const { name, logoUrl } = entityInfo;
    return (jsxRuntime.jsxs("div", { className: "flex items-center gap-[6px]", onClick: () => showMobileDetail === null || showMobileDetail === void 0 ? void 0 : showMobileDetail(), children: [jsxRuntime.jsx(Avatar, { src: logoUrl, size: "md", className: "shrink-0" }), jsxRuntime.jsxs("div", { className: "flex gap-1 items-center", children: [jsxRuntime.jsx("span", { className: "line-clamp-1 break-all", children: name }), jsxRuntime.jsx(ForwardRef$G, { className: "size-[18px] text-brand" })] })] }));
}

var __rest$f = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const MobileTextInput = React.forwardRef((_a, ref) => {
    var { value, disabled, disabledReason, sendDisabled, onChange, onSend, placeholder, style, className, rows, autoFocus, showMobileDetail, audioInputSlot, loading, interactingDisabled, energyCost, showEnergyCostIcon } = _a, props = __rest$f(_a, ["value", "disabled", "disabledReason", "sendDisabled", "onChange", "onSend", "placeholder", "style", "className", "rows", "autoFocus", "showMobileDetail", "audioInputSlot", "loading", "interactingDisabled", "energyCost", "showEnergyCostIcon"]);
    const { uploadDisabled } = React.useContext(StaticContext);
    const { file, onPastedFiles } = React.useContext(MessageContext);
    const { uploadedFiles, isChoosingFile } = file || {};
    const t = nextIntl.useTranslations('chat');
    const inputRef = React.useRef(null);
    const containerRef = React.useRef(null);
    const compositionFlag = React.useRef(false);
    const pl = (value || '').trim().split('\n')[0].slice(0, 100);
    const [mode, setMode] = React.useState('display');
    reactUse.useClickAway(containerRef, () => {
        if (!(isChoosingFile === null || isChoosingFile === void 0 ? void 0 : isChoosingFile.current)) {
            setMode('display');
        }
    });
    const handleCompositionStart = () => {
        compositionFlag.current = true;
    };
    const handleCompositionEnd = () => {
        compositionFlag.current = false;
    };
    const handlePaste = (e) => {
        const { clipboardData } = e;
        const { items } = clipboardData !== null && clipboardData !== void 0 ? clipboardData : {};
        const files = Array.from(items !== null && items !== void 0 ? items : [])
            .filter(item => item.kind === 'file')
            .map(item => item.getAsFile())
            .filter(Boolean);
        onPastedFiles === null || onPastedFiles === void 0 ? void 0 : onPastedFiles(files);
    };
    useDetectKeyboardOpen({
        callback: (open) => {
            if (!open && !(isChoosingFile === null || isChoosingFile === void 0 ? void 0 : isChoosingFile.current)) {
                setMode('display');
            }
        }
    });
    const handleSelectionRange = (range) => {
        var _a;
        (_a = inputRef === null || inputRef === void 0 ? void 0 : inputRef.current) === null || _a === void 0 ? void 0 : _a.setSelectionRange(range, range);
    };
    const handleFocus = (e) => {
        const { value: textValue } = e.target;
        const valueLen = textValue.length;
        setTimeout(() => {
            handleSelectionRange(valueLen);
        });
    };
    React.useImperativeHandle(ref, () => ({
        focus: () => {
            var _a;
            (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        },
        blur: () => {
            var _a;
            (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.blur();
        }
    }));
    const handleInputChange = React.useCallback(e => {
        var _a;
        if (((_a = e === null || e === void 0 ? void 0 : e.nativeEvent) === null || _a === void 0 ? void 0 : _a.inputType) !== 'insertLineBreak') {
            onChange === null || onChange === void 0 ? void 0 : onChange(e);
        }
    }, [onChange]);
    const handleEnterPress = React.useCallback(e => {
        var _a;
        if (!((_a = e.target) === null || _a === void 0 ? void 0 : _a.value)) {
            return;
        }
        if (e.key === 'Enter') {
            const { value: v, selectionStart, selectionEnd } = e.target;
            const prev = v.slice(0, selectionStart);
            const next = v.slice(selectionEnd);
            onChange === null || onChange === void 0 ? void 0 : onChange({
                target: {
                    value: `${prev}\n${next}`
                }
            });
            const newRange = selectionStart + 1;
            setTimeout(() => {
                handleSelectionRange(newRange);
            });
        }
    }, [onChange]);
    const handleButtonClick = () => {
        onSend === null || onSend === void 0 ? void 0 : onSend(value);
        setMode('display');
    };
    return mode === 'display' ? (jsxRuntime.jsxs("div", { className: "px-4 flex flex-col gap-2", children: [jsxRuntime.jsx(Tooltip, { side: "top", align: "start", sideOffset: 8, alignOffset: 8, variant: "info", showArrow: false, description: (disabled && disabledReason) || '', triggerClassName: "w-full", children: disabled ? (jsxRuntime.jsxs("div", { className: "p-2 w-full h-10 overflow-hidden border border-default rounded-lg shadow-textarea flex items-center gap-2", children: [jsxRuntime.jsx("p", { className: clsx__default.default('grow truncate h-6 text-sm leading-6 text-start', pl.length ? 'text-default' : 'text-subtlest'), children: pl || disabledReason || placeholder || t('placeholder') }), jsxRuntime.jsx(IconButton, { icon: (uploadedFiles === null || uploadedFiles === void 0 ? void 0 : uploadedFiles.length) ? ForwardRef$s : ForwardRef$o, variant: "ghost", size: "md", className: "shrink-0", disabled: disabled || uploadDisabled })] })) : (jsxRuntime.jsxs("div", { className: "p-2 w-full h-10 overflow-hidden border border-default rounded-lg shadow-textarea flex items-center gap-2", onClick: () => setMode('input'), children: [jsxRuntime.jsx("p", { className: clsx__default.default('grow truncate h-6 text-sm leading-6 text-start', pl.length ? 'text-default' : 'text-subtlest'), children: pl || disabledReason || placeholder || t('placeholder') }), jsxRuntime.jsx(IconButton, { icon: (uploadedFiles === null || uploadedFiles === void 0 ? void 0 : uploadedFiles.length) ? ForwardRef$s : ForwardRef$o, variant: "ghost", size: "md", className: "shrink-0", disabled: disabled || uploadDisabled })] })) }), jsxRuntime.jsxs("div", { className: "w-full flex justify-between items-center", children: [jsxRuntime.jsx("div", { className: "shrink-0", children: jsxRuntime.jsx(MobileEntityInfo, { showMobileDetail: showMobileDetail }) }), audioInputSlot] })] })) : (jsxRuntime.jsxs("div", { className: "w-full bg-surface-default flex flex-col gap-2", ref: containerRef, children: [jsxRuntime.jsx(Separator, { className: "w-full bg-[var(--border)]" }), jsxRuntime.jsx("div", { className: "px-4", children: jsxRuntime.jsx(TextareaAutosize__default.default, Object.assign({ ref: inputRef, className: "flex w-full resize-none bg-surface-default text-sm leading-6 placeholder:text-subtlest focus-visible:outline-none disabled:cursor-not-allowed disabled:placeholder:text-disabled h-fit max-h-[144px] focus:overflow-auto", rows: rows || 1, disabled: disabled, value: value, onCompositionStart: handleCompositionStart, onCompositionEnd: handleCompositionEnd, onPaste: handlePaste, onChange: handleInputChange, onFocus: handleFocus, onKeyDown: handleEnterPress, autoFocus: autoFocus !== null && autoFocus !== void 0 ? autoFocus : true, placeholder: disabledReason || placeholder || t('placeholder') }, props)) }), jsxRuntime.jsx(Attachments, {}), jsxRuntime.jsxs("div", { className: "w-full flex justify-between items-center pl-2 pr-4", children: [jsxRuntime.jsx("div", { className: "shrink-0", children: jsxRuntime.jsx(FileUploader, { disabled: disabled }) }), jsxRuntime.jsx(SendButton, { loading: loading, disabled: interactingDisabled || sendDisabled, onSend: handleButtonClick, energyCost: energyCost, showEnergyCostIcon: showEnergyCostIcon && !!value })] })] }));
});
MobileTextInput.displayName = 'MobileTextInput';

function SaveTipModal$1({ maxSize }) {
    const { file } = React.useContext(MessageContext);
    const { isChoosingFile } = file || {};
    nextIntl.useTranslations('common');
    const chatT = nextIntl.useTranslations('chat');
    const fileAlert = useNewChatStore(state => state.fileUpload.alert);
    const setFileAlert = useNewChatStore(state => state.setFileAlert);
    const hasSupport = fileAlert.data[0].length > 0;
    const hasTooLarge = fileAlert.data[1].length > 0;
    const total = hasSupport && hasTooLarge ? 2 : 1;
    const [index, setIndex] = React.useState(total === 1 && hasTooLarge ? 1 : 0);
    const handleClose = () => {
        setFileAlert({ visible: false, data: [] });
        if (isChoosingFile) {
            isChoosingFile.current = false;
        }
        if (total === 2 && index === 0) {
            setIndex(1);
        }
    };
    const current = index === 0 ? fileAlert.data[0] : fileAlert.data[1];
    reactUse.useEffectOnce(() => {
        if (isChoosingFile) {
            isChoosingFile.current = true;
        }
    });
    return (jsxRuntime.jsx(Modal, { open: true, onClose: handleClose, hideClose: true, isNotification: true, state: "warning", size: "sm", overlayClassName: "z-[100]", contentClassName: "z-[110] p-0", title: index === 0 ? chatT('panel.unsupported') : chatT('panel.maxsize'), onConfirm: handleClose, showCancel: false, children: jsxRuntime.jsxs("div", { className: "w-full rounded-4xl px-4", children: [index === 0 && (jsxRuntime.jsx(Text, { size: "sm", color: "subtle", children: chatT('panel.unsupported_tip') })), index === 0 && (jsxRuntime.jsx("ul", { className: "list-disc list-inside", children: current.map((item) => {
                        return (jsxRuntime.jsx("li", { className: "list-item line-clamp-2 break-all", children: jsxRuntime.jsx(Text, { size: "sm", className: "-ml-3", children: item.name }) }, item.name));
                    }) })), index === 1 && (jsxRuntime.jsx("span", { children: chatT('panel.maxsize_tip', {
                        maxSize: maxSize || 50
                    }) }))] }) }));
}

function QuestionItem({ question, handlePickQuestion, isMobile = false, disableClick = false }) {
    const energy = useUserStore(state => state.energy);
    const { entityInfo } = React.useContext(StaticContext);
    const { energyPerChat } = entityInfo;
    const hasEnoughEnergy = (energy !== null && energy !== void 0 ? energy : 0) >= (energyPerChat !== null && energyPerChat !== void 0 ? energyPerChat : 1);
    return (jsxRuntime.jsxs("div", { className: clsx__default.default('py-2 px-4 max-h-[76px] h-full border border-[#E4E9F0] dark:border-[#42434A] rounded-xl text-[#414345] dark:text-[#B8BCCF] bg-white hover:bg-[#F6F6F7] dark:bg-[#1C1E26] dark:hover:bg-[#232533] text-sm flex space-x-[6px] items-center shadow-button-basic shrink-0', hasEnoughEnergy && !disableClick ? 'cursor-pointer' : 'cursor-not-allowed opacity-50', isMobile ? 'w-full' : ' w-[320px]'), onClick: () => {
            if (!hasEnoughEnergy || disableClick)
                return;
            handlePickQuestion(question);
        }, children: [jsxRuntime.jsx("div", { className: "grow line-clamp-3", children: question }), jsxRuntime.jsx(ForwardRef$P, { className: "w-5 h-5 text-[#6D7175] dark-[#868996] shrink-0" })] }));
}
var QuestionItem$1 = React.memo(QuestionItem);

const container$1 = {
    hidden: { opacity: 0, y: 100 },
    visible: {
        opacity: 1,
        y: 0,
        transition: {
            delayChildren: 0.1,
            staggerChildren: 0.1
        }
    },
    exit: {
        opacity: 0,
        y: 100,
        transition: {
            duration: 0.1,
            ease: 'easeInOut'
        }
    }
};
const listContainer = {
    hidden: { opacity: 0 },
    visible: {
        opacity: 1,
        transition: {
            delayChildren: 0.1,
            staggerChildren: 0.1
        }
    }
};
function Questions({ questions, handlePick, disableClick = false }) {
    const hoverRef = React.useRef(null);
    const isHover = usehooksTs.useHover(hoverRef);
    const scrollRef = React.useRef(null);
    const [isAtLeft, setIsAtLeft] = React.useState(true);
    const [isAtRight, setIsAtRight] = React.useState(false);
    const scrollLeft = () => {
        var _a;
        (_a = scrollRef.current) === null || _a === void 0 ? void 0 : _a.scrollBy({
            top: 0,
            left: -320,
            behavior: 'smooth'
        });
    };
    const scrollRight = () => {
        var _a;
        (_a = scrollRef.current) === null || _a === void 0 ? void 0 : _a.scrollBy({
            top: 0,
            left: 320,
            behavior: 'smooth'
        });
    };
    React.useEffect(() => {
        const ref = scrollRef.current;
        const handleScroll = () => {
            if (ref) {
                const { scrollLeft, clientWidth, scrollWidth } = ref;
                setIsAtLeft(scrollLeft === 0);
                setIsAtRight(Math.ceil(scrollLeft + clientWidth) === scrollWidth);
            }
        };
        if (ref) {
            ref.addEventListener('scroll', handleScroll);
        }
        return () => {
            if (ref) {
                ref.removeEventListener('scroll', handleScroll);
            }
        };
    }, []);
    return (jsxRuntime.jsxs(framerMotion.motion.div, { ref: hoverRef, className: "w-full overflow-hidden relative py-2 px-6 shrink-0", variants: container$1, initial: "hidden", animate: "visible", exit: "exit", children: [!isAtLeft && (jsxRuntime.jsx("div", { className: "w-20 absolute left-0 top-2 bg-gradient-to-l from-[#FFFFFF73] dark:from-[#17181C00] to-[#FFFFFF] dark:to-[#17181C] z-10", style: {
                    height: 'calc(100% - 16px)'
                } })), isHover && !isAtLeft && (jsxRuntime.jsx("div", { className: "h-full flex items-center absolute left-3 top-0 z-20", children: jsxRuntime.jsx(IconButton, { size: "md", variant: "outline", color: "default", icon: ForwardRef$I, onClick: scrollLeft }) })), jsxRuntime.jsx(framerMotion.motion.ul, { ref: scrollRef, className: "flex h-full space-x-3 w-full overflow-y-hidden overflow-x-auto no-scrollbar", variants: listContainer, initial: "hidden", animate: "visible", children: questions.map(r => (jsxRuntime.jsx(framerMotion.motion.li, { children: jsxRuntime.jsx(QuestionItem$1, { question: r, handlePickQuestion: handlePick, disableClick: disableClick }) }, r))) }, "questions-container"), !isAtRight && (jsxRuntime.jsx("div", { className: "w-20 absolute right-0 top-2 bg-gradient-to-r from-[#FFFFFF73] dark:from-[#17181C00] to-[#FFFFFF] dark:to-[#17181C] z-10", style: {
                    height: 'calc(100% - 16px)'
                } })), isHover && !isAtRight && (jsxRuntime.jsx("div", { className: "h-full flex items-center absolute right-3 top-0 z-20", children: jsxRuntime.jsx(IconButton, { size: "md", variant: "outline", color: "default", icon: ForwardRef$H, onClick: scrollRight }) }))] }, "questions-wrapper"));
}

/**
 * SSR Window 4.0.2
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: December 13, 2021
 */
/* eslint-disable no-param-reassign */
function isObject$3(obj) {
  return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
}
function extend$2(target, src) {
  if (target === void 0) {
    target = {};
  }
  if (src === void 0) {
    src = {};
  }
  Object.keys(src).forEach(key => {
    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$3(src[key]) && isObject$3(target[key]) && Object.keys(src[key]).length > 0) {
      extend$2(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {},
  removeEventListener() {},
  activeElement: {
    blur() {},
    nodeName: ''
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {}
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {},
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  }
};
function getDocument() {
  const doc = typeof document !== 'undefined' ? document : {};
  extend$2(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ''
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  },
  history: {
    replaceState() {},
    pushState() {},
    go() {},
    back() {}
  },
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener() {},
  removeEventListener() {},
  getComputedStyle() {
    return {
      getPropertyValue() {
        return '';
      }
    };
  },
  Image() {},
  Date() {},
  screen: {},
  setTimeout() {},
  clearTimeout() {},
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === 'undefined') {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id) {
    if (typeof setTimeout === 'undefined') {
      return;
    }
    clearTimeout(id);
  }
};
function getWindow() {
  const win = typeof window !== 'undefined' ? window : {};
  extend$2(win, ssrWindow);
  return win;
}

function classesToTokens(classes) {
  if (classes === void 0) {
    classes = '';
  }
  return classes.trim().split(' ').filter(c => !!c.trim());
}

function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach(key => {
    try {
      object[key] = null;
    } catch (e) {
      // no getter for object
    }
    try {
      delete object[key];
    } catch (e) {
      // something got wrong
    }
  });
}
function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function now$1() {
  return Date.now();
}
function getComputedStyle$1(el) {
  const window = getWindow();
  let style;
  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = 'x';
  }
  const window = getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle$1(el);
  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
    }
    // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case
    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }
  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[4]);
  }
  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject$2(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}
function isNode(node) {
  // eslint-disable-next-line
  if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
    return node instanceof HTMLElement;
  }
  return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend$1() {
  const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
  const noExtend = ['__proto__', 'constructor', 'prototype'];
  for (let i = 1; i < arguments.length; i += 1) {
    const nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
    if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) {
          if (isObject$2(to[nextKey]) && isObject$2(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend$1(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject$2(to[nextKey]) && isObject$2(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend$1(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function setCSSProperty(el, varName, varValue) {
  el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll(_ref) {
  let {
    swiper,
    targetPosition,
    side
  } = _ref;
  const window = getWindow();
  const startPosition = -swiper.translate;
  let startTime = null;
  let time;
  const duration = swiper.params.speed;
  swiper.wrapperEl.style.scrollSnapType = 'none';
  window.cancelAnimationFrame(swiper.cssModeFrameID);
  const dir = targetPosition > startPosition ? 'next' : 'prev';
  const isOutOfBound = (current, target) => {
    return dir === 'next' && current >= target || dir === 'prev' && current <= target;
  };
  const animate = () => {
    time = new Date().getTime();
    if (startTime === null) {
      startTime = time;
    }
    const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper.wrapperEl.style.overflow = 'hidden';
      swiper.wrapperEl.style.scrollSnapType = '';
      setTimeout(() => {
        swiper.wrapperEl.style.overflow = '';
        swiper.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window.cancelAnimationFrame(swiper.cssModeFrameID);
      return;
    }
    swiper.cssModeFrameID = window.requestAnimationFrame(animate);
  };
  animate();
}
function elementChildren(element, selector) {
  if (selector === void 0) {
    selector = '';
  }
  const children = [...element.children];
  if (element instanceof HTMLSlotElement) {
    children.push(...element.assignedElements());
  }
  if (!selector) {
    return children;
  }
  return children.filter(el => el.matches(selector));
}
function elementIsChildOf(el, parent) {
  const isChild = parent.contains(el);
  if (!isChild && parent instanceof HTMLSlotElement) {
    const children = [...parent.assignedElements()];
    return children.includes(el);
  }
  return isChild;
}
function showWarning(text) {
  try {
    console.warn(text);
    return;
  } catch (err) {
    // err
  }
}
function createElement(tag, classes) {
  if (classes === void 0) {
    classes = [];
  }
  const el = document.createElement(tag);
  el.classList.add(...(Array.isArray(classes) ? classes : classesToTokens(classes)));
  return el;
}
function elementPrevAll(el, selector) {
  const prevEls = [];
  while (el.previousElementSibling) {
    const prev = el.previousElementSibling; // eslint-disable-line
    if (selector) {
      if (prev.matches(selector)) prevEls.push(prev);
    } else prevEls.push(prev);
    el = prev;
  }
  return prevEls;
}
function elementNextAll(el, selector) {
  const nextEls = [];
  while (el.nextElementSibling) {
    const next = el.nextElementSibling; // eslint-disable-line
    if (selector) {
      if (next.matches(selector)) nextEls.push(next);
    } else nextEls.push(next);
    el = next;
  }
  return nextEls;
}
function elementStyle(el, prop) {
  const window = getWindow();
  return window.getComputedStyle(el, null).getPropertyValue(prop);
}
function elementIndex(el) {
  let child = el;
  let i;
  if (child) {
    i = 0;
    // eslint-disable-next-line
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
function elementParents(el, selector) {
  const parents = []; // eslint-disable-line
  let parent = el.parentElement; // eslint-disable-line
  while (parent) {
    {
      parents.push(parent);
    }
    parent = parent.parentElement;
  }
  return parents;
}
function elementOuterSize(el, size, includeMargins) {
  const window = getWindow();
  {
    return el[size === 'width' ? 'offsetWidth' : 'offsetHeight'] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-right' : 'margin-top')) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === 'width' ? 'margin-left' : 'margin-bottom'));
  }
}

let support;
function calcSupport() {
  const window = getWindow();
  const document = getDocument();
  return {
    smoothScroll: document.documentElement && document.documentElement.style && 'scrollBehavior' in document.documentElement.style,
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch)
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}

let deviceCached;
function calcDevice(_temp) {
  let {
    userAgent
  } = _temp === void 0 ? {} : _temp;
  const support = getSupport();
  const window = getWindow();
  const platform = window.navigator.platform;
  const ua = userAgent || window.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window.screen.width;
  const screenHeight = window.screen.height;
  const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform === 'Win32';
  let macos = platform === 'MacIntel';

  // iPadOs 13 fix
  const iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
  if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  }

  // Android
  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }

  // Export object
  return device;
}
function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}

let browser;
function calcBrowser() {
  const window = getWindow();
  const device = getDevice();
  let needPerspectiveFix = false;
  function isSafari() {
    const ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }
  if (isSafari()) {
    const ua = String(window.navigator.userAgent);
    if (ua.includes('Version/')) {
      const [major, minor] = ua.split('Version/')[1].split(' ')[0].split('.').map(num => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  const isWebView = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent);
  const isSafariBrowser = isSafari();
  const need3dFix = isSafariBrowser || isWebView && device.ios;
  return {
    isSafari: needPerspectiveFix || isSafariBrowser,
    needPerspectiveFix,
    need3dFix,
    isWebView
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}

function Resize(_ref) {
  let {
    swiper,
    on,
    emit
  } = _ref;
  const window = getWindow();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('beforeResize');
    emit('resize');
  };
  const createObserver = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    observer = new ResizeObserver(entries => {
      animationFrame = window.requestAnimationFrame(() => {
        const {
          width,
          height
        } = swiper;
        let newWidth = width;
        let newHeight = height;
        entries.forEach(_ref2 => {
          let {
            contentBoxSize,
            contentRect,
            target
          } = _ref2;
          if (target && target !== swiper.el) return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width || newHeight !== height) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper.el) {
      observer.unobserve(swiper.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper || swiper.destroyed || !swiper.initialized) return;
    emit('orientationchange');
  };
  on('init', () => {
    if (swiper.params.resizeObserver && typeof window.ResizeObserver !== 'undefined') {
      createObserver();
      return;
    }
    window.addEventListener('resize', resizeHandler);
    window.addEventListener('orientationchange', orientationChangeHandler);
  });
  on('destroy', () => {
    removeObserver();
    window.removeEventListener('resize', resizeHandler);
    window.removeEventListener('orientationchange', orientationChangeHandler);
  });
}

function Observer(_ref) {
  let {
    swiper,
    extendParams,
    on,
    emit
  } = _ref;
  const observers = [];
  const window = getWindow();
  const attach = function (target, options) {
    if (options === void 0) {
      options = {};
    }
    const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    const observer = new ObserverFunc(mutations => {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (swiper.__preventObserver__) return;
      if (mutations.length === 1) {
        emit('observerUpdate', mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate() {
        emit('observerUpdate', mutations[0]);
      };
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: swiper.isElement || (typeof options.childList === 'undefined' ? true : options).childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    observers.push(observer);
  };
  const init = () => {
    if (!swiper.params.observer) return;
    if (swiper.params.observeParents) {
      const containerParents = elementParents(swiper.hostEl);
      for (let i = 0; i < containerParents.length; i += 1) {
        attach(containerParents[i]);
      }
    }
    // Observe container
    attach(swiper.hostEl, {
      childList: swiper.params.observeSlideChildren
    });

    // Observe wrapper
    attach(swiper.wrapperEl, {
      attributes: false
    });
  };
  const destroy = () => {
    observers.forEach(observer => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on('init', init);
  on('destroy', destroy);
}

/* eslint-disable no-underscore-dangle */

var eventsEmitter = {
  on(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(event => {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },
  once(events, handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    function onceHandler() {
      self.off(events, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self, args);
    }
    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (typeof handler !== 'function') return self;
    const method = priority ? 'unshift' : 'push';
    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }
    return self;
  },
  offAny(handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsAnyListeners) return self;
    const index = self.eventsAnyListeners.indexOf(handler);
    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }
    return self;
  },
  off(events, handler) {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(event => {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },
  emit() {
    const self = this;
    if (!self.eventsListeners || self.destroyed) return self;
    if (!self.eventsListeners) return self;
    let events;
    let data;
    let context;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    data.unshift(context);
    const eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(event => {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(eventHandler => {
          eventHandler.apply(context, [event, ...data]);
        });
      }
      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(eventHandler => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
};

function updateSize() {
  const swiper = this;
  let width;
  let height;
  const el = swiper.el;
  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = el.clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = el.clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }

  // Subtract paddings
  width = width - parseInt(elementStyle(el, 'padding-left') || 0, 10) - parseInt(elementStyle(el, 'padding-right') || 0, 10);
  height = height - parseInt(elementStyle(el, 'padding-top') || 0, 10) - parseInt(elementStyle(el, 'padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  Object.assign(swiper, {
    width,
    height,
    size: swiper.isHorizontal() ? width : height
  });
}

function updateSlides() {
  const swiper = this;
  function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
  }
  const params = swiper.params;
  const {
    wrapperEl,
    slidesEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
  const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  const previousSnapGridLength = swiper.snapGrid.length;
  const previousSlidesGridLength = swiper.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  swiper.virtualSize = -spaceBetween;

  // reset margins
  slides.forEach(slideEl => {
    if (rtl) {
      slideEl.style.marginLeft = '';
    } else {
      slideEl.style.marginRight = '';
    }
    slideEl.style.marginBottom = '';
    slideEl.style.marginTop = '';
  });

  // reset cssMode offsets
  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', '');
    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', '');
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
  if (gridEnabled) {
    swiper.grid.initSlides(slides);
  } else if (swiper.grid) {
    swiper.grid.unsetSlides();
  }

  // Calc slides
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === 'auto' && params.breakpoints && Object.keys(params.breakpoints).filter(key => {
    return typeof params.breakpoints[key].slidesPerView !== 'undefined';
  }).length > 0;
  for (let i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    let slide;
    if (slides[i]) slide = slides[i];
    if (gridEnabled) {
      swiper.grid.updateSlide(i, slide, slides);
    }
    if (slides[i] && elementStyle(slide, 'display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      if (shouldResetSlideSize) {
        slides[i].style[swiper.getDirectionLabel('width')] = ``;
      }
      const slideStyles = getComputedStyle(slide);
      const currentTransform = slide.style.transform;
      const currentWebKitTransform = slide.style.webkitTransform;
      if (currentTransform) {
        slide.style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide.style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? elementOuterSize(slide, 'width') : elementOuterSize(slide, 'height');
      } else {
        // eslint-disable-next-line
        const width = getDirectionPropertyValue(slideStyles, 'width');
        const paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        const paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        const marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        const marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        const boxSizing = slideStyles.getPropertyValue('box-sizing');
        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide.style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide.style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[swiper.getDirectionLabel('width')] = `${slideSize}px`;
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (params.setWrapperSize) {
    wrapperEl.style[swiper.getDirectionLabel('width')] = `${swiper.virtualSize + spaceBetween}px`;
  }
  if (gridEnabled) {
    swiper.grid.updateWrapperSize(slideSize, snapGrid);
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i = 0; i < snapGrid.length; i += 1) {
      let slidesGridItem = snapGrid[i];
      if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (isVirtual && params.loop) {
    const size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
      const groupSize = size * params.slidesPerGroup;
      for (let i = 0; i < groups; i += 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
      }
    }
    for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
      if (params.slidesPerGroup === 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
      }
      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
      swiper.virtualSize += size;
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];
  if (spaceBetween !== 0) {
    const key = swiper.isHorizontal() && rtl ? 'marginLeft' : swiper.getDirectionLabel('marginRight');
    slides.filter((_, slideIndex) => {
      if (!params.cssMode || params.loop) return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).forEach(slideEl => {
      slideEl.style[key] = `${spaceBetween}px`;
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map(snap => {
      if (snap <= 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach(slideSizeValue => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
    if (allSlidesSize + offsetSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(wrapperEl, '--swiper-centered-offset-before', `${-snapGrid[0]}px`);
    setCSSProperty(wrapperEl, '--swiper-centered-offset-after', `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper.snapGrid[0];
    const addToSlidesGrid = -swiper.slidesGrid[0];
    swiper.snapGrid = swiper.snapGrid.map(v => v + addToSnapGrid);
    swiper.slidesGrid = swiper.slidesGrid.map(v => v + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  swiper.emit('slidesUpdated');
  if (!isVirtual && !params.cssMode && (params.effect === 'slide' || params.effect === 'fade')) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper.el.classList.remove(backFaceHiddenClass);
    }
  }
}

function updateAutoHeight(speed) {
  const swiper = this;
  const activeSlides = [];
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
  let newHeight = 0;
  let i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  const getSlideByIndex = index => {
    if (isVirtual) {
      return swiper.slides[swiper.getSlideIndexByData(index)];
    }
    return swiper.slides[index];
  };
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      (swiper.visibleSlides || []).forEach(slide => {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        const index = swiper.activeIndex + i;
        if (index > swiper.slides.length && !isVirtual) break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper.activeIndex));
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      const height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
}

function updateSlidesOffset() {
  const swiper = this;
  const slides = swiper.slides;
  // eslint-disable-next-line
  const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
  for (let i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
  }
}

const toggleSlideClasses$1 = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesProgress(translate) {
  if (translate === void 0) {
    translate = this && this.translate || 0;
  }
  const swiper = this;
  const params = swiper.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  let offsetCenter = -translate;
  if (rtl) offsetCenter = translate;
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  let spaceBetween = params.spaceBetween;
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiper.size;
  } else if (typeof spaceBetween === 'string') {
    spaceBetween = parseFloat(spaceBetween);
  }
  for (let i = 0; i < slides.length; i += 1) {
    const slide = slides[i];
    let slideOffset = slide.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
    const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i];
    const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
    if (isVisible) {
      swiper.visibleSlides.push(slide);
      swiper.visibleSlidesIndexes.push(i);
    }
    toggleSlideClasses$1(slide, isVisible, params.slideVisibleClass);
    toggleSlideClasses$1(slide, isFullyVisible, params.slideFullyVisibleClass);
    slide.progress = rtl ? -slideProgress : slideProgress;
    slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}

function updateProgress(translate) {
  const swiper = this;
  if (typeof translate === 'undefined') {
    const multiplier = swiper.rtlTranslate ? -1 : 1;
    // eslint-disable-next-line
    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  const params = swiper.params;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd,
    progressLoop
  } = swiper;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
    const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress <= 0;
    isEnd = isEndRounded || progress >= 1;
    if (isBeginningRounded) progress = 0;
    if (isEndRounded) progress = 1;
  }
  if (params.loop) {
    const firstSlideIndex = swiper.getSlideIndexByData(0);
    const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
    const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
    const translateAbs = Math.abs(translate);
    if (translateAbs >= firstSlideTranslate) {
      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
    } else {
      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
    }
    if (progressLoop > 1) progressLoop -= 1;
  }
  Object.assign(swiper, {
    progress,
    progressLoop,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }
  swiper.emit('progress', progress);
}

const toggleSlideClasses = (slideEl, condition, className) => {
  if (condition && !slideEl.classList.contains(className)) {
    slideEl.classList.add(className);
  } else if (!condition && slideEl.classList.contains(className)) {
    slideEl.classList.remove(className);
  }
};
function updateSlidesClasses() {
  const swiper = this;
  const {
    slides,
    params,
    slidesEl,
    activeIndex
  } = swiper;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const getFilteredSlide = selector => {
    return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
  };
  let activeSlide;
  let prevSlide;
  let nextSlide;
  if (isVirtual) {
    if (params.loop) {
      let slideIndex = activeIndex - swiper.virtual.slidesBefore;
      if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
      if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else {
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
    }
  } else {
    if (gridEnabled) {
      activeSlide = slides.filter(slideEl => slideEl.column === activeIndex)[0];
      nextSlide = slides.filter(slideEl => slideEl.column === activeIndex + 1)[0];
      prevSlide = slides.filter(slideEl => slideEl.column === activeIndex - 1)[0];
    } else {
      activeSlide = slides[activeIndex];
    }
  }
  if (activeSlide) {
    if (!gridEnabled) {
      // Next Slide
      nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !nextSlide) {
        nextSlide = slides[0];
      }

      // Prev Slide
      prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
      if (params.loop && !prevSlide === 0) {
        prevSlide = slides[slides.length - 1];
      }
    }
  }
  slides.forEach(slideEl => {
    toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
    toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
    toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
  });
  swiper.emitSlidesClasses();
}

const processLazyPreloader = (swiper, imageEl) => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
  const slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
    if (!lazyEl && swiper.isElement) {
      if (slideEl.shadowRoot) {
        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
      } else {
        // init later
        requestAnimationFrame(() => {
          if (slideEl.shadowRoot) {
            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
            if (lazyEl) lazyEl.remove();
          }
        });
      }
    }
    if (lazyEl) lazyEl.remove();
  }
};
const unlazy = (swiper, index) => {
  if (!swiper.slides[index]) return;
  const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
  if (imageEl) imageEl.removeAttribute('loading');
};
const preload = swiper => {
  if (!swiper || swiper.destroyed || !swiper.params) return;
  let amount = swiper.params.lazyPreloadPrevNext;
  const len = swiper.slides.length;
  if (!len || !amount || amount < 0) return;
  amount = Math.min(amount, len);
  const slidesPerView = swiper.params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
  const activeIndex = swiper.activeIndex;
  if (swiper.params.grid && swiper.params.grid.rows > 1) {
    const activeColumn = activeIndex;
    const preloadColumns = [activeColumn - amount];
    preloadColumns.push(...Array.from({
      length: amount
    }).map((_, i) => {
      return activeColumn + slidesPerView + i;
    }));
    swiper.slides.forEach((slideEl, i) => {
      if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
    });
    return;
  }
  const slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper.params.rewind || swiper.params.loop) {
    for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
      const realIndex = (i % len + len) % len;
      if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
    }
  } else {
    for (let i = Math.max(activeIndex - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) {
      if (i !== activeIndex && (i > slideIndexLastInView || i < activeIndex)) {
        unlazy(swiper, i);
      }
    }
  }
};

function getActiveIndexByTranslate(swiper) {
  const {
    slidesGrid,
    params
  } = swiper;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  let activeIndex;
  for (let i = 0; i < slidesGrid.length; i += 1) {
    if (typeof slidesGrid[i + 1] !== 'undefined') {
      if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
        activeIndex = i;
      } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
        activeIndex = i + 1;
      }
    } else if (translate >= slidesGrid[i]) {
      activeIndex = i;
    }
  }
  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
  }
  return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  const swiper = this;
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  const {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper;
  let activeIndex = newActiveIndex;
  let snapIndex;
  const getVirtualRealIndex = aIndex => {
    let realIndex = aIndex - swiper.virtual.slidesBefore;
    if (realIndex < 0) {
      realIndex = swiper.virtual.slides.length + realIndex;
    }
    if (realIndex >= swiper.virtual.slides.length) {
      realIndex -= swiper.virtual.slides.length;
    }
    return realIndex;
  };
  if (typeof activeIndex === 'undefined') {
    activeIndex = getActiveIndexByTranslate(swiper);
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex && !swiper.params.loop) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }
  if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
    swiper.realIndex = getVirtualRealIndex(activeIndex);
    return;
  }
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;

  // Get real index
  let realIndex;
  if (swiper.virtual && params.virtual.enabled && params.loop) {
    realIndex = getVirtualRealIndex(activeIndex);
  } else if (gridEnabled) {
    const firstSlideInColumn = swiper.slides.filter(slideEl => slideEl.column === activeIndex)[0];
    let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute('data-swiper-slide-index'), 10);
    if (Number.isNaN(activeSlideIndex)) {
      activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
    }
    realIndex = Math.floor(activeSlideIndex / params.grid.rows);
  } else if (swiper.slides[activeIndex]) {
    const slideIndex = swiper.slides[activeIndex].getAttribute('data-swiper-slide-index');
    if (slideIndex) {
      realIndex = parseInt(slideIndex, 10);
    } else {
      realIndex = activeIndex;
    }
  } else {
    realIndex = activeIndex;
  }
  Object.assign(swiper, {
    previousSnapIndex,
    snapIndex,
    previousRealIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  if (swiper.initialized) {
    preload(swiper);
  }
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }
    swiper.emit('slideChange');
  }
}

function updateClickedSlide(el, path) {
  const swiper = this;
  const params = swiper.params;
  let slide = el.closest(`.${params.slideClass}, swiper-slide`);
  if (!slide && swiper.isElement && path && path.length > 1 && path.includes(el)) {
    [...path.slice(path.indexOf(el) + 1, path.length)].forEach(pathEl => {
      if (!slide && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
        slide = pathEl;
      }
    });
  }
  let slideFound = false;
  let slideIndex;
  if (slide) {
    for (let i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(slide.getAttribute('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};

function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? 'x' : 'y';
  }
  const swiper = this;
  const {
    params,
    rtlTranslate: rtl,
    translate,
    wrapperEl
  } = swiper;
  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }
  if (params.cssMode) {
    return translate;
  }
  let currentTranslate = getTranslate(wrapperEl, axis);
  currentTranslate += swiper.cssOverflowAdjustment();
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}

function setTranslate(translate, byController) {
  const swiper = this;
  const {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress
  } = swiper;
  let x = 0;
  let y = 0;
  const z = 0;
  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }
  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    if (swiper.isHorizontal()) {
      x -= swiper.cssOverflowAdjustment();
    } else {
      y -= swiper.cssOverflowAdjustment();
    }
    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
  }

  // Check if we need to update progress
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }
  swiper.emit('setTranslate', swiper.translate, byController);
}

function minTranslate() {
  return -this.snapGrid[0];
}

function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
  if (translate === void 0) {
    translate = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (translateBounds === void 0) {
    translateBounds = true;
  }
  const swiper = this;
  const {
    params,
    wrapperEl
  } = swiper;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate = swiper.minTranslate();
  const maxTranslate = swiper.maxTranslate();
  let newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;

  // Update progress
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: -newTranslate,
          side: isH ? 'left' : 'top'
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: -newTranslate,
        behavior: 'smooth'
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.wrapperEl.removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          swiper.animating = false;
          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }
      swiper.wrapperEl.addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}

var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};

function setTransition(duration, byController) {
  const swiper = this;
  if (!swiper.params.cssMode) {
    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
    swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : '';
  }
  swiper.emit('setTransition', duration, byController);
}

function transitionEmit(_ref) {
  let {
    swiper,
    runCallbacks,
    direction,
    step
  } = _ref;
  const {
    activeIndex,
    previousIndex
  } = swiper;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }
  swiper.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit(`slideResetTransition${step}`);
      return;
    }
    swiper.emit(`slideChangeTransition${step}`);
    if (dir === 'next') {
      swiper.emit(`slideNextTransition${step}`);
    } else {
      swiper.emit(`slidePrevTransition${step}`);
    }
  }
}

function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  if (params.cssMode) return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'Start'
  });
}

function transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  transitionEmit({
    swiper,
    runCallbacks,
    direction,
    step: 'End'
  });
}

var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};

function slideTo(index, speed, runCallbacks, internal, initial) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === 'string') {
    index = parseInt(index, 10);
  }
  const swiper = this;
  let slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper;
  if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  const translate = -snapGrid[snapIndex];
  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (let i = 0; i < slidesGrid.length; i += 1) {
      const normalizedTranslate = -Math.floor(translate * 100);
      const normalizedGrid = Math.floor(slidesGrid[i] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) {
        return false;
      }
    }
  }
  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }

  // Update progress
  swiper.updateProgress(translate);
  let direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';

  // Update Index
  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper.isHorizontal();
    const t = rtl ? translate : -translate;
    if (speed === 0) {
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      if (isVirtual) {
        swiper.wrapperEl.style.scrollSnapType = 'none';
        swiper._immediateVirtual = true;
      }
      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
        swiper._cssModeVirtualInitialSet = true;
        requestAnimationFrame(() => {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        });
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper.wrapperEl.style.scrollSnapType = '';
          swiper._immediateVirtual = false;
        });
      }
    } else {
      if (!swiper.support.smoothScroll) {
        animateCSSModeScroll({
          swiper,
          targetPosition: t,
          side: isH ? 'left' : 'top'
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? 'left' : 'top']: t,
        behavior: 'smooth'
      });
    }
    return true;
  }
  swiper.setTransition(speed);
  swiper.setTranslate(translate);
  swiper.updateActiveIndex(slideIndex);
  swiper.updateSlidesClasses();
  swiper.emit('beforeTransitionStart', speed, internal);
  swiper.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper.transitionEnd(runCallbacks, direction);
  } else if (!swiper.animating) {
    swiper.animating = true;
    if (!swiper.onSlideToWrapperTransitionEnd) {
      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
        if (!swiper || swiper.destroyed) return;
        if (e.target !== this) return;
        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.onSlideToWrapperTransitionEnd = null;
        delete swiper.onSlideToWrapperTransitionEnd;
        swiper.transitionEnd(runCallbacks, direction);
      };
    }
    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
  }
  return true;
}

function slideToLoop(index, speed, runCallbacks, internal) {
  if (index === void 0) {
    index = 0;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === 'string') {
    const indexAsNumber = parseInt(index, 10);
    index = indexAsNumber;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
  let newIndex = index;
  if (swiper.params.loop) {
    if (swiper.virtual && swiper.params.virtual.enabled) {
      // eslint-disable-next-line
      newIndex = newIndex + swiper.virtual.slidesBefore;
    } else {
      let targetSlideIndex;
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        targetSlideIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;
      } else {
        targetSlideIndex = swiper.getSlideIndexByData(newIndex);
      }
      const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
      const {
        centeredSlides
      } = swiper.params;
      let slidesPerView = swiper.params.slidesPerView;
      if (slidesPerView === 'auto') {
        slidesPerView = swiper.slidesPerViewDynamic();
      } else {
        slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
        if (centeredSlides && slidesPerView % 2 === 0) {
          slidesPerView = slidesPerView + 1;
        }
      }
      let needLoopFix = cols - targetSlideIndex < slidesPerView;
      if (centeredSlides) {
        needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
      }
      if (internal && centeredSlides && swiper.params.slidesPerView !== 'auto' && !gridEnabled) {
        needLoopFix = false;
      }
      if (needLoopFix) {
        const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? 'prev' : 'next' : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? 'next' : 'prev';
        swiper.loopFix({
          direction,
          slideTo: true,
          activeSlideIndex: direction === 'next' ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
          slideRealIndex: direction === 'next' ? swiper.realIndex : undefined
        });
      }
      if (gridEnabled) {
        const slideIndex = newIndex * swiper.params.grid.rows;
        newIndex = swiper.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === slideIndex)[0].column;
      } else {
        newIndex = swiper.getSlideIndexByData(newIndex);
      }
    }
  }
  requestAnimationFrame(() => {
    swiper.slideTo(newIndex, speed, runCallbacks, internal);
  });
  return swiper;
}

/* eslint no-unused-vars: "off" */
function slideNext(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    enabled,
    params,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper.slidesPerViewDynamic('current', true), 1);
  }
  const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: 'next'
    });
    // eslint-disable-next-line
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
    if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
      });
      return true;
    }
  }
  if (params.rewind && swiper.isEnd) {
    return swiper.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slidePrev(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  const {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating
  } = swiper;
  if (!enabled || swiper.destroyed) return swiper;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  const isVirtual = swiper.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding) return false;
    swiper.loopFix({
      direction: 'prev'
    });
    // eslint-disable-next-line
    swiper._clientLeft = swiper.wrapperEl.clientLeft;
  }
  const translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize(translate);
  const normalizedSnapGrid = snapGrid.map(val => normalize(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === 'undefined' && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        // prevSnap = snap;
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== 'undefined') {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
    if (params.slidesPerView === 'auto' && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper.slidesPerViewDynamic('previous', true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper.isBeginning) {
    const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
  } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
    requestAnimationFrame(() => {
      swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    });
    return true;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideReset(speed, runCallbacks, internal) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

/* eslint no-unused-vars: "off" */
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (threshold === void 0) {
    threshold = 0.5;
  }
  const swiper = this;
  if (swiper.destroyed) return;
  if (typeof speed === 'undefined') {
    speed = swiper.params.speed;
  }
  let index = swiper.activeIndex;
  const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    const currentSnap = swiper.snapGrid[snapIndex];
    const nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    const prevSnap = swiper.snapGrid[snapIndex - 1];
    const currentSnap = swiper.snapGrid[snapIndex];
    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}

function slideToClickedSlide() {
  const swiper = this;
  if (swiper.destroyed) return;
  const {
    params,
    slidesEl
  } = swiper;
  const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper.clickedIndex;
  let realIndex;
  const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(swiper.clickedSlide.getAttribute('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
      nextTick(() => {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};

function loopCreate(slideRealIndex) {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  const initSlides = () => {
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    slides.forEach((el, index) => {
      el.setAttribute('data-swiper-slide-index', index);
    });
  };
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
  const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
  const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
  const addBlankSlides = amountOfSlides => {
    for (let i = 0; i < amountOfSlides; i += 1) {
      const slideEl = swiper.isElement ? createElement('swiper-slide', [params.slideBlankClass]) : createElement('div', [params.slideClass, params.slideBlankClass]);
      swiper.slidesEl.append(slideEl);
    }
  };
  if (shouldFillGroup) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      showWarning('Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
    }
    initSlides();
  } else if (shouldFillGrid) {
    if (params.loopAddBlankSlides) {
      const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
      addBlankSlides(slidesToAdd);
      swiper.recalcSlides();
      swiper.updateSlides();
    } else {
      showWarning('Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)');
    }
    initSlides();
  } else {
    initSlides();
  }
  swiper.loopFix({
    slideRealIndex,
    direction: params.centeredSlides ? undefined : 'next'
  });
}

function loopFix(_temp) {
  let {
    slideRealIndex,
    slideTo = true,
    direction,
    setTranslate,
    activeSlideIndex,
    byController,
    byMousewheel
  } = _temp === void 0 ? {} : _temp;
  const swiper = this;
  if (!swiper.params.loop) return;
  swiper.emit('beforeLoopFix');
  const {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params
  } = swiper;
  const {
    centeredSlides
  } = params;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  if (swiper.virtual && params.virtual.enabled) {
    if (slideTo) {
      if (!params.centeredSlides && swiper.snapIndex === 0) {
        swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
      } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
        swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
      } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
        swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit('loopFix');
    return;
  }
  let slidesPerView = params.slidesPerView;
  if (slidesPerView === 'auto') {
    slidesPerView = swiper.slidesPerViewDynamic();
  } else {
    slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
    if (centeredSlides && slidesPerView % 2 === 0) {
      slidesPerView = slidesPerView + 1;
    }
  }
  const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
  let loopedSlides = slidesPerGroup;
  if (loopedSlides % slidesPerGroup !== 0) {
    loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
  }
  loopedSlides += params.loopAdditionalSlides;
  swiper.loopedSlides = loopedSlides;
  const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
  if (slides.length < slidesPerView + loopedSlides) {
    showWarning('Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters');
  } else if (gridEnabled && params.grid.fill === 'row') {
    showWarning('Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`');
  }
  const prependSlidesIndexes = [];
  const appendSlidesIndexes = [];
  let activeIndex = swiper.activeIndex;
  if (typeof activeSlideIndex === 'undefined') {
    activeSlideIndex = swiper.getSlideIndex(slides.filter(el => el.classList.contains(params.slideActiveClass))[0]);
  } else {
    activeIndex = activeSlideIndex;
  }
  const isNext = direction === 'next' || !direction;
  const isPrev = direction === 'prev' || !direction;
  let slidesPrepended = 0;
  let slidesAppended = 0;
  const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
  const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
  const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate === 'undefined' ? -slidesPerView / 2 + 0.5 : 0);
  // prepend last slides before start
  if (activeColIndexWithShift < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
    for (let i = 0; i < loopedSlides - activeColIndexWithShift; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        const colIndexToPrepend = cols - index - 1;
        for (let i = slides.length - 1; i >= 0; i -= 1) {
          if (slides[i].column === colIndexToPrepend) prependSlidesIndexes.push(i);
        }
        // slides.forEach((slide, slideIndex) => {
        //   if (slide.column === colIndexToPrepend) prependSlidesIndexes.push(slideIndex);
        // });
      } else {
        prependSlidesIndexes.push(cols - index - 1);
      }
    }
  } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
    slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
    for (let i = 0; i < slidesAppended; i += 1) {
      const index = i - Math.floor(i / cols) * cols;
      if (gridEnabled) {
        slides.forEach((slide, slideIndex) => {
          if (slide.column === index) appendSlidesIndexes.push(slideIndex);
        });
      } else {
        appendSlidesIndexes.push(index);
      }
    }
  }
  swiper.__preventObserver__ = true;
  requestAnimationFrame(() => {
    swiper.__preventObserver__ = false;
  });
  if (isPrev) {
    prependSlidesIndexes.forEach(index => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.prepend(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  if (isNext) {
    appendSlidesIndexes.forEach(index => {
      slides[index].swiperLoopMoveDOM = true;
      slidesEl.append(slides[index]);
      slides[index].swiperLoopMoveDOM = false;
    });
  }
  swiper.recalcSlides();
  if (params.slidesPerView === 'auto') {
    swiper.updateSlides();
  } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
    swiper.slides.forEach((slide, slideIndex) => {
      swiper.grid.updateSlide(slideIndex, slide, swiper.slides);
    });
  }
  if (params.watchSlidesProgress) {
    swiper.updateSlidesOffset();
  }
  if (slideTo) {
    if (prependSlidesIndexes.length > 0 && isPrev) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
          if (setTranslate) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        if (setTranslate) {
          const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
          swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
          swiper.touchEventsData.currentTranslate = swiper.translate;
        }
      }
    } else if (appendSlidesIndexes.length > 0 && isNext) {
      if (typeof slideRealIndex === 'undefined') {
        const currentSlideTranslate = swiper.slidesGrid[activeIndex];
        const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper.setTranslate(swiper.translate - diff);
        } else {
          swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
          if (setTranslate) {
            swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
            swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
          }
        }
      } else {
        const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
        swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
      }
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.controller && swiper.controller.control && !byController) {
    const loopParams = {
      slideRealIndex,
      direction,
      setTranslate,
      activeSlideIndex,
      byController: true
    };
    if (Array.isArray(swiper.controller.control)) {
      swiper.controller.control.forEach(c => {
        if (!c.destroyed && c.params.loop) c.loopFix({
          ...loopParams,
          slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo : false
        });
      });
    } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
      swiper.controller.control.loopFix({
        ...loopParams,
        slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo : false
      });
    }
  }
  swiper.emit('loopFix');
}

function loopDestroy() {
  const swiper = this;
  const {
    params,
    slidesEl
  } = swiper;
  if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
  swiper.recalcSlides();
  const newSlidesOrder = [];
  swiper.slides.forEach(slideEl => {
    const index = typeof slideEl.swiperSlideIndex === 'undefined' ? slideEl.getAttribute('data-swiper-slide-index') * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index] = slideEl;
  });
  swiper.slides.forEach(slideEl => {
    slideEl.removeAttribute('data-swiper-slide-index');
  });
  newSlidesOrder.forEach(slideEl => {
    slidesEl.append(slideEl);
  });
  swiper.recalcSlides();
  swiper.slideTo(swiper.realIndex, 0);
}

var loop = {
  loopCreate,
  loopFix,
  loopDestroy
};

function setGrabCursor(moving) {
  const swiper = this;
  if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  const el = swiper.params.touchEventsTarget === 'container' ? swiper.el : swiper.wrapperEl;
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  el.style.cursor = 'move';
  el.style.cursor = moving ? 'grabbing' : 'grab';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}

function unsetGrabCursor() {
  const swiper = this;
  if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  if (swiper.isElement) {
    swiper.__preventObserver__ = true;
  }
  swiper[swiper.params.touchEventsTarget === 'container' ? 'el' : 'wrapperEl'].style.cursor = '';
  if (swiper.isElement) {
    requestAnimationFrame(() => {
      swiper.__preventObserver__ = false;
    });
  }
}

var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};

// Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }
  function __closestFrom(el) {
    if (!el || el === getDocument() || el === getWindow()) return null;
    if (el.assignedSlot) el = el.assignedSlot;
    const found = el.closest(selector);
    if (!found && !el.getRootNode) {
      return null;
    }
    return found || __closestFrom(el.getRootNode().host);
  }
  return __closestFrom(base);
}
function preventEdgeSwipe(swiper, event, startX) {
  const window = getWindow();
  const {
    params
  } = swiper;
  const edgeSwipeDetection = params.edgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
      return true;
    }
    return false;
  }
  return true;
}
function onTouchStart(event) {
  const swiper = this;
  const document = getDocument();
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  const data = swiper.touchEventsData;
  if (e.type === 'pointerdown') {
    if (data.pointerId !== null && data.pointerId !== e.pointerId) {
      return;
    }
    data.pointerId = e.pointerId;
  } else if (e.type === 'touchstart' && e.targetTouches.length === 1) {
    data.touchId = e.targetTouches[0].identifier;
  }
  if (e.type === 'touchstart') {
    // don't proceed touch event
    preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
    return;
  }
  const {
    params,
    touches,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e.pointerType === 'mouse') return;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper.animating && params.cssMode && params.loop) {
    swiper.loopFix();
  }
  let targetEl = e.target;
  if (params.touchEventsTarget === 'wrapper') {
    if (!elementIsChildOf(targetEl, swiper.wrapperEl)) return;
  }
  if ('which' in e && e.which === 3) return;
  if ('button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;

  // change target el for shadow root component
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
  // eslint-disable-next-line
  const eventPath = e.composedPath ? e.composedPath() : e.path;
  if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
    targetEl = eventPath[0];
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e.target && e.target.shadowRoot);

  // use closestElement for shadow root element to get the actual closest for nested shadow root element
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!targetEl.closest(params.swipeHandler)) return;
  }
  touches.currentX = e.pageX;
  touches.currentY = e.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  if (!preventEdgeSwipe(swiper, e, startX)) {
    return;
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now$1();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  let preventDefault = true;
  if (targetEl.matches(data.focusableElements)) {
    preventDefault = false;
    if (targetEl.nodeName === 'SELECT') {
      data.isTouched = false;
    }
  }
  if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) {
    document.activeElement.blur();
  }
  const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
    e.preventDefault();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
    swiper.freeMode.onTouchStart();
  }
  swiper.emit('touchStart', e);
}

function onTouchMove(event) {
  const document = getDocument();
  const swiper = this;
  const data = swiper.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && event.pointerType === 'mouse') return;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (e.type === 'pointermove') {
    if (data.touchId !== null) return; // return from pointer if we use touch
    const id = e.pointerId;
    if (id !== data.pointerId) return;
  }
  let targetTouch;
  if (e.type === 'touchmove') {
    targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  } else {
    targetTouch = e;
  }
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  const pageX = targetTouch.pageX;
  const pageY = targetTouch.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    if (!e.target.matches(data.focusableElements)) {
      swiper.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now$1();
    }
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (document.activeElement) {
    if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  touches.previousX = touches.currentX;
  touches.previousY = touches.currentY;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
  if (typeof data.isScrolling === 'undefined') {
    let touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling || e.type === 'touchmove' && data.preventTouchMoveFromPointerMove) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }
  let diff = swiper.isHorizontal() ? diffX : diffY;
  let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  if (params.oneWayMovement) {
    diff = Math.abs(diff) * (rtl ? 1 : -1);
    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
  }
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) {
    diff = -diff;
    touchesDiff = -touchesDiff;
  }
  const prevTouchesDirection = swiper.touchesDirection;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  swiper.touchesDirection = touchesDiff > 0 ? 'prev' : 'next';
  const isLoop = swiper.params.loop && !params.cssMode;
  const allowLoopFix = swiper.touchesDirection === 'next' && swiper.allowSlideNext || swiper.touchesDirection === 'prev' && swiper.allowSlidePrev;
  if (!data.isMoved) {
    if (isLoop && allowLoopFix) {
      swiper.loopFix({
        direction: swiper.swipeDirection
      });
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      const evt = new window.CustomEvent('transitionend', {
        bubbles: true,
        cancelable: true,
        detail: {
          bySwiperTouchMove: true
        }
      });
      swiper.wrapperEl.dispatchEvent(evt);
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  let loopFixed;
  new Date().getTime();
  if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
    Object.assign(touches, {
      startX: pageX,
      startY: pageY,
      currentX: pageX,
      currentY: pageY,
      startTranslate: data.currentTranslate
    });
    data.loopSwapReset = true;
    data.startTranslate = data.currentTranslate;
    return;
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {
      swiper.loopFix({
        direction: 'prev',
        setTranslate: true,
        activeSlideIndex: 0
      });
    }
    if (data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      }
    }
  } else if (diff < 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== 'auto' && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {
      swiper.loopFix({
        direction: 'next',
        setTranslate: true,
        activeSlideIndex: swiper.slides.length - (params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
      });
    }
    if (data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }
    }
  }
  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }

  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode) return;

  // Update active index in free mode
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
    swiper.freeMode.onTouchMove();
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}

function onTouchEnd(event) {
  const swiper = this;
  const data = swiper.touchEventsData;
  let e = event;
  if (e.originalEvent) e = e.originalEvent;
  let targetTouch;
  const isTouchEvent = e.type === 'touchend' || e.type === 'touchcancel';
  if (!isTouchEvent) {
    if (data.touchId !== null) return; // return from pointer if we use touch
    if (e.pointerId !== data.pointerId) return;
    targetTouch = e;
  } else {
    targetTouch = [...e.changedTouches].filter(t => t.identifier === data.touchId)[0];
    if (!targetTouch || targetTouch.identifier !== data.touchId) return;
  }
  if (['pointercancel', 'pointerout', 'pointerleave', 'contextmenu'].includes(e.type)) {
    const proceed = ['pointercancel', 'contextmenu'].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
    if (!proceed) {
      return;
    }
  }
  data.pointerId = null;
  data.touchId = null;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper;
  if (!enabled) return;
  if (!params.simulateTouch && e.pointerType === 'mouse') return;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }

  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  const touchEndTime = now$1();
  const timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    const pathTree = e.path || e.composedPath && e.composedPath();
    swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
    swiper.emit('tap click', e);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }
  data.lastClickTime = now$1();
  nextTick(() => {
    if (!swiper.destroyed) swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode && params.freeMode.enabled) {
    swiper.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }

  // Find current slide
  const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
  let stopIndex = 0;
  let groupSize = swiper.slidesSizesGrid[0];
  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + increment] !== 'undefined') {
      if (swipeToLast || currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + increment] - slidesGrid[i];
      }
    } else if (swipeToLast || currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper.isBeginning) {
      rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
    } else if (swiper.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  // Find current slide size
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper.slideTo(rewindLastIndex);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

function onResize() {
  const swiper = this;
  const {
    params,
    el
  } = swiper;
  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper;
  const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  const isVirtualLoop = isVirtual && params.loop;
  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    if (swiper.params.loop && !isVirtual) {
      swiper.slideToLoop(swiper.realIndex, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    clearTimeout(swiper.autoplay.resizeTimeout);
    swiper.autoplay.resizeTimeout = setTimeout(() => {
      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.resume();
      }
    }, 500);
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

function onClick(e) {
  const swiper = this;
  if (!swiper.enabled) return;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

function onScroll() {
  const swiper = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper;
  if (!enabled) return;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    swiper.translate = -wrapperEl.scrollLeft;
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  // eslint-disable-next-line
  if (swiper.translate === 0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit('setTranslate', swiper.translate, false);
}

function onLoad(e) {
  const swiper = this;
  processLazyPreloader(swiper, e.target);
  if (swiper.params.cssMode || swiper.params.slidesPerView !== 'auto' && !swiper.params.autoHeight) {
    return;
  }
  swiper.update();
}

function onDocumentTouchStart() {
  const swiper = this;
  if (swiper.documentTouchHandlerProceeded) return;
  swiper.documentTouchHandlerProceeded = true;
  if (swiper.params.touchReleaseOnEdges) {
    swiper.el.style.touchAction = 'auto';
  }
}

const events = (swiper, method) => {
  const document = getDocument();
  const {
    params,
    el,
    wrapperEl,
    device
  } = swiper;
  const capture = !!params.nested;
  const domMethod = method === 'on' ? 'addEventListener' : 'removeEventListener';
  const swiperMethod = method;
  if (!el || typeof el === 'string') return;

  // Touch Events
  document[domMethod]('touchstart', swiper.onDocumentTouchStart, {
    passive: false,
    capture
  });
  el[domMethod]('touchstart', swiper.onTouchStart, {
    passive: false
  });
  el[domMethod]('pointerdown', swiper.onTouchStart, {
    passive: false
  });
  document[domMethod]('touchmove', swiper.onTouchMove, {
    passive: false,
    capture
  });
  document[domMethod]('pointermove', swiper.onTouchMove, {
    passive: false,
    capture
  });
  document[domMethod]('touchend', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerup', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointercancel', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('touchcancel', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerout', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('pointerleave', swiper.onTouchEnd, {
    passive: true
  });
  document[domMethod]('contextmenu', swiper.onTouchEnd, {
    passive: true
  });

  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el[domMethod]('click', swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]('scroll', swiper.onScroll);
  }

  // Resize handler
  if (params.updateOnWindowResize) {
    swiper[swiperMethod](device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  } else {
    swiper[swiperMethod]('observerUpdate', onResize, true);
  }

  // Images loader
  el[domMethod]('load', swiper.onLoad, {
    capture: true
  });
};
function attachEvents() {
  const swiper = this;
  const {
    params
  } = swiper;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  swiper.onLoad = onLoad.bind(swiper);
  events(swiper, 'on');
}
function detachEvents() {
  const swiper = this;
  events(swiper, 'off');
}
var events$1 = {
  attachEvents,
  detachEvents
};

const isGridEnabled = (swiper, params) => {
  return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper = this;
  const {
    realIndex,
    initialized,
    params,
    el
  } = swiper;
  const breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;

  // Get breakpoint for window width and update parameters
  const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
  const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
  const breakpointParams = breakpointOnlyParams || swiper.originalParams;
  const wasMultiRow = isGridEnabled(swiper, params);
  const isMultiRow = isGridEnabled(swiper, breakpointParams);
  const wasGrabCursor = swiper.params.grabCursor;
  const isGrabCursor = breakpointParams.grabCursor;
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
    swiper.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    el.classList.add(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === 'column' || !breakpointParams.grid.fill && params.grid.fill === 'column') {
      el.classList.add(`${params.containerModifierClass}grid-column`);
    }
    swiper.emitContainerClasses();
  }
  if (wasGrabCursor && !isGrabCursor) {
    swiper.unsetGrabCursor();
  } else if (!wasGrabCursor && isGrabCursor) {
    swiper.setGrabCursor();
  }

  // Toggle navigation, pagination, scrollbar
  ['navigation', 'pagination', 'scrollbar'].forEach(prop => {
    if (typeof breakpointParams[prop] === 'undefined') return;
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper[prop].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  const wasLoop = params.loop;
  if (directionChanged && initialized) {
    swiper.changeDirection();
  }
  extend$1(swiper.params, breakpointParams);
  const isEnabled = swiper.params.enabled;
  const hasLoop = swiper.params.loop;
  Object.assign(swiper, {
    allowTouchMove: swiper.params.allowTouchMove,
    allowSlideNext: swiper.params.allowSlideNext,
    allowSlidePrev: swiper.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper.enable();
  }
  swiper.currentBreakpoint = breakpoint;
  swiper.emit('_beforeBreakpoint', breakpointParams);
  if (initialized) {
    if (needsReLoop) {
      swiper.loopDestroy();
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (!wasLoop && hasLoop) {
      swiper.loopCreate(realIndex);
      swiper.updateSlides();
    } else if (wasLoop && !hasLoop) {
      swiper.loopDestroy();
    }
  }
  swiper.emit('breakpoint', breakpointParams);
}

function getBreakpoint(breakpoints, base, containerEl) {
  if (base === void 0) {
    base = 'window';
  }
  if (!breakpoints || base === 'container' && !containerEl) return undefined;
  let breakpoint = false;
  const window = getWindow();
  const currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints).map(point => {
    if (typeof point === 'string' && point.indexOf('@') === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
  for (let i = 0; i < points.length; i += 1) {
    const {
      point,
      value
    } = points[i];
    if (base === 'window') {
      if (window.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || 'max';
}

var breakpoints = {
  setBreakpoint,
  getBreakpoint
};

function prepareClasses(entries, prefix) {
  const resultClasses = [];
  entries.forEach(item => {
    if (typeof item === 'object') {
      Object.keys(item).forEach(classNames => {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === 'string') {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper = this;
  const {
    classNames,
    params,
    rtl,
    el,
    device
  } = swiper;
  // prettier-ignore
  const suffixes = prepareClasses(['initialized', params.direction, {
    'free-mode': swiper.params.freeMode && params.freeMode.enabled
  }, {
    'autoheight': params.autoHeight
  }, {
    'rtl': rtl
  }, {
    'grid': params.grid && params.grid.rows > 1
  }, {
    'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
  }, {
    'android': device.android
  }, {
    'ios': device.ios
  }, {
    'css-mode': params.cssMode
  }, {
    'centered': params.cssMode && params.centeredSlides
  }, {
    'watch-progress': params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  el.classList.add(...classNames);
  swiper.emitContainerClasses();
}

function removeClasses() {
  const swiper = this;
  const {
    el,
    classNames
  } = swiper;
  if (!el || typeof el === 'string') return;
  el.classList.remove(...classNames);
  swiper.emitContainerClasses();
}

var classes = {
  addClasses,
  removeClasses
};

function checkOverflow() {
  const swiper = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper.slides.length - 1;
    const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper.isLocked = swiper.size > lastSlideRightEdge;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper.allowSlideNext = !swiper.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper.allowSlidePrev = !swiper.isLocked;
  }
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
  }
  if (wasLocked !== swiper.isLocked) {
    swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
  }
}
var checkOverflow$1 = {
  checkOverflow
};

var defaults = {
  init: true,
  direction: 'horizontal',
  oneWayMovement: false,
  swiperElementNodeName: 'SWIPER-CONTAINER',
  touchEventsTarget: 'wrapper',
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  eventsPrefix: 'swiper',
  enabled: true,
  focusableElements: 'input, select, option, textarea, button, video, label',
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: 'slide',
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

  // Breakpoints
  breakpoints: undefined,
  breakpointsBase: 'window',
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 5,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // loop
  loop: false,
  loopAddBlankSlides: true,
  loopAdditionalSlides: 0,
  loopPreventsSliding: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: 'swiper-no-swiping',
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: 'swiper-',
  // NEW
  slideClass: 'swiper-slide',
  slideBlankClass: 'swiper-slide-blank',
  slideActiveClass: 'swiper-slide-active',
  slideVisibleClass: 'swiper-slide-visible',
  slideFullyVisibleClass: 'swiper-slide-fully-visible',
  slideNextClass: 'swiper-slide-next',
  slidePrevClass: 'swiper-slide-prev',
  wrapperClass: 'swiper-wrapper',
  lazyPreloaderClass: 'swiper-lazy-preloader',
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};

function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj) {
    if (obj === void 0) {
      obj = {};
    }
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== 'object' || moduleParams === null) {
      extend$1(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (moduleParamName === 'navigation' && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
      params[moduleParamName].auto = true;
    }
    if (['pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
      params[moduleParamName].auto = true;
    }
    if (!(moduleParamName in params && 'enabled' in moduleParams)) {
      extend$1(allModulesParams, obj);
      return;
    }
    if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName]) params[moduleParamName] = {
      enabled: false
    };
    extend$1(allModulesParams, obj);
  };
}

/* eslint no-param-reassign: "off" */
const prototypes = {
  eventsEmitter,
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes
};
const extendedDefaults = {};
let Swiper$1 = class Swiper {
  constructor() {
    let el;
    let params;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
      params = args[0];
    } else {
      [el, params] = args;
    }
    if (!params) params = {};
    params = extend$1({}, params);
    if (el && !params.el) params.el = el;
    const document = getDocument();
    if (params.el && typeof params.el === 'string' && document.querySelectorAll(params.el).length > 1) {
      const swipers = [];
      document.querySelectorAll(params.el).forEach(containerEl => {
        const newParams = extend$1({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      // eslint-disable-next-line no-constructor-return
      return swipers;
    }

    // Swiper Instance
    const swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    swiper.modules = [...swiper.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper.modules.forEach(mod => {
      mod({
        params,
        swiper,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper.on.bind(swiper),
        once: swiper.once.bind(swiper),
        off: swiper.off.bind(swiper),
        emit: swiper.emit.bind(swiper)
      });
    });

    // Extend defaults with modules params
    const swiperParams = extend$1({}, defaults, allModulesParams);

    // Extend defaults with passed params
    swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend$1({}, swiper.params);
    swiper.passedParams = extend$1({}, params);

    // add event listeners
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(eventName => {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }

    // Extend Swiper
    Object.assign(swiper, {
      enabled: swiper.params.enabled,
      el,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return swiper.params.direction === 'horizontal';
      },
      isVertical() {
        return swiper.params.direction === 'vertical';
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      cssOverflowAdjustment() {
        // Returns 0 unless `translate` is > 2**23
        // Should be subtracted from css values to prevent overflow
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: undefined,
        isMoved: undefined,
        allowTouchCallbacks: undefined,
        touchStartTime: undefined,
        isScrolling: undefined,
        currentTranslate: undefined,
        startTranslate: undefined,
        allowThresholdMove: undefined,
        // Form elements to match
        focusableElements: swiper.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: undefined,
        // Velocities
        velocities: [],
        allowMomentumBounce: undefined,
        startMoving: undefined,
        pointerId: null,
        touchId: null
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.emit('_swiper');

    // Init
    if (swiper.params.init) {
      swiper.init();
    }

    // Return app instance
    // eslint-disable-next-line no-constructor-return
    return swiper;
  }
  getDirectionLabel(property) {
    if (this.isHorizontal()) {
      return property;
    }
    // prettier-ignore
    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  }
  getSlideIndex(slideEl) {
    const {
      slidesEl,
      params
    } = this;
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    const firstSlideIndex = elementIndex(slides[0]);
    return elementIndex(slideEl) - firstSlideIndex;
  }
  getSlideIndexByData(index) {
    return this.getSlideIndex(this.slides.filter(slideEl => slideEl.getAttribute('data-swiper-slide-index') * 1 === index)[0]);
  }
  recalcSlides() {
    const swiper = this;
    const {
      slidesEl,
      params
    } = swiper;
    swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  }
  enable() {
    const swiper = this;
    if (swiper.enabled) return;
    swiper.enabled = true;
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    swiper.emit('enable');
  }
  disable() {
    const swiper = this;
    if (!swiper.enabled) return;
    swiper.enabled = false;
    if (swiper.params.grabCursor) {
      swiper.unsetGrabCursor();
    }
    swiper.emit('disable');
  }
  setProgress(progress, speed) {
    const swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper.minTranslate();
    const max = swiper.maxTranslate();
    const current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const cls = swiper.el.className.split(' ').filter(className => {
      return className.indexOf('swiper') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit('_containerClasses', cls.join(' '));
  }
  getSlideClasses(slideEl) {
    const swiper = this;
    if (swiper.destroyed) return '';
    return slideEl.className.split(' ').filter(className => {
      return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(' ');
  }
  emitSlidesClasses() {
    const swiper = this;
    if (!swiper.params._emitClasses || !swiper.el) return;
    const updates = [];
    swiper.slides.forEach(slideEl => {
      const classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit('_slideClass', slideEl, classNames);
    });
    swiper.emit('_slideClasses', updates);
  }
  slidesPerViewDynamic(view, exact) {
    if (view === void 0) {
      view = 'current';
    }
    if (exact === void 0) {
      exact = false;
    }
    const swiper = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper;
    let spv = 1;
    if (typeof params.slidesPerView === 'number') return params.slidesPerView;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
      let breakLoop;
      for (let i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += Math.ceil(slides[i].swiperSlideSize);
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
      for (let i = activeIndex - 1; i >= 0; i -= 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize) breakLoop = true;
        }
      }
    } else {
      // eslint-disable-next-line
      if (view === 'current') {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        // previous
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper = this;
    if (!swiper || swiper.destroyed) return;
    const {
      snapGrid,
      params
    } = swiper;
    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(imageEl => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      }
    });
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate() {
      const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    let translated;
    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
      setTranslate();
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
        const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
        translated = swiper.slideTo(slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit('update');
  }
  changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }
    const swiper = this;
    const currentDirection = swiper.params.direction;
    if (!newDirection) {
      // eslint-disable-next-line
      newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
    }
    if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
      return swiper;
    }
    swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
    swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.forEach(slideEl => {
      if (newDirection === 'vertical') {
        slideEl.style.width = '';
      } else {
        slideEl.style.height = '';
      }
    });
    swiper.emit('changeDirection');
    if (needUpdate) swiper.update();
    return swiper;
  }
  changeLanguageDirection(direction) {
    const swiper = this;
    if (swiper.rtl && direction === 'rtl' || !swiper.rtl && direction === 'ltr') return;
    swiper.rtl = direction === 'rtl';
    swiper.rtlTranslate = swiper.params.direction === 'horizontal' && swiper.rtl;
    if (swiper.rtl) {
      swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'rtl';
    } else {
      swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
      swiper.el.dir = 'ltr';
    }
    swiper.update();
  }
  mount(element) {
    const swiper = this;
    if (swiper.mounted) return true;

    // Find el
    let el = element || swiper.params.el;
    if (typeof el === 'string') {
      el = document.querySelector(el);
    }
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
      swiper.isElement = true;
    }
    const getWrapperSelector = () => {
      return `.${(swiper.params.wrapperClass || '').trim().split(' ').join('.')}`;
    };
    const getWrapper = () => {
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        const res = el.shadowRoot.querySelector(getWrapperSelector());
        // Children needs to return slot items
        return res;
      }
      return elementChildren(el, getWrapperSelector())[0];
    };
    // Find Wrapper
    let wrapperEl = getWrapper();
    if (!wrapperEl && swiper.params.createElements) {
      wrapperEl = createElement('div', swiper.params.wrapperClass);
      el.append(wrapperEl);
      elementChildren(el, `.${swiper.params.slideClass}`).forEach(slideEl => {
        wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper, {
      el,
      wrapperEl,
      slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
      hostEl: swiper.isElement ? el.parentNode.host : el,
      mounted: true,
      // RTL
      rtl: el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl',
      rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || elementStyle(el, 'direction') === 'rtl'),
      wrongRTL: elementStyle(wrapperEl, 'display') === '-webkit-box'
    });
    return true;
  }
  init(el) {
    const swiper = this;
    if (swiper.initialized) return swiper;
    const mounted = swiper.mount(el);
    if (mounted === false) return swiper;
    swiper.emit('beforeInit');

    // Set breakpoint
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Add Classes
    swiper.addClasses();

    // Update size
    swiper.updateSize();

    // Update slides
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }

    // Set Grab Cursor
    if (swiper.params.grabCursor && swiper.enabled) {
      swiper.setGrabCursor();
    }

    // Slide To Initial Slide
    if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
      swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
    }

    // Create loop
    if (swiper.params.loop) {
      swiper.loopCreate();
    }

    // Attach events
    swiper.attachEvents();
    const lazyElements = [...swiper.el.querySelectorAll('[loading="lazy"]')];
    if (swiper.isElement) {
      lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
    }
    lazyElements.forEach(imageEl => {
      if (imageEl.complete) {
        processLazyPreloader(swiper, imageEl);
      } else {
        imageEl.addEventListener('load', e => {
          processLazyPreloader(swiper, e.target);
        });
      }
    });
    preload(swiper);

    // Init Flag
    swiper.initialized = true;
    preload(swiper);

    // Emit
    swiper.emit('init');
    swiper.emit('afterInit');
    return swiper;
  }
  destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }
    if (cleanStyles === void 0) {
      cleanStyles = true;
    }
    const swiper = this;
    const {
      params,
      el,
      wrapperEl,
      slides
    } = swiper;
    if (typeof swiper.params === 'undefined' || swiper.destroyed) {
      return null;
    }
    swiper.emit('beforeDestroy');

    // Init Flag
    swiper.initialized = false;

    // Detach events
    swiper.detachEvents();

    // Destroy loop
    if (params.loop) {
      swiper.loopDestroy();
    }

    // Cleanup styles
    if (cleanStyles) {
      swiper.removeClasses();
      if (el && typeof el !== 'string') {
        el.removeAttribute('style');
      }
      if (wrapperEl) {
        wrapperEl.removeAttribute('style');
      }
      if (slides && slides.length) {
        slides.forEach(slideEl => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
          slideEl.removeAttribute('style');
          slideEl.removeAttribute('data-swiper-slide-index');
        });
      }
    }
    swiper.emit('destroy');

    // Detach emitter events
    Object.keys(swiper.eventsListeners).forEach(eventName => {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      if (swiper.el && typeof swiper.el !== 'string') {
        swiper.el.swiper = null;
      }
      deleteProps(swiper);
    }
    swiper.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    extend$1(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(mod) {
    if (!Swiper.prototype.__modules__) Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;
    if (typeof mod === 'function' && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }
  static use(module) {
    if (Array.isArray(module)) {
      module.forEach(m => Swiper.installModule(m));
      return Swiper;
    }
    Swiper.installModule(module);
    return Swiper;
  }
};
Object.keys(prototypes).forEach(prototypeGroup => {
  Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
    Swiper$1.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper$1.use([Resize, Observer]);

/* underscore in name -> watch for changes */
const paramsList = ['eventsPrefix', 'injectStyles', 'injectStylesUrls', 'modules', 'init', '_direction', 'oneWayMovement', 'swiperElementNodeName', 'touchEventsTarget', 'initialSlide', '_speed', 'cssMode', 'updateOnWindowResize', 'resizeObserver', 'nested', 'focusableElements', '_enabled', '_width', '_height', 'preventInteractionOnTransition', 'userAgent', 'url', '_edgeSwipeDetection', '_edgeSwipeThreshold', '_freeMode', '_autoHeight', 'setWrapperSize', 'virtualTranslate', '_effect', 'breakpoints', 'breakpointsBase', '_spaceBetween', '_slidesPerView', 'maxBackfaceHiddenSlides', '_grid', '_slidesPerGroup', '_slidesPerGroupSkip', '_slidesPerGroupAuto', '_centeredSlides', '_centeredSlidesBounds', '_slidesOffsetBefore', '_slidesOffsetAfter', 'normalizeSlideIndex', '_centerInsufficientSlides', '_watchOverflow', 'roundLengths', 'touchRatio', 'touchAngle', 'simulateTouch', '_shortSwipes', '_longSwipes', 'longSwipesRatio', 'longSwipesMs', '_followFinger', 'allowTouchMove', '_threshold', 'touchMoveStopPropagation', 'touchStartPreventDefault', 'touchStartForcePreventDefault', 'touchReleaseOnEdges', 'uniqueNavElements', '_resistance', '_resistanceRatio', '_watchSlidesProgress', '_grabCursor', 'preventClicks', 'preventClicksPropagation', '_slideToClickedSlide', '_loop', 'loopAdditionalSlides', 'loopAddBlankSlides', 'loopPreventsSliding', '_rewind', '_allowSlidePrev', '_allowSlideNext', '_swipeHandler', '_noSwiping', 'noSwipingClass', 'noSwipingSelector', 'passiveListeners', 'containerModifierClass', 'slideClass', 'slideActiveClass', 'slideVisibleClass', 'slideFullyVisibleClass', 'slideNextClass', 'slidePrevClass', 'slideBlankClass', 'wrapperClass', 'lazyPreloaderClass', 'lazyPreloadPrevNext', 'runCallbacksOnInit', 'observer', 'observeParents', 'observeSlideChildren',
// modules
'a11y', '_autoplay', '_controller', 'coverflowEffect', 'cubeEffect', 'fadeEffect', 'flipEffect', 'creativeEffect', 'cardsEffect', 'hashNavigation', 'history', 'keyboard', 'mousewheel', '_navigation', '_pagination', 'parallax', '_scrollbar', '_thumbs', 'virtual', 'zoom', 'control'];

function isObject$1(o) {
  return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object' && !o.__swiper__;
}
function extend(target, src) {
  const noExtend = ['__proto__', 'constructor', 'prototype'];
  Object.keys(src).filter(key => noExtend.indexOf(key) < 0).forEach(key => {
    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
      if (src[key].__swiper__) target[key] = src[key];else extend(target[key], src[key]);
    } else {
      target[key] = src[key];
    }
  });
}
function needsNavigation(params) {
  if (params === void 0) {
    params = {};
  }
  return params.navigation && typeof params.navigation.nextEl === 'undefined' && typeof params.navigation.prevEl === 'undefined';
}
function needsPagination(params) {
  if (params === void 0) {
    params = {};
  }
  return params.pagination && typeof params.pagination.el === 'undefined';
}
function needsScrollbar(params) {
  if (params === void 0) {
    params = {};
  }
  return params.scrollbar && typeof params.scrollbar.el === 'undefined';
}
function uniqueClasses(classNames) {
  if (classNames === void 0) {
    classNames = '';
  }
  const classes = classNames.split(' ').map(c => c.trim()).filter(c => !!c);
  const unique = [];
  classes.forEach(c => {
    if (unique.indexOf(c) < 0) unique.push(c);
  });
  return unique.join(' ');
}
function wrapperClass(className) {
  if (className === void 0) {
    className = '';
  }
  if (!className) return 'swiper-wrapper';
  if (!className.includes('swiper-wrapper')) return `swiper-wrapper ${className}`;
  return className;
}

function updateSwiper(_ref) {
  let {
    swiper,
    slides,
    passedParams,
    changedParams,
    nextEl,
    prevEl,
    scrollbarEl,
    paginationEl
  } = _ref;
  const updateParams = changedParams.filter(key => key !== 'children' && key !== 'direction' && key !== 'wrapperClass');
  const {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper;
  let needThumbsInit;
  let needControllerInit;
  let needPaginationInit;
  let needScrollbarInit;
  let needNavigationInit;
  let loopNeedDestroy;
  let loopNeedEnable;
  let loopNeedReloop;
  if (changedParams.includes('thumbs') && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
    needThumbsInit = true;
  }
  if (changedParams.includes('controller') && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
    needControllerInit = true;
  }
  if (changedParams.includes('pagination') && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
    needPaginationInit = true;
  }
  if (changedParams.includes('scrollbar') && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
    needScrollbarInit = true;
  }
  if (changedParams.includes('navigation') && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
    needNavigationInit = true;
  }
  const destroyModule = mod => {
    if (!swiper[mod]) return;
    swiper[mod].destroy();
    if (mod === 'navigation') {
      if (swiper.isElement) {
        swiper[mod].prevEl.remove();
        swiper[mod].nextEl.remove();
      }
      currentParams[mod].prevEl = undefined;
      currentParams[mod].nextEl = undefined;
      swiper[mod].prevEl = undefined;
      swiper[mod].nextEl = undefined;
    } else {
      if (swiper.isElement) {
        swiper[mod].el.remove();
      }
      currentParams[mod].el = undefined;
      swiper[mod].el = undefined;
    }
  };
  if (changedParams.includes('loop') && swiper.isElement) {
    if (currentParams.loop && !passedParams.loop) {
      loopNeedDestroy = true;
    } else if (!currentParams.loop && passedParams.loop) {
      loopNeedEnable = true;
    } else {
      loopNeedReloop = true;
    }
  }
  updateParams.forEach(key => {
    if (isObject$1(currentParams[key]) && isObject$1(passedParams[key])) {
      Object.assign(currentParams[key], passedParams[key]);
      if ((key === 'navigation' || key === 'pagination' || key === 'scrollbar') && 'enabled' in passedParams[key] && !passedParams[key].enabled) {
        destroyModule(key);
      }
    } else {
      const newValue = passedParams[key];
      if ((newValue === true || newValue === false) && (key === 'navigation' || key === 'pagination' || key === 'scrollbar')) {
        if (newValue === false) {
          destroyModule(key);
        }
      } else {
        currentParams[key] = passedParams[key];
      }
    }
  });
  if (updateParams.includes('controller') && !needControllerInit && swiper.controller && swiper.controller.control && currentParams.controller && currentParams.controller.control) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (changedParams.includes('children') && slides && virtual && currentParams.virtual.enabled) {
    virtual.slides = slides;
    virtual.update(true);
  } else if (changedParams.includes('virtual') && virtual && currentParams.virtual.enabled) {
    if (slides) virtual.slides = slides;
    virtual.update(true);
  }
  if (changedParams.includes('children') && slides && currentParams.loop) {
    loopNeedReloop = true;
  }
  if (needThumbsInit) {
    const initialized = thumbs.init();
    if (initialized) thumbs.update(true);
  }
  if (needControllerInit) {
    swiper.controller.control = currentParams.controller.control;
  }
  if (needPaginationInit) {
    if (swiper.isElement && (!paginationEl || typeof paginationEl === 'string')) {
      paginationEl = document.createElement('div');
      paginationEl.classList.add('swiper-pagination');
      paginationEl.part.add('pagination');
      swiper.el.appendChild(paginationEl);
    }
    if (paginationEl) currentParams.pagination.el = paginationEl;
    pagination.init();
    pagination.render();
    pagination.update();
  }
  if (needScrollbarInit) {
    if (swiper.isElement && (!scrollbarEl || typeof scrollbarEl === 'string')) {
      scrollbarEl = document.createElement('div');
      scrollbarEl.classList.add('swiper-scrollbar');
      scrollbarEl.part.add('scrollbar');
      swiper.el.appendChild(scrollbarEl);
    }
    if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;
    scrollbar.init();
    scrollbar.updateSize();
    scrollbar.setTranslate();
  }
  if (needNavigationInit) {
    if (swiper.isElement) {
      if (!nextEl || typeof nextEl === 'string') {
        nextEl = document.createElement('div');
        nextEl.classList.add('swiper-button-next');
        nextEl.innerHTML = swiper.hostEl.constructor.nextButtonSvg;
        nextEl.part.add('button-next');
        swiper.el.appendChild(nextEl);
      }
      if (!prevEl || typeof prevEl === 'string') {
        prevEl = document.createElement('div');
        prevEl.classList.add('swiper-button-prev');
        prevEl.innerHTML = swiper.hostEl.constructor.prevButtonSvg;
        prevEl.part.add('button-prev');
        swiper.el.appendChild(prevEl);
      }
    }
    if (nextEl) currentParams.navigation.nextEl = nextEl;
    if (prevEl) currentParams.navigation.prevEl = prevEl;
    navigation.init();
    navigation.update();
  }
  if (changedParams.includes('allowSlideNext')) {
    swiper.allowSlideNext = passedParams.allowSlideNext;
  }
  if (changedParams.includes('allowSlidePrev')) {
    swiper.allowSlidePrev = passedParams.allowSlidePrev;
  }
  if (changedParams.includes('direction')) {
    swiper.changeDirection(passedParams.direction, false);
  }
  if (loopNeedDestroy || loopNeedReloop) {
    swiper.loopDestroy();
  }
  if (loopNeedEnable || loopNeedReloop) {
    swiper.loopCreate();
  }
  swiper.update();
}

function getParams(obj, splitEvents) {
  if (obj === void 0) {
    obj = {};
  }
  if (splitEvents === void 0) {
    splitEvents = true;
  }
  const params = {
    on: {}
  };
  const events = {};
  const passedParams = {};
  extend(params, defaults);
  params._emitClasses = true;
  params.init = false;
  const rest = {};
  const allowedParams = paramsList.map(key => key.replace(/_/, ''));
  const plainObj = Object.assign({}, obj);
  Object.keys(plainObj).forEach(key => {
    if (typeof obj[key] === 'undefined') return;
    if (allowedParams.indexOf(key) >= 0) {
      if (isObject$1(obj[key])) {
        params[key] = {};
        passedParams[key] = {};
        extend(params[key], obj[key]);
        extend(passedParams[key], obj[key]);
      } else {
        params[key] = obj[key];
        passedParams[key] = obj[key];
      }
    } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === 'function') {
      if (splitEvents) {
        events[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      } else {
        params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      }
    } else {
      rest[key] = obj[key];
    }
  });
  ['navigation', 'pagination', 'scrollbar'].forEach(key => {
    if (params[key] === true) params[key] = {};
    if (params[key] === false) delete params[key];
  });
  return {
    params,
    passedParams,
    rest,
    events
  };
}

function mountSwiper(_ref, swiperParams) {
  let {
    el,
    nextEl,
    prevEl,
    paginationEl,
    scrollbarEl,
    swiper
  } = _ref;
  if (needsNavigation(swiperParams) && nextEl && prevEl) {
    swiper.params.navigation.nextEl = nextEl;
    swiper.originalParams.navigation.nextEl = nextEl;
    swiper.params.navigation.prevEl = prevEl;
    swiper.originalParams.navigation.prevEl = prevEl;
  }
  if (needsPagination(swiperParams) && paginationEl) {
    swiper.params.pagination.el = paginationEl;
    swiper.originalParams.pagination.el = paginationEl;
  }
  if (needsScrollbar(swiperParams) && scrollbarEl) {
    swiper.params.scrollbar.el = scrollbarEl;
    swiper.originalParams.scrollbar.el = scrollbarEl;
  }
  swiper.init(el);
}

function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
  const keys = [];
  if (!oldParams) return keys;
  const addKey = key => {
    if (keys.indexOf(key) < 0) keys.push(key);
  };
  if (children && oldChildren) {
    const oldChildrenKeys = oldChildren.map(getKey);
    const childrenKeys = children.map(getKey);
    if (oldChildrenKeys.join('') !== childrenKeys.join('')) addKey('children');
    if (oldChildren.length !== children.length) addKey('children');
  }
  const watchParams = paramsList.filter(key => key[0] === '_').map(key => key.replace(/_/, ''));
  watchParams.forEach(key => {
    if (key in swiperParams && key in oldParams) {
      if (isObject$1(swiperParams[key]) && isObject$1(oldParams[key])) {
        const newKeys = Object.keys(swiperParams[key]);
        const oldKeys = Object.keys(oldParams[key]);
        if (newKeys.length !== oldKeys.length) {
          addKey(key);
        } else {
          newKeys.forEach(newKey => {
            if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
              addKey(key);
            }
          });
          oldKeys.forEach(oldKey => {
            if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);
          });
        }
      } else if (swiperParams[key] !== oldParams[key]) {
        addKey(key);
      }
    }
  });
  return keys;
}

const updateOnVirtualData = swiper => {
  if (!swiper || swiper.destroyed || !swiper.params.virtual || swiper.params.virtual && !swiper.params.virtual.enabled) return;
  swiper.updateSlides();
  swiper.updateProgress();
  swiper.updateSlidesClasses();
  if (swiper.parallax && swiper.params.parallax && swiper.params.parallax.enabled) {
    swiper.parallax.setTranslate();
  }
};

/**
 * Swiper React 11.1.9
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * https://swiperjs.com
 *
 * Copyright 2014-2024 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: July 31, 2024
 */


function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function isChildSwiperSlide(child) {
  return child.type && child.type.displayName && child.type.displayName.includes('SwiperSlide');
}
function processChildren(c) {
  const slides = [];
  React__namespace.default.Children.toArray(c).forEach(child => {
    if (isChildSwiperSlide(child)) {
      slides.push(child);
    } else if (child.props && child.props.children) {
      processChildren(child.props.children).forEach(slide => slides.push(slide));
    }
  });
  return slides;
}
function getChildren(c) {
  const slides = [];
  const slots = {
    'container-start': [],
    'container-end': [],
    'wrapper-start': [],
    'wrapper-end': []
  };
  React__namespace.default.Children.toArray(c).forEach(child => {
    if (isChildSwiperSlide(child)) {
      slides.push(child);
    } else if (child.props && child.props.slot && slots[child.props.slot]) {
      slots[child.props.slot].push(child);
    } else if (child.props && child.props.children) {
      const foundSlides = processChildren(child.props.children);
      if (foundSlides.length > 0) {
        foundSlides.forEach(slide => slides.push(slide));
      } else {
        slots['container-end'].push(child);
      }
    } else {
      slots['container-end'].push(child);
    }
  });
  return {
    slides,
    slots
  };
}

function renderVirtual(swiper, slides, virtualData) {
  if (!virtualData) return null;
  const getSlideIndex = index => {
    let slideIndex = index;
    if (index < 0) {
      slideIndex = slides.length + index;
    } else if (slideIndex >= slides.length) {
      // eslint-disable-next-line
      slideIndex = slideIndex - slides.length;
    }
    return slideIndex;
  };
  const style = swiper.isHorizontal() ? {
    [swiper.rtlTranslate ? 'right' : 'left']: `${virtualData.offset}px`
  } : {
    top: `${virtualData.offset}px`
  };
  const {
    from,
    to
  } = virtualData;
  const loopFrom = swiper.params.loop ? -slides.length : 0;
  const loopTo = swiper.params.loop ? slides.length * 2 : slides.length;
  const slidesToRender = [];
  for (let i = loopFrom; i < loopTo; i += 1) {
    if (i >= from && i <= to) {
      slidesToRender.push(slides[getSlideIndex(i)]);
    }
  }
  return slidesToRender.map((child, index) => {
    return /*#__PURE__*/React__namespace.default.cloneElement(child, {
      swiper,
      style,
      key: child.props.virtualIndex || child.key || `slide-${index}`
    });
  });
}

function useIsomorphicLayoutEffect(callback, deps) {
  // eslint-disable-next-line
  if (typeof window === 'undefined') return React.useEffect(callback, deps);
  return React.useLayoutEffect(callback, deps);
}

const SwiperSlideContext = /*#__PURE__*/React.createContext(null);
const SwiperContext = /*#__PURE__*/React.createContext(null);

const Swiper = /*#__PURE__*/React.forwardRef(function (_temp, externalElRef) {
  let {
    className,
    tag: Tag = 'div',
    wrapperTag: WrapperTag = 'div',
    children,
    onSwiper,
    ...rest
  } = _temp === void 0 ? {} : _temp;
  let eventsAssigned = false;
  const [containerClasses, setContainerClasses] = React.useState('swiper');
  const [virtualData, setVirtualData] = React.useState(null);
  const [breakpointChanged, setBreakpointChanged] = React.useState(false);
  const initializedRef = React.useRef(false);
  const swiperElRef = React.useRef(null);
  const swiperRef = React.useRef(null);
  const oldPassedParamsRef = React.useRef(null);
  const oldSlides = React.useRef(null);
  const nextElRef = React.useRef(null);
  const prevElRef = React.useRef(null);
  const paginationElRef = React.useRef(null);
  const scrollbarElRef = React.useRef(null);
  const {
    params: swiperParams,
    passedParams,
    rest: restProps,
    events
  } = getParams(rest);
  const {
    slides,
    slots
  } = getChildren(children);
  const onBeforeBreakpoint = () => {
    setBreakpointChanged(!breakpointChanged);
  };
  Object.assign(swiperParams.on, {
    _containerClasses(swiper, classes) {
      setContainerClasses(classes);
    }
  });
  const initSwiper = () => {
    // init swiper
    Object.assign(swiperParams.on, events);
    eventsAssigned = true;
    const passParams = {
      ...swiperParams
    };
    delete passParams.wrapperClass;
    swiperRef.current = new Swiper$1(passParams);
    if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {
      swiperRef.current.virtual.slides = slides;
      const extendWith = {
        cache: false,
        slides,
        renderExternal: setVirtualData,
        renderExternalUpdate: false
      };
      extend(swiperRef.current.params.virtual, extendWith);
      extend(swiperRef.current.originalParams.virtual, extendWith);
    }
  };
  if (!swiperElRef.current) {
    initSwiper();
  }

  // Listen for breakpoints change
  if (swiperRef.current) {
    swiperRef.current.on('_beforeBreakpoint', onBeforeBreakpoint);
  }
  const attachEvents = () => {
    if (eventsAssigned || !events || !swiperRef.current) return;
    Object.keys(events).forEach(eventName => {
      swiperRef.current.on(eventName, events[eventName]);
    });
  };
  const detachEvents = () => {
    if (!events || !swiperRef.current) return;
    Object.keys(events).forEach(eventName => {
      swiperRef.current.off(eventName, events[eventName]);
    });
  };
  React.useEffect(() => {
    return () => {
      if (swiperRef.current) swiperRef.current.off('_beforeBreakpoint', onBeforeBreakpoint);
    };
  });

  // set initialized flag
  React.useEffect(() => {
    if (!initializedRef.current && swiperRef.current) {
      swiperRef.current.emitSlidesClasses();
      initializedRef.current = true;
    }
  });

  // mount swiper
  useIsomorphicLayoutEffect(() => {
    if (externalElRef) {
      externalElRef.current = swiperElRef.current;
    }
    if (!swiperElRef.current) return;
    if (swiperRef.current.destroyed) {
      initSwiper();
    }
    mountSwiper({
      el: swiperElRef.current,
      nextEl: nextElRef.current,
      prevEl: prevElRef.current,
      paginationEl: paginationElRef.current,
      scrollbarEl: scrollbarElRef.current,
      swiper: swiperRef.current
    }, swiperParams);
    if (onSwiper && !swiperRef.current.destroyed) onSwiper(swiperRef.current);
    // eslint-disable-next-line
    return () => {
      if (swiperRef.current && !swiperRef.current.destroyed) {
        swiperRef.current.destroy(true, false);
      }
    };
  }, []);

  // watch for params change
  useIsomorphicLayoutEffect(() => {
    attachEvents();
    const changedParams = getChangedParams(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, c => c.key);
    oldPassedParamsRef.current = passedParams;
    oldSlides.current = slides;
    if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {
      updateSwiper({
        swiper: swiperRef.current,
        slides,
        passedParams,
        changedParams,
        nextEl: nextElRef.current,
        prevEl: prevElRef.current,
        scrollbarEl: scrollbarElRef.current,
        paginationEl: paginationElRef.current
      });
    }
    return () => {
      detachEvents();
    };
  });

  // update on virtual update
  useIsomorphicLayoutEffect(() => {
    updateOnVirtualData(swiperRef.current);
  }, [virtualData]);

  // bypass swiper instance to slides
  function renderSlides() {
    if (swiperParams.virtual) {
      return renderVirtual(swiperRef.current, slides, virtualData);
    }
    return slides.map((child, index) => {
      return /*#__PURE__*/React__namespace.default.cloneElement(child, {
        swiper: swiperRef.current,
        swiperSlideIndex: index
      });
    });
  }
  return /*#__PURE__*/React__namespace.default.createElement(Tag, _extends({
    ref: swiperElRef,
    className: uniqueClasses(`${containerClasses}${className ? ` ${className}` : ''}`)
  }, restProps), /*#__PURE__*/React__namespace.default.createElement(SwiperContext.Provider, {
    value: swiperRef.current
  }, slots['container-start'], /*#__PURE__*/React__namespace.default.createElement(WrapperTag, {
    className: wrapperClass(swiperParams.wrapperClass)
  }, slots['wrapper-start'], renderSlides(), slots['wrapper-end']), needsNavigation(swiperParams) && /*#__PURE__*/React__namespace.default.createElement(React__namespace.default.Fragment, null, /*#__PURE__*/React__namespace.default.createElement("div", {
    ref: prevElRef,
    className: "swiper-button-prev"
  }), /*#__PURE__*/React__namespace.default.createElement("div", {
    ref: nextElRef,
    className: "swiper-button-next"
  })), needsScrollbar(swiperParams) && /*#__PURE__*/React__namespace.default.createElement("div", {
    ref: scrollbarElRef,
    className: "swiper-scrollbar"
  }), needsPagination(swiperParams) && /*#__PURE__*/React__namespace.default.createElement("div", {
    ref: paginationElRef,
    className: "swiper-pagination"
  }), slots['container-end']));
});
Swiper.displayName = 'Swiper';

const SwiperSlide = /*#__PURE__*/React.forwardRef(function (_temp, externalRef) {
  let {
    tag: Tag = 'div',
    children,
    className = '',
    swiper,
    zoom,
    lazy,
    virtualIndex,
    swiperSlideIndex,
    ...rest
  } = _temp === void 0 ? {} : _temp;
  const slideElRef = React.useRef(null);
  const [slideClasses, setSlideClasses] = React.useState('swiper-slide');
  const [lazyLoaded, setLazyLoaded] = React.useState(false);
  function updateClasses(_s, el, classNames) {
    if (el === slideElRef.current) {
      setSlideClasses(classNames);
    }
  }
  useIsomorphicLayoutEffect(() => {
    if (typeof swiperSlideIndex !== 'undefined') {
      slideElRef.current.swiperSlideIndex = swiperSlideIndex;
    }
    if (externalRef) {
      externalRef.current = slideElRef.current;
    }
    if (!slideElRef.current || !swiper) {
      return;
    }
    if (swiper.destroyed) {
      if (slideClasses !== 'swiper-slide') {
        setSlideClasses('swiper-slide');
      }
      return;
    }
    swiper.on('_slideClass', updateClasses);
    // eslint-disable-next-line
    return () => {
      if (!swiper) return;
      swiper.off('_slideClass', updateClasses);
    };
  });
  useIsomorphicLayoutEffect(() => {
    if (swiper && slideElRef.current && !swiper.destroyed) {
      setSlideClasses(swiper.getSlideClasses(slideElRef.current));
    }
  }, [swiper]);
  const slideData = {
    isActive: slideClasses.indexOf('swiper-slide-active') >= 0,
    isVisible: slideClasses.indexOf('swiper-slide-visible') >= 0,
    isPrev: slideClasses.indexOf('swiper-slide-prev') >= 0,
    isNext: slideClasses.indexOf('swiper-slide-next') >= 0
  };
  const renderChildren = () => {
    return typeof children === 'function' ? children(slideData) : children;
  };
  const onLoad = () => {
    setLazyLoaded(true);
  };
  return /*#__PURE__*/React__namespace.default.createElement(Tag, _extends({
    ref: slideElRef,
    className: uniqueClasses(`${slideClasses}${className ? ` ${className}` : ''}`),
    "data-swiper-slide-index": virtualIndex,
    onLoad: onLoad
  }, rest), zoom && /*#__PURE__*/React__namespace.default.createElement(SwiperSlideContext.Provider, {
    value: slideData
  }, /*#__PURE__*/React__namespace.default.createElement("div", {
    className: "swiper-zoom-container",
    "data-swiper-zoom": typeof zoom === 'number' ? zoom : undefined
  }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/React__namespace.default.createElement("div", {
    className: "swiper-lazy-preloader"
  }))), !zoom && /*#__PURE__*/React__namespace.default.createElement(SwiperSlideContext.Provider, {
    value: slideData
  }, renderChildren(), lazy && !lazyLoaded && /*#__PURE__*/React__namespace.default.createElement("div", {
    className: "swiper-lazy-preloader"
  })));
});
SwiperSlide.displayName = 'SwiperSlide';

const container = {
    hidden: { opacity: 0, y: 50 },
    visible: {
        opacity: 1,
        y: 0,
        transition: {
            delayChildren: 0.1,
            staggerChildren: 0.1
        }
    },
    exit: {
        opacity: 0,
        y: 50,
        transition: {
            duration: 0.2,
            ease: 'easeInOut'
        }
    }
};
function QuestionsMobile({ questions, handlePick, disableClick = false }) {
    return (jsxRuntime.jsx(framerMotion.motion.div, { className: "w-full shrink-0 overflow-hidden relative pt-1", variants: container, initial: "hidden", animate: "visible", exit: "exit", children: jsxRuntime.jsx(Swiper, { spaceBetween: 8, freeMode: true, touchRatio: 1, slidesPerView: "auto", centeredSlides: true, className: "flex h-full w-full", children: questions.map(r => (jsxRuntime.jsx(SwiperSlide, { style: {
                    width: 'calc(100% - 32px)',
                    flexShrink: 0
                }, children: jsxRuntime.jsx(framerMotion.motion.div, { className: "h-full", children: jsxRuntime.jsx(QuestionItem$1, { question: r, handlePickQuestion: handlePick, isMobile: true, disableClick: disableClick }) }) }, r))) }) }));
}

function Editor({ editorContainerRef, editorAnchorRef, textareaRef, scrollLayoutToTop, showMobileDetail }) {
    const sensors = useSensors();
    const isVisitor = useUserStore(state => state.isVisitor);
    const user = useUserStore(state => state.user);
    const { type, interactionDisabled, audioDisabled = false, textDisabled = false, disabledReason, entityInfo, showInteractionCostEnergy, atBottom, imgGenerator, terminatable = true } = React.useContext(StaticContext);
    const { sendTextMessage, sendAudioMessage, sending, interacting, showTerminate, draftMessage, setDraftMessage, terminate, dragMaskVisible, inputMode, setInputMode, file, questions, terminating } = React.useContext(MessageContext);
    const useElementWidth = (ref) => {
        const [width, setWidth] = React.useState(0);
        React.useEffect(() => {
            const observer = new ResizeObserver(entries => {
                for (const entry of entries) {
                    setWidth(entry.contentRect.width);
                }
            });
            if (ref.current) {
                observer.observe(ref.current);
            }
            return () => {
                if (ref.current) {
                    observer.unobserve(ref.current);
                }
            };
        }, [ref]);
        return width;
    };
    const width = useElementWidth(editorAnchorRef);
    const { uploadedFiles } = file || {};
    const { id, name, energyPerChat, energyPerLevelByPass, maxTokens } = entityInfo;
    const isMobile = useGlobalStore(state => state.isMobile);
    const switchToAudioInput = () => {
        setInputMode === null || setInputMode === void 0 ? void 0 : setInputMode('AUDIO');
        scrollLayoutToTop === null || scrollLayoutToTop === void 0 ? void 0 : scrollLayoutToTop();
    };
    const exitAudioInput = () => {
        setInputMode === null || setInputMode === void 0 ? void 0 : setInputMode('TEXT');
    };
    const [text, setText] = React.useState(draftMessage !== null && draftMessage !== void 0 ? draftMessage : '');
    const [tokenLen, setTokenLen] = React.useState(0);
    const energyCost = React.useMemo(() => {
        var _a;
        if (!(energyPerLevelByPass === null || energyPerLevelByPass === void 0 ? void 0 : energyPerLevelByPass.length))
            return energyPerChat;
        if (tokenLen > (maxTokens || 1500)) {
            return energyPerLevelByPass[((_a = energyPerLevelByPass.length) !== null && _a !== void 0 ? _a : 0) - 1];
        }
        return energyPerLevelByPass[Math.ceil((tokenLen || 1) / 1500) - 1] || 1;
    }, [energyPerChat, energyPerLevelByPass, maxTokens, tokenLen]);
    const updateTokenLen = async (value) => {
        getTokenCount(value).then(res => setTokenLen(res));
    };
    const sendTextHandler = React.useCallback(() => {
        scrollLayoutToTop === null || scrollLayoutToTop === void 0 ? void 0 : scrollLayoutToTop();
        if (type === 'bot') {
            sensors === null || sensors === void 0 ? void 0 : sensors.track('UserSendMessage', {
                message_type: 'text',
                bot_id: id,
                bot_name: name,
                keyboard_behavior: inputMode,
                chat_platform: 'web2',
                bot_battery_cost: energyCost,
                token_count: tokenLen,
                user_membership_type: isVisitor ? '0' : (user === null || user === void 0 ? void 0 : user.isGenesisPasscard) || (user === null || user === void 0 ? void 0 : user.isPasscard) ? '3' : `${user === null || user === void 0 ? void 0 : user.level}`
            });
        }
        sendTextMessage(text, uploadedFiles, imgGenerator ? ConversationScenario.CONVERSATION_SCENARIO_BOT_GENERATION : undefined);
        setText('');
    }, [
        energyCost,
        id,
        imgGenerator,
        inputMode,
        isVisitor,
        name,
        scrollLayoutToTop,
        sendTextMessage,
        sensors,
        text,
        tokenLen,
        type,
        uploadedFiles,
        user === null || user === void 0 ? void 0 : user.isGenesisPasscard,
        user === null || user === void 0 ? void 0 : user.isPasscard,
        user === null || user === void 0 ? void 0 : user.level
    ]);
    const sendAudioHandler = React.useCallback((audioBlob, mimeType) => {
        sendAudioMessage(audioBlob, mimeType);
        if (type === 'bot') {
            sensors === null || sensors === void 0 ? void 0 : sensors.track('UserSendMessage', {
                message_type: 'voice',
                bot_id: id,
                bot_name: name,
                keyboard_behavior: 'DirectInput',
                chat_platform: 'web2',
                bot_battery_cost: energyPerChat,
                user_membership_type: isVisitor ? '0' : (user === null || user === void 0 ? void 0 : user.isGenesisPasscard) || (user === null || user === void 0 ? void 0 : user.isPasscard) ? '3' : `${user === null || user === void 0 ? void 0 : user.level}`
            });
        }
    }, [
        energyPerChat,
        id,
        isVisitor,
        name,
        sendAudioMessage,
        sensors,
        type,
        user === null || user === void 0 ? void 0 : user.isGenesisPasscard,
        user === null || user === void 0 ? void 0 : user.isPasscard,
        user === null || user === void 0 ? void 0 : user.level
    ]);
    React.useEffect(() => {
        setDraftMessage(text);
        updateTokenLen(text);
    }, [text]);
    const fileAlert = useNewChatStore(state => state.fileUpload.alert);
    const onPickQuestion = React.useCallback((question) => {
        scrollLayoutToTop === null || scrollLayoutToTop === void 0 ? void 0 : scrollLayoutToTop();
        sendTextMessage(question);
    }, [scrollLayoutToTop, sendTextMessage]);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [atBottom &&
                !!(questions === null || questions === void 0 ? void 0 : questions.length) &&
                (!isMobile ? (jsxRuntime.jsx(Questions, { questions: questions, handlePick: onPickQuestion, disableClick: interactionDisabled || sending || interacting })) : (jsxRuntime.jsx(QuestionsMobile, { questions: questions, handlePick: onPickQuestion, disableClick: interactionDisabled || sending || interacting }))), jsxRuntime.jsx(Separator, { className: "w-full bg-[var(--border)] hidden md:block relative" }), jsxRuntime.jsx("div", { ref: editorAnchorRef, className: "shrink-0 h-fit w-full", children: jsxRuntime.jsxs("div", { ref: editorContainerRef, className: "px-0 md:px-6 py-3 md:py-4 flex flex-col gap-2 md:gap-1 h-fit shrink-0 top-2 right-[9px] z-10 bg-surface-default md:rounded-b-3xl", style: {
                        width: width || '100%'
                    }, children: [dragMaskVisible && jsxRuntime.jsx(DragMask, {}), fileAlert.visible && jsxRuntime.jsx(SaveTipModal$1, { maxSize: 50 }), jsxRuntime.jsxs("div", { className: "relative flex flex-col gap-1", children: [terminatable && showTerminate && (jsxRuntime.jsx("div", { className: "flex justify-center absolute -top-[60px] md:-top-[78px] left-1/2 -translate-x-1/2 z-20", children: jsxRuntime.jsx(Termination, { onTerminate: () => terminate === null || terminate === void 0 ? void 0 : terminate(), loading: terminating }) })), inputMode === 'TEXT' &&
                                    (!isMobile ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(TextInput, { className: "w-full min-h-9 max-h-[156px]", onSend: sendTextHandler, sendDisabled: interactionDisabled || sending || interacting, autoFocus: true, value: text, ref: textareaRef, onChange: e => setText(e.target.value), disabled: interactionDisabled || textDisabled, disabledReason: disabledReason, onFocus: () => {
                                                    scrollLayoutToTop === null || scrollLayoutToTop === void 0 ? void 0 : scrollLayoutToTop();
                                                } }), jsxRuntime.jsx(Attachments, {}), jsxRuntime.jsx("div", { className: "w-full flex items-center justify-between", children: jsxRuntime.jsxs("div", { className: "flex w-full justify-between items-center", children: [jsxRuntime.jsxs("div", { className: "flex gap-1", children: [jsxRuntime.jsx(MenuList$1, {}), jsxRuntime.jsx(FileUploader, { disabled: interactionDisabled })] }), text || uploadedFiles ? (jsxRuntime.jsx(SendButton, { loading: sending || interacting, disabled: interactionDisabled || sending || interacting, onSend: sendTextHandler, energyCost: energyCost, showEnergyCostIcon: showInteractionCostEnergy })) : (jsxRuntime.jsx(AudioInput, { onStart: switchToAudioInput, disabled: interactionDisabled || audioDisabled }))] }) })] })) : (jsxRuntime.jsx(MobileTextInput, { onSend: sendTextHandler, value: text, ref: textareaRef, onChange: e => setText(e.target.value), sendDisabled: interactionDisabled || sending || interacting, disabled: interactionDisabled || textDisabled, disabledReason: disabledReason, showMobileDetail: showMobileDetail, audioInputSlot: jsxRuntime.jsxs("div", { className: "flex gap-1 items-center", children: [jsxRuntime.jsx(MenuList$1, {}), jsxRuntime.jsx(AudioInput, { onStart: switchToAudioInput, disabled: interactionDisabled || audioDisabled })] }), loading: sending || interacting, interactingDisabled: interactionDisabled || sending || interacting, energyCost: energyCost, showEnergyCostIcon: showInteractionCostEnergy }))), inputMode === 'AUDIO' && (jsxRuntime.jsx(AudioRecorder, { exitAudioInput: exitAudioInput, onSend: sendAudioHandler, interacting: sending, disabled: interactionDisabled || audioDisabled, scrollLayoutToTop: scrollLayoutToTop }))] })] }) })] }));
}

function ShareSelectAll() {
    const t = nextIntl.useTranslations('chat');
    const { share, setEditorMode } = React.useContext(MessageContext);
    const { allChecked, checkAllHandler } = share || {};
    return (jsxRuntime.jsxs("div", { className: "w-full h-14 px-4 md:px-0 flex justify-between items-center md:justify-end shrink-0 absolute top-0 right-0 md:right-6 z-20 bg-surface-default md:bg-transparent", children: [jsxRuntime.jsx("span", { className: "md:hidden", children: jsxRuntime.jsx(IconButton, { size: "md", variant: "ghost", icon: ForwardRef$j, onClick: () => setEditorMode === null || setEditorMode === void 0 ? void 0 : setEditorMode('NORMAL') }) }), jsxRuntime.jsx(Button$1, { variant: "outline", color: "brand", size: "md", className: "bg-surface-default", onClick: () => {
                    checkAllHandler === null || checkAllHandler === void 0 ? void 0 : checkAllHandler();
                }, children: t('select_all') })] }));
}

const DisplayContext = React.createContext({
    actions: [],
    displayMode: 'NORMAL',
    setDisplayMode: () => { },
    latest: false,
    totalMessages: 1,
    isTextDisplayException: false
});
const useDisplayContext = () => {
    return React.useContext(DisplayContext);
};
const DisplayProvider = props => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const { message, latest, children } = props;
    const energy = useUserStore(state => state.energy);
    const { chatSetting, type, entityInfo, entitySetting, messageShareAvailable = true, feedbackAvailable = true, globalContextMenuDisabled, } = React.useContext(StaticContext);
    const { id } = entityInfo;
    const { exceptionsForTextDisplay, messageList } = React.useContext(MessageContext);
    const totalMessages = ((_b = (_a = message === null || message === void 0 ? void 0 : message.regeneratedMessages) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + 1;
    const [currentMessageIndex, setCurrentMessageIndex] = React.useState(((_d = (_c = message === null || message === void 0 ? void 0 : message.regeneratedMessages) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) + 1);
    const prevMessageIndex = reactUse.usePrevious(currentMessageIndex);
    const isTextDisplayException = React.useMemo(() => {
        var _a;
        return ((_a = exceptionsForTextDisplay === null || exceptionsForTextDisplay === void 0 ? void 0 : exceptionsForTextDisplay[`${type}-${id}`]) !== null && _a !== void 0 ? _a : []).includes(message === null || message === void 0 ? void 0 : message.id);
    }, [exceptionsForTextDisplay, id, message === null || message === void 0 ? void 0 : message.id, type]);
    const currentDisplayMessage = React.useMemo(() => {
        var _a;
        if (totalMessages === 1) {
            return message;
        }
        if (currentMessageIndex === totalMessages) {
            return message;
        }
        return (_a = message === null || message === void 0 ? void 0 : message.regeneratedMessages) === null || _a === void 0 ? void 0 : _a.at(-(currentMessageIndex !== null && currentMessageIndex !== void 0 ? currentMessageIndex : 1));
    }, [currentMessageIndex, message, totalMessages]);
    const replyOriginMessage = React.useMemo(() => {
        if (message === null || message === void 0 ? void 0 : message.replyId) {
            const originMsg = messageList.find(item => item.id === message.replyId);
            return originMsg;
        }
    }, [message === null || message === void 0 ? void 0 : message.replyId, messageList]);
    const contextMenuDisabled = globalContextMenuDisabled ||
        !(((message === null || message === void 0 ? void 0 : message.status) === 'DONE' &&
            (((_e = message === null || message === void 0 ? void 0 : message.asyncJobInfo) === null || _e === void 0 ? void 0 : _e.jobId)
                ? ((_f = message === null || message === void 0 ? void 0 : message.asyncJobInfo) === null || _f === void 0 ? void 0 : _f.status) === EmbedObjStatus$1.DONE
                : ((_g = message === null || message === void 0 ? void 0 : message.imageGenMessageResponse) === null || _g === void 0 ? void 0 : _g.jobId)
                    ? ((_h = message === null || message === void 0 ? void 0 : message.imageGenMessageResponse) === null || _h === void 0 ? void 0 : _h.genStatus) === ImageGenStatus.DONE
                    : true)) ||
            ((message === null || message === void 0 ? void 0 : message.status) === 'CANCELED' && (message === null || message === void 0 ? void 0 : message.type) !== 'PENDING_FOR_RESPONSE') ||
            ((message === null || message === void 0 ? void 0 : message.status) === 'PROCESSING' &&
                (message.type === 'TEXT' || message.type === 'VOICE' || message.type === 'BUTTON_INTERACTION')));
    const contextMenuItems = React.useMemo(() => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const feedbackItem = (message === null || message === void 0 ? void 0 : message.source) === 'OTHER' && feedbackAvailable ? [MenuActionType.Feedback] : [];
        const editItem = (message === null || message === void 0 ? void 0 : message.source) === 'OTHER' &&
            ((message === null || message === void 0 ? void 0 : message.status) === 'DONE' || (message === null || message === void 0 ? void 0 : message.status) === 'CANCELED') &&
            latest &&
            ((_a = message === null || message === void 0 ? void 0 : message.extraInfo) === null || _a === void 0 ? void 0 : _a.canEdit) &&
            currentMessageIndex === totalMessages &&
            (((_b = chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn) !== null && _b !== void 0 ? _b : true) ||
                ((_c = exceptionsForTextDisplay === null || exceptionsForTextDisplay === void 0 ? void 0 : exceptionsForTextDisplay[`${type}-${id}`]) !== null && _c !== void 0 ? _c : []).includes(message === null || message === void 0 ? void 0 : message.id))
            ? [MenuActionType.Edit]
            : [];
        const regenItem = (message === null || message === void 0 ? void 0 : message.source) === 'OTHER' &&
            latest &&
            ((message === null || message === void 0 ? void 0 : message.status) === 'DONE' || (message === null || message === void 0 ? void 0 : message.status) === 'CANCELED') &&
            ((_d = message === null || message === void 0 ? void 0 : message.extraInfo) === null || _d === void 0 ? void 0 : _d.canRegenerate) &&
            energy >= ((_e = message === null || message === void 0 ? void 0 : message.extraInfo) === null || _e === void 0 ? void 0 : _e.consumeEnergy) &&
            replyOriginMessage
            ? [MenuActionType.Regenerate]
            : [];
        const copyMenuItem = ((_f = chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn) !== null && _f !== void 0 ? _f : true) ||
            (!(chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn) && ((_g = exceptionsForTextDisplay === null || exceptionsForTextDisplay === void 0 ? void 0 : exceptionsForTextDisplay[`${type}-${id}`]) !== null && _g !== void 0 ? _g : []).includes(message === null || message === void 0 ? void 0 : message.id))
            ? [MenuActionType.Copy_Message]
            : [];
        const selectTextItem = ((_h = chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn) !== null && _h !== void 0 ? _h : true) ||
            (!(chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn) && ((_j = exceptionsForTextDisplay === null || exceptionsForTextDisplay === void 0 ? void 0 : exceptionsForTextDisplay[`${type}-${id}`]) !== null && _j !== void 0 ? _j : []).includes(message === null || message === void 0 ? void 0 : message.id))
            ? [MenuActionType.Select_Text]
            : [];
        const shareMenuItem = messageShareAvailable ? [MenuActionType.Share] : [];
        const voiceMenuItem = (entitySetting === null || entitySetting === void 0 ? void 0 : entitySetting.outputVoice) && (chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isAudioOn) && (message === null || message === void 0 ? void 0 : message.audioUrl) ? [MenuActionType.Download_Voice] : [];
        const textExceptionItem = (message === null || message === void 0 ? void 0 : message.source) === 'OTHER' &&
            !((_k = chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn) !== null && _k !== void 0 ? _k : true) &&
            !((_l = exceptionsForTextDisplay === null || exceptionsForTextDisplay === void 0 ? void 0 : exceptionsForTextDisplay[`${type}-${id}`]) !== null && _l !== void 0 ? _l : []).includes(message === null || message === void 0 ? void 0 : message.id)
            ? [MenuActionType.Show_Text]
            : [];
        const translationItem = (message === null || message === void 0 ? void 0 : message.source) === 'OTHER' && ((_m = chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranslationOn) !== null && _m !== void 0 ? _m : false) ? [MenuActionType.Translate] : [];
        const deleteMenuItem = [MenuActionType.Delete];
        return [
            ...feedbackItem,
            ...(feedbackItem.length ? [MenuActionType.Divider] : []),
            ...copyMenuItem,
            ...selectTextItem,
            ...editItem,
            ...regenItem,
            ...voiceMenuItem,
            ...(copyMenuItem.length + voiceMenuItem.length > 0 ? [MenuActionType.Divider] : []),
            ...textExceptionItem,
            ...translationItem,
            ...shareMenuItem,
            ...(textExceptionItem.length + translationItem.length + shareMenuItem.length > 0 ? [MenuActionType.Divider] : []),
            ...deleteMenuItem
        ];
    }, [
        chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isAudioOn,
        chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn,
        chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranslationOn,
        currentMessageIndex,
        energy,
        entitySetting === null || entitySetting === void 0 ? void 0 : entitySetting.outputVoice,
        exceptionsForTextDisplay,
        feedbackAvailable,
        id,
        latest,
        message === null || message === void 0 ? void 0 : message.audioUrl,
        (_j = message === null || message === void 0 ? void 0 : message.extraInfo) === null || _j === void 0 ? void 0 : _j.canEdit,
        (_k = message === null || message === void 0 ? void 0 : message.extraInfo) === null || _k === void 0 ? void 0 : _k.canRegenerate,
        (_l = message === null || message === void 0 ? void 0 : message.extraInfo) === null || _l === void 0 ? void 0 : _l.consumeEnergy,
        message === null || message === void 0 ? void 0 : message.id,
        message === null || message === void 0 ? void 0 : message.source,
        message === null || message === void 0 ? void 0 : message.status,
        messageShareAvailable,
        replyOriginMessage,
        totalMessages,
        type
    ]);
    const [displayMode, setDisplayMode] = React.useState('NORMAL');
    const [publishState, setPublishState] = React.useState('info');
    const [popupConfirmVisible, setPopupConfirmVisible] = reactUse.useBoolean(false);
    const [popupConfirmItem, setPopupConfirmItem] = React.useState(undefined);
    const [deleteConfirming, setDeleteConfirming] = reactUse.useBoolean(false);
    const [selectTextVisible, setSelectTextVisible] = reactUse.useBoolean(false);
    const [audioPlayProgress, setAudioPlayProgress] = React.useState(0);
    const displayContextParams = React.useMemo(() => {
        return {
            message,
            displayMessage: currentDisplayMessage,
            contextMenuDisabled,
            actions: contextMenuItems,
            displayMode,
            setDisplayMode,
            latest,
            publishState,
            setPublishState,
            popupConfirmItem,
            setPopupConfirmItem,
            popupConfirmVisible,
            setPopupConfirmVisible,
            deleteConfirming,
            setDeleteConfirming,
            selectTextVisible,
            setSelectTextVisible,
            audioPlayProgress,
            setAudioPlayProgress,
            replyOriginMessage,
            totalMessages,
            currentMessageIndex,
            prevMessageIndex,
            setCurrentMessageIndex,
            isTextDisplayException
        };
    }, [
        audioPlayProgress,
        contextMenuDisabled,
        contextMenuItems,
        currentDisplayMessage,
        currentMessageIndex,
        deleteConfirming,
        displayMode,
        isTextDisplayException,
        latest,
        message,
        popupConfirmItem,
        popupConfirmVisible,
        prevMessageIndex,
        publishState,
        replyOriginMessage,
        selectTextVisible,
        setDeleteConfirming,
        setPopupConfirmVisible,
        setSelectTextVisible,
        totalMessages
    ]);
    React.useEffect(() => {
        var _a, _b;
        setCurrentMessageIndex(((_b = (_a = message === null || message === void 0 ? void 0 : message.regeneratedMessages) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + 1);
    }, [(_m = message === null || message === void 0 ? void 0 : message.regeneratedMessages) === null || _m === void 0 ? void 0 : _m.length]);
    return jsxRuntime.jsx(DisplayContext.Provider, { value: displayContextParams, children: children });
};

const Header = ({ loading }) => {
    if (loading) {
        return (jsxRuntime.jsx("div", { className: "w-full flex justify-center", children: jsxRuntime.jsx(Spinner, { color: "brand" }) }));
    }
    return null;
};

const roomChatBot = `/chat/${TRANSLATOR_BOT_ID}`;
function useButtonActions(message, clearMemory, partialUpdateMessage) {
    nextIntl.useTranslations('chat');
    const router = navigation.useRouter();
    React.useEffect(() => {
        router.prefetch(roomChatBot);
    }, []);
    const toggleLoginModal = useGlobalStore(state => state.toggleLoginModal);
    const onOpenLogin = () => toggleLoginModal(true);
    const onCreateRoom = () => {
        router.push(roomChatBot);
    };
    const onLoginAndCreateRoom = () => {
        router.push(roomChatBot);
        requestAnimationFrame(() => {
            onOpenLogin();
        });
    };
    const onMarked = async () => {
        try {
            const { success } = await markMessageAsHandled(message.id);
            if (success) {
                partialUpdateMessage === null || partialUpdateMessage === void 0 ? void 0 : partialUpdateMessage(message.id, {
                    handled: true
                });
            }
        }
        catch (e) {
            console.error(e);
        }
    };
    const onRemoveAndClearMemory = async () => {
        try {
            const { success } = await setMessageHandled(message.id);
            if (success) {
                partialUpdateMessage === null || partialUpdateMessage === void 0 ? void 0 : partialUpdateMessage(message.id, {
                    handled: true
                });
                clearMemory === null || clearMemory === void 0 ? void 0 : clearMemory();
            }
        }
        catch (e) {
            console.error(e);
        }
    };
    return {
        onOpenLogin,
        onCreateRoom,
        onLoginAndCreateRoom,
        onMarked,
        onRemoveAndClearMemory
    };
}

function AlertMessage() {
    var _a;
    const { clearMemory, partialUpdateMessage } = React.useContext(MessageContext);
    const { message } = useDisplayContext();
    const isVisitor = useUserStore(state => state.isVisitor);
    const t = nextIntl.useTranslations('chat');
    const { onOpenLogin, onCreateRoom, onLoginAndCreateRoom, onMarked, onRemoveAndClearMemory } = useButtonActions(message, clearMemory, partialUpdateMessage);
    const alertMap = {
        ROOM_CLOSED: {
            text: t('room.room_close'),
            variant: 'warning',
            textClassName: 'w-full text-center'
        },
        OTHER_SIDE_LEFT: {
            text: t('room.other_side_left', {
                user: message === null || message === void 0 ? void 0 : message.text
            }),
            buttons: [
                {
                    children: isVisitor !== VisitorEnum.NO ? t('room.login_to_create') : t('room.create'),
                    color: 'brand',
                    onClick: isVisitor !== VisitorEnum.NO ? onLoginAndCreateRoom : onCreateRoom
                }
            ],
            variant: 'info'
        },
        OTHER_SIDE_NO_ENOUGH_ENERGY: {
            text: t('room.other_side_no_enough_energy'),
            buttons: [
                {
                    children: t('login_register'),
                    color: 'warning',
                    onClick: onOpenLogin
                }
            ],
            variant: 'warning'
        },
        PROMPT_UPDATED: {
            text: t('prompt_updated_tip'),
            buttons: [
                {
                    children: t('clear'),
                    color: 'warning',
                    onClick: onRemoveAndClearMemory
                },
                {
                    children: t('ignore'),
                    color: 'warning',
                    variant: 'outline',
                    onClick: onMarked
                }
            ],
            variant: 'warning'
        },
        RESET: {
            text: t('memory_cleared_tip'),
            variant: 'info'
        }
    };
    const alertData = alertMap[message === null || message === void 0 ? void 0 : message.type];
    return (jsxRuntime.jsx("div", { className: "w-full px-0 md:pl-[38px]", children: (message === null || message === void 0 ? void 0 : message.customRender) ? (message.customRender) : (message === null || message === void 0 ? void 0 : message.msgDisplayType) === 'INFO' ? (jsxRuntime.jsxs("div", { className: "w-full overflow-hidden flex gap-5 items-center", children: [jsxRuntime.jsx(Separator, { className: "grow inline-block w-auto" }), jsxRuntime.jsx(Text, { className: "w-fit shrink-0", color: "subtle", size: "sm", children: (message === null || message === void 0 ? void 0 : message.text) || alertData.text }), jsxRuntime.jsx(Separator, { className: "grow inline-block w-auto" })] })) : (jsxRuntime.jsxs(Alert, { variant: alertData === null || alertData === void 0 ? void 0 : alertData.variant, className: "flex-col md:flex-col lg:flex-row", children: [jsxRuntime.jsx(AlertDescription, { className: alertData === null || alertData === void 0 ? void 0 : alertData.textClassName, children: jsxRuntime.jsxs("div", { className: "flex gap-[6px]", children: [(alertData === null || alertData === void 0 ? void 0 : alertData.variant) === 'error' ? (jsxRuntime.jsx(ForwardRef$D, { className: "hidden md:block shrink-0 size-6 text-icon-critical" })) : (jsxRuntime.jsx(ForwardRef$U, { className: clsx__default.default('hidden md:block shrink-0 size-6', (alertData === null || alertData === void 0 ? void 0 : alertData.variant) === 'info' ? 'text-icon-brand' : 'text-icon-warning') })), jsxRuntime.jsx(Text, { children: alertData === null || alertData === void 0 ? void 0 : alertData.text })] }) }), ((_a = alertData === null || alertData === void 0 ? void 0 : alertData.buttons) === null || _a === void 0 ? void 0 : _a.length) ? (jsxRuntime.jsx("div", { className: "w-full gap-x-2 md:w-auto flex justify-center self-end lg:self-auto", children: alertData.buttons.map((item, index) => (jsxRuntime.jsx(Button$1, { className: "w-full px-4 flex-1 md:w-full", color: item.color, size: "md", variant: item.variant, onClick: item === null || item === void 0 ? void 0 : item.onClick, children: item === null || item === void 0 ? void 0 : item.children }, index))) })) : null] })) }));
}

function useDownload() {
    const [downloading, setDownloading] = React.useState(false);
    const { warning } = useNotification();
    const isMobile = useGlobalStore(state => state.isMobile);
    const t = nextIntl.useTranslations('common');
    const gT = nextIntl.useTranslations();
    const params = navigation.useParams();
    const botId = params.botId;
    const onDownload = React.useCallback(async (filePath, fileName, successCb) => {
        setDownloading(true);
        fetch(filePath)
            .then(response => response.blob())
            .then(blob => {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            setTimeout(() => {
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }, 1000);
            successCb === null || successCb === void 0 ? void 0 : successCb();
        })
            .catch(e => {
            console.error(e);
            warning({
                content: t('download_failed')
            });
        })
            .finally(() => {
            setDownloading(false);
        });
    }, [warning]);
    const onImageDownload = React.useCallback(async (filePath, fileName, successCb) => {
        const isAnimatedImage = filePath.endsWith('.gif') || filePath.endsWith('.webp');
        if (isAnimatedImage) {
            onDownload(filePath, fileName, successCb);
        }
        else {
            setDownloading(true);
            let shareCode = '';
            if (botId) {
                shareCode = await getBotSharingCode(`${botId}`);
            }
            const logoUrl = 'https://www.myshellstatic.com/image/website/logo/logotext.png';
            try {
                const mainImg = await loadImage(filePath);
                const logoImg = await loadImage(logoUrl);
                const currentUrl = new URL(window.location.href);
                if (shareCode) {
                    currentUrl.searchParams.set('shareCode', shareCode);
                    currentUrl.searchParams.set('bot', '1');
                    currentUrl.searchParams.set('utm_channel', 'referral');
                    currentUrl.searchParams.set('utm_source', 'imageshare');
                    currentUrl.searchParams.set('utm_medium', 'qrcode');
                    currentUrl.searchParams.set('utm_campaign', shareCode);
                }
                const url = currentUrl.toString();
                const qrCodeDataUrl = await QRCode__default.default.toDataURL(url);
                const qrCodeImg = await loadImage(qrCodeDataUrl);
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    throw new Error('Could not get canvas context');
                }
                const canvasWidth = mainImg.width;
                const bottomHeight = Math.max(canvasWidth * 0.1131, 62);
                const canvasHeight = mainImg.height + bottomHeight;
                const logoWidth = Math.max(canvasWidth * 0.1689, 92);
                const logoHeight = Math.max(canvasWidth * 0.0365, 20);
                const qrCodeSize = Math.max(canvasWidth * 0.06934, 50);
                canvas.width = canvasWidth * 2;
                canvas.height = canvasHeight * 2;
                ctx.scale(2, 2);
                ctx.drawImage(mainImg, 0, 0, canvasWidth, mainImg.height);
                const bottomAreaY = mainImg.height;
                ctx.fillStyle = 'white';
                ctx.fillRect(0, bottomAreaY, canvasWidth, bottomHeight);
                const paddingX = Math.max(canvasWidth * 0.0292, 16);
                const paddingY = Math.max(canvasWidth * 0.0219, 12);
                const logoX = paddingX;
                const logoY = bottomAreaY + Math.max(canvasWidth * 0.0383, 22);
                ctx.drawImage(logoImg, logoX, logoY, logoWidth, logoHeight);
                ctx.font = `${paddingY}px sans-serif`;
                ctx.fillStyle = '#6D7175';
                const words = ['Scan to', 'Generate'];
                const lineHeight = paddingX;
                const maxTextWidth = Math.max(canvasWidth * 0.1022, 56);
                const textX = canvasWidth - qrCodeSize - maxTextWidth - paddingX;
                let line = '';
                let textBlockHeight = lineHeight;
                for (let n = 0; n < words.length; n++) {
                    if (n > 0) {
                        line = `${words[n]} `;
                        textBlockHeight += lineHeight;
                    }
                }
                let textY = bottomAreaY + paddingY + (bottomHeight - textBlockHeight) / 2;
                line = '';
                for (let n = 0; n < words.length; n++) {
                    const testLine = `${line + words[n]} `;
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;
                    if (testWidth > maxTextWidth && n > 0) {
                        ctx.fillText(line, textX, textY);
                        line = `${words[n]} `;
                        textY += lineHeight;
                    }
                    else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, textX, textY);
                const qrCodeX = canvasWidth - qrCodeSize - paddingX;
                ctx.drawImage(qrCodeImg, qrCodeX, bottomAreaY + (bottomHeight - qrCodeSize) / 2, qrCodeSize, qrCodeSize);
                canvas.toBlob(blob => {
                    if (blob) {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = fileName;
                        document.body.appendChild(link);
                        link.click();
                        setTimeout(() => {
                            document.body.removeChild(link);
                            URL.revokeObjectURL(url);
                        }, 1000);
                        successCb === null || successCb === void 0 ? void 0 : successCb();
                    }
                    else {
                        throw new Error('Failed to create image blob');
                    }
                }, 'image/png', 1.0);
            }
            catch (error) {
                warning({
                    id: 'download_image',
                    content: t('download_failed')
                });
            }
            finally {
                setDownloading(false);
            }
        }
    }, [warning, t, gT, isMobile]);
    const loadImage = (src) => {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
        });
    };
    return {
        downloading,
        onDownload,
        onImageDownload
    };
}

function Doc({ doc }) {
    const hoverRef = React.useRef(null);
    const isHover = usehooksTs.useHover(hoverRef);
    const { downloading, onDownload } = useDownload();
    return (jsxRuntime.jsxs("div", { className: "flex items-center space-x-3 px-3 rounded-xl border border-default bg-surface-search-field h-[58px] w-full max-w-full overflow-hidden relative", ref: hoverRef, children: [jsxRuntime.jsx(Image__default.default, { src: doc.iconUrl, alt: "file type", width: 36, height: 36, className: "rounded-[10.8px] overflow-hidden w-9 h-9 shrink-0" }), jsxRuntime.jsxs("div", { className: "flex flex-col space-y-[2px] grow overflow-hidden", children: [jsxRuntime.jsx("div", { className: "text-sm font-semibold text-default truncate", children: doc.title }), jsxRuntime.jsx("span", { className: "text-xs text-subtle uppercase", children: doc.extensionName })] }), jsxRuntime.jsx("div", { className: "w-[26px] h-10 shrink-0", children: isHover && (jsxRuntime.jsx(react.IconButton, { variant: "unstyled", "aria-label": "download file", isLoading: downloading, onClick: () => onDownload(doc.url, doc.title), className: "p-1 min-w-fit text-subtle bg-surface-search-field", children: jsxRuntime.jsx(ForwardRef$T, { className: "w-[18px] h-[18px] text-subtle cursor-pointer" }) })) })] }));
}

function IosAudioPlayer({ title, url }) {
    const chatT = nextIntl.useTranslations('chat');
    const audioRef = React.useRef(null);
    const [duration, setDuration] = React.useState(0);
    const [loading, setLoading] = React.useState(false);
    const [isPlaying, setIsPlaying] = React.useState(false);
    const [currentTime, setCurrentTime] = React.useState(0);
    const [audioHasError, setAudioHasError] = React.useState(false);
    const hoverRef = React.useRef(null);
    const isHover = usehooksTs.useHover(hoverRef);
    const { downloading, onDownload } = useDownload();
    const handleAudioLoad = () => {
        setLoading(false);
        const audio = audioRef.current;
        setDuration(audio.duration);
    };
    const handleAudioError = () => {
        setAudioHasError(true);
    };
    const handleAudioToggle = React.useCallback(() => {
        const audio = audioRef.current;
        if (!duration) {
            setLoading(true);
            audio === null || audio === void 0 ? void 0 : audio.load();
            audio === null || audio === void 0 ? void 0 : audio.addEventListener('loadedmetadata', () => {
                handleAudioLoad();
                audio
                    .play()
                    .then(() => {
                    setIsPlaying(true);
                })
                    .catch(err => {
                    console.error(err, err === null || err === void 0 ? void 0 : err.stack);
                });
            }, {
                once: true
            });
        }
        else if (!audio.paused) {
            audio === null || audio === void 0 ? void 0 : audio.pause();
            setIsPlaying(false);
        }
        else {
            audio
                .play()
                .then(() => {
                setIsPlaying(true);
            })
                .catch(err => {
                console.error(err, err === null || err === void 0 ? void 0 : err.stack);
            });
        }
    }, [duration]);
    const handleAudioTimeUpdate = () => {
        const audio = audioRef.current;
        if (audio) {
            setCurrentTime(audio.currentTime);
            if (!audio.paused) {
                requestAnimationFrame(handleAudioTimeUpdate);
            }
        }
    };
    function afterPlayEnd() {
        var _a;
        if (audioRef.current) {
            audioRef.current.currentTime = 0;
            (_a = audioRef.current) === null || _a === void 0 ? void 0 : _a.pause();
            setIsPlaying(false);
        }
        setCurrentTime(0);
    }
    const handleAudioProgressChangeStart = () => {
        const audio = audioRef.current;
        if (!audio.paused) {
            audio === null || audio === void 0 ? void 0 : audio.pause();
            setIsPlaying(false);
        }
    };
    const handleAudioProgressChange = (newValue) => {
        const audio = audioRef.current;
        audio.currentTime = newValue;
        setCurrentTime(audio.currentTime);
    };
    const handleAudioProgressChangeEnd = () => {
        const audio = audioRef.current;
        if (audio.paused) {
            audio
                .play()
                .then(() => {
                setIsPlaying(true);
            })
                .catch(err => {
                console.error(err, err === null || err === void 0 ? void 0 : err.stack);
            });
        }
    };
    return (jsxRuntime.jsxs("div", { className: "p-3 rounded-xl border border-default bg-surface-search-field w-full max-w-full relative overflow-hidden", children: [jsxRuntime.jsxs("div", { className: "w-full flex flex-col space-y-2 text--default overflow-hidden", children: [audioHasError ? (jsxRuntime.jsxs("div", { className: "flex space-x-3 items-center min-h-[38px]", children: [jsxRuntime.jsx(ForwardRef$k, { className: "w-9 h-9 stroke-[#EC2F0D]" }), jsxRuntime.jsx("span", { className: "text-default", children: chatT('audio_cannot_load') })] })) : (jsxRuntime.jsxs("div", { className: "flex space-x-3 items-center w-full overflow-hidden", ref: hoverRef, children: [jsxRuntime.jsx(react.Button, { variant: "unstyled", onClick: handleAudioToggle, borderRadius: "full", "aria-label": "audio control button", isLoading: !url || loading, isDisabled: !url || loading, _disabled: {
                                    opacity: 0.3,
                                    cursor: 'not-allowed'
                                }, size: "sm", spinner: jsxRuntime.jsx(Spinner, { className: "text-brand", size: "md" }), className: "bg-[#ECEFFF] !flex !items-center !justify-center text-brand w-9 h-9 shrink-0", children: isPlaying ? jsxRuntime.jsx(ForwardRef$g, { className: "w-5 h-5" }) : jsxRuntime.jsx(ForwardRef$f, { className: "w-5 h-5" }) }), jsxRuntime.jsxs("div", { className: "flex flex-col space-y-[2px] grow overflow-hidden", children: [jsxRuntime.jsx("div", { className: "text-sm font-medium truncate", children: title }), jsxRuntime.jsx("span", { className: "text-xs text-subtle", children: !duration ? durationFormatter(0) : duration < 1 ? durationFormatter(1) : durationFormatter(duration) })] }), jsxRuntime.jsx("div", { className: "w-[26px] h-[26px] shrink-0", children: isHover && (jsxRuntime.jsx(react.IconButton, { variant: "unstyled", "aria-label": "download file", isLoading: downloading, onClick: () => onDownload(url, title), className: "p-1 min-w-fit h-fit bg-surface-search-field", children: jsxRuntime.jsx(ForwardRef$T, { className: "w-[18px] h-[18px] text-subtle cursor-pointer" }) })) })] })), jsxRuntime.jsxs("div", { className: "flex space-x-2 items-center pl-1", children: [jsxRuntime.jsxs(react.Slider, { flexGrow: 1, min: 0, max: duration, value: currentTime, onChangeStart: handleAudioProgressChangeStart, onChange: (value) => handleAudioProgressChange(value), onChangeEnd: handleAudioProgressChangeEnd, focusThumbOnChange: false, isDisabled: !duration, className: "flex items-center w-full h-6 cursor-pointer", children: [jsxRuntime.jsx(react.SliderTrack, { className: "bg-surface-container-selected-hovered h-[2px]", children: jsxRuntime.jsx(react.SliderFilledTrack, { className: "bg-[var(--text)]" }) }), jsxRuntime.jsx(react.SliderThumb, { className: "bg-[var(--text)] w-[7px] h-[7px] rounded-full" })] }), jsxRuntime.jsx("span", { className: "text-subtle text-xs shrink-0", children: durationFormatter(currentTime) })] })] }), jsxRuntime.jsx("audio", { ref: audioRef, src: url, onEnded: afterPlayEnd, onTimeUpdate: handleAudioTimeUpdate, onError: handleAudioError, autoPlay: false })] }));
}
var IosAudioPlayer$1 = React.memo(IosAudioPlayer);

function NormalAudioPlayer({ title, url }) {
    const chatT = nextIntl.useTranslations('chat');
    const audioRef = React.useRef(null);
    const [duration, setDuration] = React.useState(0);
    const [isPlaying, setIsPlaying] = React.useState(false);
    const [currentTime, setCurrentTime] = React.useState(0);
    const [audioHasError, setAudioHasError] = React.useState(false);
    const hoverRef = React.useRef(null);
    const isHover = usehooksTs.useHover(hoverRef);
    const { downloading, onDownload } = useDownload();
    const handleAudioLoad = () => {
        const audio = audioRef.current;
        setDuration(audio.duration);
    };
    const handleAudioError = () => {
        setAudioHasError(true);
    };
    const handleAudioToggle = () => {
        const audio = audioRef.current;
        if (!audio.paused) {
            audio === null || audio === void 0 ? void 0 : audio.pause();
            setIsPlaying(false);
        }
        else {
            audio
                .play()
                .then(() => {
                setIsPlaying(true);
            })
                .catch(err => {
                console.error(err, err === null || err === void 0 ? void 0 : err.stack);
            });
        }
    };
    const handleAudioTimeUpdate = () => {
        const audio = audioRef.current;
        if (audio) {
            setCurrentTime(audio.currentTime);
            if (!audio.paused) {
                requestAnimationFrame(handleAudioTimeUpdate);
            }
        }
    };
    function afterPlayEnd() {
        var _a;
        if (audioRef.current) {
            audioRef.current.currentTime = 0;
            (_a = audioRef.current) === null || _a === void 0 ? void 0 : _a.pause();
            setIsPlaying(false);
        }
        setCurrentTime(0);
    }
    const handleAudioProgressChangeStart = () => {
        const audio = audioRef.current;
        if (!audio.paused) {
            audio === null || audio === void 0 ? void 0 : audio.pause();
            setIsPlaying(false);
        }
    };
    const handleAudioProgressChange = (newValue) => {
        const audio = audioRef.current;
        audio.currentTime = newValue;
        setCurrentTime(audio.currentTime);
    };
    const handleAudioProgressChangeEnd = () => {
        const audio = audioRef.current;
        if (audio.paused) {
            audio
                .play()
                .then(() => {
                setIsPlaying(true);
            })
                .catch(err => {
                console.error(err, err === null || err === void 0 ? void 0 : err.stack);
            });
        }
    };
    return (jsxRuntime.jsxs("div", { className: "p-3 rounded-xl border border-default bg-surface-search-field w-full max-w-full relative overflow-hidden", children: [jsxRuntime.jsxs("div", { className: "w-full flex flex-col space-y-2 text-default overflow-hidden", children: [audioHasError ? (jsxRuntime.jsxs("div", { className: "flex space-x-3 items-center min-h-[38px]", children: [jsxRuntime.jsx(ForwardRef$k, { className: "w-9 h-9 stroke-[#EC2F0D]" }), jsxRuntime.jsx("span", { className: "text-default", children: chatT('audio_cannot_load') })] })) : (jsxRuntime.jsxs("div", { className: "flex space-x-3 items-center w-full overflow-hidden", ref: hoverRef, children: [jsxRuntime.jsx(react.Button, { variant: "unstyled", onClick: handleAudioToggle, borderRadius: "full", "aria-label": "audio control button", isLoading: !url || !duration, isDisabled: !url || !duration, _disabled: {
                                    opacity: 0.3,
                                    cursor: 'not-allowed'
                                }, size: "sm", spinner: jsxRuntime.jsx(Spinner, { className: "text-brand", size: "md" }), className: "bg-[#ECEFFF] !flex !items-center !justify-center text-brand w-9 h-9 shrink-0", children: isPlaying ? jsxRuntime.jsx(ForwardRef$g, { className: "w-5 h-5" }) : jsxRuntime.jsx(ForwardRef$f, { className: "w-5 h-5" }) }), jsxRuntime.jsxs("div", { className: "flex flex-col space-y-[2px] grow overflow-hidden", children: [jsxRuntime.jsx("div", { className: "text-sm font-medium truncate", children: title }), jsxRuntime.jsx("span", { className: "text-xs text-subtle", children: !duration ? durationFormatter(0) : duration < 1 ? durationFormatter(1) : durationFormatter(duration) })] }), jsxRuntime.jsx("div", { className: "w-[26px] h-[26px] shrink-0", children: isHover && (jsxRuntime.jsx(react.IconButton, { variant: "unstyled", "aria-label": "download file", isLoading: downloading, onClick: () => onDownload(url, title), className: "p-1 min-w-fit h-fit text-subtle bg-surface-search-field", children: jsxRuntime.jsx(ForwardRef$T, { className: "w-[18px] h-[18px] text-subtle cursor-pointer" }) })) })] })), jsxRuntime.jsxs("div", { className: "flex space-x-2 items-center pl-1", children: [jsxRuntime.jsxs(react.Slider, { flexGrow: 1, min: 0, max: duration, value: currentTime, onChangeStart: handleAudioProgressChangeStart, onChange: (value) => handleAudioProgressChange(value), onChangeEnd: handleAudioProgressChangeEnd, focusThumbOnChange: false, isDisabled: !duration, className: "flex items-center w-full h-6 cursor-pointer", children: [jsxRuntime.jsx(react.SliderTrack, { className: "bg-surface-container-selected-hovered h-[2px]", children: jsxRuntime.jsx(react.SliderFilledTrack, { className: "bg-[var(--text)]" }) }), jsxRuntime.jsx(react.SliderThumb, { className: "bg-[var(--text)] w-[7px] h-[7px] rounded-full" })] }), jsxRuntime.jsx("span", { className: "text-subtle text-xs shrink-0", children: durationFormatter(currentTime) })] })] }), jsxRuntime.jsx("audio", { ref: audioRef, src: url, onLoadedData: handleAudioLoad, onEnded: afterPlayEnd, onTimeUpdate: handleAudioTimeUpdate, onError: handleAudioError, autoPlay: false })] }));
}
var NormalAudioPlayer$1 = React.memo(NormalAudioPlayer);

function Audio(props) {
    const isIosDevice = isIos();
    return isIosDevice ? jsxRuntime.jsx(IosAudioPlayer$1, Object.assign({}, props)) : jsxRuntime.jsx(NormalAudioPlayer$1, Object.assign({}, props));
}
var Audio$1 = React.memo(Audio);

var __rest$e = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const CheckIcon = ({ className }) => {
    return (jsxRuntime.jsx("svg", { className: className, xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", children: jsxRuntime.jsx("path", { d: "M2.25 6.375L5.25 9.375L9.75 2.625", stroke: "white", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }) }));
};
const checkboxVariants = classVarianceAuthority.cva('peer w-5 h-5 shrink-0 border-[1.5px] border-pressed hover:border-depressed data-[state=checked]:border-surface-primary-default ring-offset-surface-default focus-visible:border-surface-primary-default focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand focus-visible:ring-offset-1 disabled:border-pressed disabled:cursor-not-allowed disabled:opacity-30 data-[state=checked]:bg-surface-primary-default data-[state=checked]:text-icon-static hover:data-[state=checked]:bg-surface-primary-hovered disabled:data-[state=checked]:text-disabled disabled:data-[state=checked]:border-none', {
    variants: {
        variant: {
            checkbox: 'rounded-sm',
            circle: 'rounded-full',
            radio: 'rounded-full',
            'circle-static': 'rounded-full bg-beta-black-10 border-beta-white-100 hover:border-beta-white-100'
        }
    },
    defaultVariants: {
        variant: 'checkbox'
    }
});
const Checkbox = React__namespace.forwardRef((_a, ref) => {
    var { className, variant, label } = _a, props = __rest$e(_a, ["className", "variant", "label"]);
    return (jsxRuntime.jsx(CheckboxPrimitive__namespace.Root, Object.assign({ ref: ref, className: cn('rounded-sm overflow-hidden flex items-center justify-center text-current ', checkboxVariants({ variant, className })) }, props, { children: jsxRuntime.jsx(CheckboxPrimitive__namespace.Indicator, { children: variant === 'radio' ? jsxRuntime.jsx("div", { className: "w-2 h-2 bg-static rounded-full" }) : jsxRuntime.jsx(CheckIcon, { className: "w-3 h-3" }) }) })));
});
Checkbox.displayName = CheckboxPrimitive__namespace.Root.displayName;

function ImageOverview({ url, imageModel, onViewImage, customClass, index }) {
    const { message } = useDisplayContext();
    const messageId = message === null || message === void 0 ? void 0 : message.id;
    const { imgGenerator, entityInfo } = React.useContext(StaticContext);
    const { editorMode, publish } = React.useContext(MessageContext);
    const { id } = entityInfo;
    const { selectedImg, everPublished, reachedLimitation, addImg, removeImg } = publish || {};
    const isPublishChecked = selectedImg === null || selectedImg === void 0 ? void 0 : selectedImg.has(url);
    const imageRef = React.useRef(null);
    const [loaded, setLoaded] = React.useState(false);
    const targetBox = React.useRef(null);
    const t = nextIntl.useTranslations();
    const isMobile = useGlobalStore(state => state.isMobile);
    const handleLoaded = () => {
        setLoaded(true);
    };
    reactUse.useEffectOnce(() => {
        const image = imageRef.current;
        if (image) {
            image.addEventListener('load', handleLoaded, {
                once: true
            });
        }
    });
    const handleImagePublishChecked = React.useCallback(() => {
        var _a, _b;
        if (messageId && id) {
            if (selectedImg === null || selectedImg === void 0 ? void 0 : selectedImg.has(url)) {
                removeImg === null || removeImg === void 0 ? void 0 : removeImg(url);
            }
            else {
                if (reachedLimitation)
                    return;
                addImg === null || addImg === void 0 ? void 0 : addImg(url, {
                    messageId,
                    imageLink: url,
                    naturalHeight: ((_a = imageRef.current) === null || _a === void 0 ? void 0 : _a.naturalHeight) || 0,
                    naturalWidth: ((_b = imageRef.current) === null || _b === void 0 ? void 0 : _b.naturalWidth) || 0
                });
            }
        }
    }, [messageId, id, selectedImg, url, removeImg, reachedLimitation, addImg]);
    return (jsxRuntime.jsxs("div", { className: clsx__default.default('relative w-full h-full', customClass), ref: targetBox, children: [!loaded && (jsxRuntime.jsx("div", { className: "absolute top-0 left-0 w-full h-full flex justify-center items-center z-[1] bg-[#00000033] backdrop-blur-2xl", children: jsxRuntime.jsx("div", { className: "w-10 h-10 p-[6px] flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "md", className: "text-white" }) }) })), jsxRuntime.jsx("img", { ref: imageRef, alt: "image", src: url, width: 1000, height: 1000, className: clsx__default.default('w-full min-h-24 max-h-[301px] md:max-h-[536px] rounded-md cursor-pointer object-cover relative', customClass), onClick: e => {
                    if (editorMode === 'PUBLISH') {
                        handleImagePublishChecked();
                    }
                    else {
                        onViewImage();
                    }
                }, "x-image-source": "embedObj", "x-image-data": JSON.stringify({
                    url,
                    imageModel
                }) }), editorMode === 'PUBLISH' && (!reachedLimitation || (reachedLimitation && isPublishChecked)) && (jsxRuntime.jsx("div", { className: "w-6 h-6 ml-0 flex justify-center items-center absolute right-3 top-3 z-[1]", children: jsxRuntime.jsx(Checkbox, { variant: "circle-static", checked: isPublishChecked, onCheckedChange: handleImagePublishChecked }) })), !everPublished && index === 0 && imgGenerator && editorMode !== 'PUBLISH' && (message === null || message === void 0 ? void 0 : message.type) !== 'GREETING' && (jsxRuntime.jsxs("div", { className: "absolute left-1 md:right-1 bottom-1 z-10 w-[150px] md:w-[220px] flex border-opaque rounded-lg bg-utility-sky-blue-500 py-2 pl-3 pr-5 text-wrap text-left", children: [jsxRuntime.jsx(Description$1, { size: "lg", weight: "medium", color: "static", children: isMobile ? t('chat.mob_publish_to_gallery') : t('chat.right_publish_to_gallery') }), jsxRuntime.jsx("span", { className: "absolute left-0 top-3 origin-center", style: {
                            transformOrigin: '0px 0px',
                            transform: 'translateY(50%) rotate(90deg) translateX(-50%)'
                        }, children: jsxRuntime.jsx("svg", { className: "fill-utility-sky-blue-500 block", width: "10", height: "5", viewBox: "0 0 30 10", preserveAspectRatio: "none", children: jsxRuntime.jsx("polygon", { points: "0,0 30,0 15,10" }) }) })] }))] }));
}
const MemorizedImageOverview = React.memo(ImageOverview);

function VideoOverview$1({ url, onViewVideo, customClass, showPlayBtn = true, showRadius = true, showLoading = true }) {
    const videoRef = React.useRef(null);
    const [loaded, setLoaded] = React.useState(false);
    const handleLoaded = () => {
        setLoaded(true);
    };
    reactUse.useEffectOnce(() => {
        const video = videoRef.current;
        if (video) {
            video.addEventListener('loadedmetadata', handleLoaded, {
                once: true
            });
        }
    });
    return (jsxRuntime.jsxs("div", { className: clsx__default.default('relative w-full h-full', customClass, showRadius ? 'rounded-md overflow-hidden' : ''), children: [!loaded && showLoading && (jsxRuntime.jsx("div", { className: "absolute top-0 left-0 w-full h-full flex justify-center items-center z-[1] bg-transparent backdrop-blur-2xl", children: jsxRuntime.jsx("div", { className: "w-10 h-10 p-[6px] flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "md", speed: "slow", className: "text-white" }) }) })), jsxRuntime.jsx("video", { ref: videoRef, src: url, muted: true, playsInline: true, disablePictureInPicture: true, className: "w-full h-full min-w-24 min-h-24 max-h-[301px] md:max-h-[536px] object-cover", preload: "metadata" }), showPlayBtn && (jsxRuntime.jsx("div", { className: "w-full h-full absolute top-0 left-0 flex justify-center items-center bg-transparent", children: jsxRuntime.jsx(ForwardRef$f, { className: "w-10 h-10 text-white cursor-pointer", onClick: () => onViewVideo && onViewVideo() }) }))] }));
}
const MemorizedVideoOverview$1 = React.memo(VideoOverview$1);

const useRoute = () => {
    const router = navigation.useRouter();
    const openUrl = (url) => {
        if (!(url.startsWith('https') || url.startsWith('http'))) {
            router.push(url);
        }
        else {
            window.open(url);
        }
    };
    return Object.assign(Object.assign({}, router), { openUrl });
};

function ArrowLeftIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M11.03 3.97a.75.75 0 0 1 0 1.06l-6.22 6.22H21a.75.75 0 0 1 0 1.5H4.81l6.22 6.22a.75.75 0 1 1-1.06 1.06l-7.5-7.5a.75.75 0 0 1 0-1.06l7.5-7.5a.75.75 0 0 1 1.06 0Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$8 = /*#__PURE__*/ React__namespace.forwardRef(ArrowLeftIcon);

function BotLogo({ logoUrl }) {
    return (jsxRuntime.jsx("div", { className: "flex-shrink-0 rounded-2xl w-[84px] h-[84px] md:w-[120px] md:h-[120px] overflow-hidden ml-[16px] md:ml-[24px] -mt-[30px] md:-mt-[48px] z-0 border-[2px] md:border-[6px] border-white dark:border-[#1C1E26]", children: logoUrl ? (jsxRuntime.jsx(Avatar, { src: logoUrl, alt: "bot avatar", className: "w-full h-full" })) : (jsxRuntime.jsx("div", { className: "w-full h-full rounded-md bg-[#bbb]" })) }));
}

function ErrorState({ className, onClick }) {
    const t = nextIntl.useTranslations();
    return (jsxRuntime.jsxs("div", { className: cn('w-full h-full flex flex-col justify-start items-center p-6 !mb-[20%]', className), children: [jsxRuntime.jsx("img", { src: "https://www.myshellstatic.com/image/website/error/20240603/error-state.png", alt: "error logo", className: "w-[225px] h-[180px]" }), jsxRuntime.jsxs("p", { className: "mt-8 md:mt-12 text-[24px] font-semibold text-default", children: [t('disconnect_tip_oops'), "!!"] }), jsxRuntime.jsx("p", { className: "mt-2 text-base text-subtler text-center md:text-left", children: t('common.error_oops') }), jsxRuntime.jsx(Button$1, { variant: "outline", className: "mt-6 flex justify-center items-center", onClick: onClick, children: jsxRuntime.jsxs("span", { className: "flex justify-center items-center space-x-1.5 text-brand", children: [jsxRuntime.jsx(ForwardRef$Q, { className: "text-brand stroke-brand w-5 h-5" }), jsxRuntime.jsx("span", { className: "text-base", children: `${t('profile.refresh')}` })] }) })] }));
}

const PhotoStackIcon = React.forwardRef((props, ref) => (jsxRuntime.jsx(Icon, Object.assign({}, props, { children: jsxRuntime.jsxs("svg", { ref: ref, className: props.className, width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsx("g", { clipPath: "url(#clip0_15911_38152)", children: jsxRuntime.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.375 5C4.375 3.61929 5.49429 2.5 6.875 2.5H13.125C14.5057 2.5 15.625 3.61929 15.625 5V5.33464C16.3717 5.7666 16.875 6.57395 16.875 7.5V7.83464C17.6217 8.2666 18.125 9.07395 18.125 10V14.9039V15C18.125 16.3807 17.0057 17.5 15.625 17.5H4.375C2.99429 17.5 1.875 16.3807 1.875 15V14.904C1.875 14.9039 1.875 14.9038 1.875 14.9037V10C1.875 9.07395 2.37825 8.2666 3.125 7.83464V7.5C3.125 6.57395 3.62825 5.7666 4.375 5.33464V5ZM5.625 5H14.375C14.375 4.30964 13.8154 3.75 13.125 3.75H6.875C6.18464 3.75 5.625 4.30964 5.625 5ZM4.375 7.5H15.625C15.625 6.95672 15.2781 6.49286 14.7917 6.32097C14.6622 6.27519 14.5222 6.25 14.375 6.25H5.625C5.47778 6.25 5.3378 6.27519 5.20828 6.32097C4.72194 6.49286 4.375 6.95672 4.375 7.5ZM3.13432 15.1534C3.20996 15.7714 3.73659 16.25 4.375 16.25H15.625C16.2634 16.25 16.79 15.7714 16.8657 15.1534L14.8204 13.1081C14.3885 12.6763 13.6884 12.6763 13.2566 13.1081L12.6147 13.75L12.8475 13.9829C13.0916 14.227 13.0916 14.6227 12.8475 14.8668C12.6034 15.1109 12.2077 15.1109 11.9636 14.8668L11.2888 14.192L8.47421 11.3773C8.04237 10.9455 7.34224 10.9455 6.91041 11.3773L3.13432 15.1534ZM11.7308 12.8661L9.35809 10.4935C8.4381 9.57347 6.94651 9.57347 6.02653 10.4935L3.125 13.395V10C3.125 9.45672 3.47194 8.99286 3.95828 8.82097C4.0878 8.77519 4.22778 8.75 4.375 8.75H15.625C15.7722 8.75 15.9122 8.77519 16.0417 8.82097C16.5281 8.99286 16.875 9.45672 16.875 10V13.395L15.7042 12.2242C14.7843 11.3042 13.2927 11.3042 12.3727 12.2242L11.7308 12.8661ZM10.9375 10.2083C10.9375 9.69057 11.3572 9.27083 11.875 9.27083C12.3928 9.27083 12.8125 9.69057 12.8125 10.2083C12.8125 10.7261 12.3928 11.1458 11.875 11.1458C11.3572 11.1458 10.9375 10.7261 10.9375 10.2083Z", fill: "currentColor" }) }), jsxRuntime.jsx("defs", { children: jsxRuntime.jsx("clipPath", { id: "clip0_15911_38152", children: jsxRuntime.jsx("rect", { width: "20", height: "20", fill: "white" }) }) })] }) }))));

const Masonry = ({ breakpointCols = {
    default: 0,
    3280: 5,
    1919: 4,
    1439: 3,
    1199: 2
}, className = '', columnClassName = '', children, columnAttrs = {} }) => {
    const [columnCount, setColumnCount] = React.useState(typeof breakpointCols === 'number' ? breakpointCols : breakpointCols.default);
    const reCalculateColumnCount = () => {
        const windowWidth = (window === null || window === void 0 ? void 0 : window.innerWidth) || Infinity;
        let newColumnCount = columnCount;
        if (typeof breakpointCols === 'object') {
            let matchedBreakpoint = Infinity;
            for (const breakpoint in breakpointCols) {
                const optBreakpoint = parseInt(breakpoint);
                const isCurrentBreakpoint = optBreakpoint > 0 && windowWidth <= optBreakpoint;
                if (isCurrentBreakpoint && optBreakpoint < matchedBreakpoint) {
                    matchedBreakpoint = optBreakpoint;
                    newColumnCount = breakpointCols[breakpoint];
                }
            }
            newColumnCount = Math.max(1, newColumnCount || 1);
        }
        if (columnCount !== newColumnCount) {
            setColumnCount(newColumnCount);
        }
    };
    React.useEffect(() => {
        const handleResize = () => {
            reCalculateColumnCount();
        };
        window.addEventListener('resize', handleResize);
        handleResize();
        return () => {
            window.removeEventListener('resize', handleResize);
        };
    }, [breakpointCols, columnCount]);
    const itemsInColumns = () => {
        const columns = new Array(columnCount);
        const items = React__namespace.default.Children.toArray(children);
        for (let i = 0; i < items.length; i++) {
            const columnIndex = i % columnCount;
            if (!columns[columnIndex]) {
                columns[columnIndex] = [];
            }
            columns[columnIndex].push(items[i]);
        }
        return columns;
    };
    const renderColumns = () => {
        const childrenInColumns = itemsInColumns();
        const columnWidth = `${100 / childrenInColumns.length}%`;
        return childrenInColumns.map((items, i) => (React.createElement("div", Object.assign({}, columnAttrs, { style: Object.assign(Object.assign({}, columnAttrs.style), { width: columnWidth }), className: cn('pl-2 md:pl-5 bg-clip-padding space-y-2 md:space-y-5', columnClassName), key: i }), items)));
    };
    return (jsxRuntime.jsx("div", Object.assign({}, columnAttrs, { className: cn('flex mr-4 md:mr-6 w-auto', className || 'my-masonry-grid'), children: columnCount > 0 && renderColumns() })));
};

var __rest$d = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function Skeleton(_a) {
    var { className, animate = true } = _a, props = __rest$d(_a, ["className", "animate"]);
    return (jsxRuntime.jsx("div", Object.assign({ className: cn('rounded-md bg-surface-container-hovered', className, animate && 'animate-pulse ') }, props)));
}

const DEFAULT_STATE$1 = {
    galleryList: [],
    galleryUserList: []
};
const computeState = (state) => ({
    history: []
});
const useGalleryStore = zustand.create()(computed__default.default((set, get) => (Object.assign(Object.assign({}, DEFAULT_STATE$1), { setGalleryList: (galleryList) => {
        set({ galleryList });
    }, setGalleryUserList: (galleryUserList) => {
        set({ galleryUserList });
    } })), computeState));

var __rest$c = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function publishGallery(list) {
    const paramsBody = list.map(item => {
        const rest = __rest$c(item, ["botId"]);
        return rest;
    });
    return APIFetch.post('/v1/bot/gallery/publish', {
        body: {
            list: paramsBody
        },
        hideErrorToast: true,
        isGoLang: true
    });
}
function getGalleryList({ pageToken, pageSize = 15, botId, userId }) {
    return APIFetch.post('/v1/bot/gallery/get_list', {
        body: Object.assign(Object.assign({ listRequest: {
                pageToken,
                pageSize
            } }, (botId && { botId })), (userId && { userId })),
        isGoLang: true
    });
}
function deleteGallery(id) {
    return APIFetch.post('/v1/bot/gallery/delete', {
        body: {
            ids: [id]
        },
        isGoLang: true
    });
}
function checkGalleryUpdate(botId) {
    return APIFetch.post('/v1/bot/gallery/check_gallery_update', {
        body: {
            botIds: [botId]
        },
        isGoLang: true
    });
}
const shareCodeCacheMap$ = new Map();
async function getGallerySharingCode(galleryId) {
    if (!shareCodeCacheMap$.has(galleryId)) {
        const res = (await getGallerySharingCodeById(galleryId));
        if (res.success && res.data) {
            shareCodeCacheMap$.set(galleryId, res.data.code);
        }
    }
    return shareCodeCacheMap$.get(galleryId);
}
function getGallerySharingCodeById(galleryId) {
    return APIFetch.post('/v1/shared/generate_shared_code', {
        body: {
            bizId: galleryId,
            bizType: 'BIZ_TYPE_GALLERY_IMAGE'
        },
        isGoLang: true
    });
}
function getGalleryDetailById(galleryId) {
    return APIFetch.post('/v1/bot/gallery/get_detail', {
        body: {
            id: galleryId
        },
        isGoLang: true
    });
}

function GalleryDeleteTipModal({ deleting, open, onClose, onConfirm }) {
    const t = nextIntl.useTranslations();
    return (jsxRuntime.jsx(Modal, { overlayClose: !deleting, hideClose: deleting, open: open, onClose: onClose, onConfirm: onConfirm, state: "warning", confirmText: t('common.delete'), isNotification: true, title: t('chat.delete_confirmation.header'), description: t('chat.delete_gallery'), confirmLoading: deleting, overlayClassName: "z-[110]", contentClassName: "z-[110]" }));
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto$1.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

function GenerateIcon({ className }) {
    return (jsxRuntime.jsxs("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", className: className, xmlns: "http://www.w3.org/2000/svg", children: [jsxRuntime.jsxs("g", { clipPath: "url(#clip0_17237_21185)", children: [jsxRuntime.jsx("path", { d: "M17.388 17.9344C17.7395 18.2943 18.3422 18.2943 18.677 17.9344C19.0202 17.5661 19.0202 16.9969 18.677 16.6453L10.7167 8.65982C10.3651 8.30826 9.76244 8.30826 9.42759 8.65982C9.07601 9.02811 9.08444 9.60568 9.42759 9.95725L17.388 17.9344ZM12.5163 12.1838L10.0637 9.72289C9.91309 9.57218 9.86287 9.40482 10.0135 9.26253C10.1391 9.12853 10.3149 9.16204 10.4739 9.32111L12.9349 11.782L12.5163 12.1838Z", fill: "white" }), jsxRuntime.jsx("path", { d: "M7.0671 18.0684C7.21777 18.0684 7.32659 17.9595 7.3517 17.8005C7.61956 15.5656 7.72837 15.5069 10.0052 15.1387C10.1809 15.1052 10.2897 15.0215 10.2897 14.8541C10.2897 14.695 10.1809 14.5946 10.0387 14.5694C7.74512 14.1342 7.61956 14.1426 7.3517 11.9077C7.32659 11.7486 7.21777 11.6398 7.0671 11.6398C6.90807 11.6398 6.79925 11.7486 6.7825 11.8993C6.48954 14.1677 6.4142 14.243 4.09557 14.5694C3.95327 14.5862 3.84445 14.695 3.84445 14.8541C3.84445 15.0131 3.95327 15.1052 4.09557 15.1387C6.4142 15.5823 6.48117 15.5823 6.7825 17.8172C6.79925 17.9595 6.90807 18.0684 7.0671 18.0684ZM3.0911 10.7776C3.20829 10.7776 3.27525 10.6939 3.30036 10.5851C3.58496 8.99473 3.59333 8.89424 5.27581 8.60966C5.38462 8.58452 5.46833 8.51758 5.46833 8.40039C5.46833 8.28321 5.38462 8.20787 5.27581 8.19113C3.59333 7.89816 3.58496 7.79771 3.30036 6.20731C3.27525 6.09849 3.20829 6.02316 3.0911 6.02316C2.97391 6.02316 2.90695 6.09849 2.88184 6.20731C2.59724 7.79771 2.58887 7.89816 0.906389 8.19113C0.797573 8.20787 0.713867 8.28321 0.713867 8.40039C0.713867 8.51758 0.797573 8.58452 0.906389 8.60966C2.58887 8.89424 2.59724 8.99473 2.88184 10.5851C2.90695 10.6939 2.97391 10.7776 3.0911 10.7776ZM7.67815 5.42048C7.7786 5.42048 7.82882 5.36188 7.84557 5.26981C8.13015 3.93053 8.11344 3.8803 9.51965 3.59571C9.61172 3.57896 9.67872 3.52037 9.67872 3.42829C9.67872 3.32785 9.61172 3.26925 9.51965 3.25251C8.11344 2.96791 8.13015 2.91769 7.84557 1.58677C7.82882 1.4947 7.7786 1.42773 7.67815 1.42773C7.57771 1.42773 7.52748 1.4947 7.51074 1.58677C7.22615 2.91769 7.24288 2.96791 5.83664 3.25251C5.74456 3.26925 5.6776 3.32785 5.6776 3.42829C5.6776 3.52037 5.74456 3.57896 5.83664 3.59571C7.24288 3.8803 7.22615 3.93053 7.51074 5.26981C7.52748 5.36188 7.57771 5.42048 7.67815 5.42048ZM14.5922 8.37528C14.7094 8.37528 14.7764 8.29994 14.8015 8.19113C15.0861 6.60073 15.0944 6.50028 16.7769 6.20731C16.8941 6.19057 16.9694 6.11523 16.9694 5.99805C16.9694 5.88086 16.8941 5.81389 16.7769 5.78878C15.0944 5.50418 15.0861 5.40374 14.8015 3.81333C14.7764 3.70452 14.7094 3.62081 14.5922 3.62081C14.475 3.62081 14.4081 3.70452 14.3829 3.81333C14.0984 5.40374 14.09 5.50418 12.4075 5.78878C12.2987 5.81389 12.215 5.88086 12.215 5.99805C12.215 6.11523 12.2987 6.19057 12.4075 6.20731C14.09 6.50028 14.0984 6.60073 14.3829 8.19113C14.4081 8.29994 14.475 8.37528 14.5922 8.37528Z", fill: "white" })] }), jsxRuntime.jsx("defs", { children: jsxRuntime.jsx("clipPath", { id: "clip0_17237_21185", children: jsxRuntime.jsx("rect", { width: "20", height: "20", fill: "white" }) }) })] }));
}

function NotFoundIcon({ className }) {
    return (jsxRuntime.jsxs("svg", { width: "300", height: "301", viewBox: "0 0 300 301", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: className, children: [jsxRuntime.jsxs("g", { opacity: "0.8", children: [jsxRuntime.jsx("circle", { opacity: "0.4", cx: "154.5", cy: "149.212", r: "115.5", fill: "url(#paint0_linear_16733_50048)" }), jsxRuntime.jsx("circle", { cx: "271.962", cy: "77.5061", r: "6.68125", stroke: "#A3A3A3", "stroke-width": "2.69663" }), jsxRuntime.jsx("circle", { cx: "184.996", cy: "277.731", r: "6.68125", stroke: "#A3A3A3", "stroke-width": "2.69663" }), jsxRuntime.jsx("g", { filter: "url(#filter0_f_16733_50048)", children: jsxRuntime.jsx("path", { d: "M57.6408 158.465L59.9169 164.616L66.0678 166.892L59.9169 169.168L57.6408 175.319L55.3648 169.168L49.2139 166.892L55.3648 164.616L57.6408 158.465Z", fill: "#B5B5B5" }) }), jsxRuntime.jsx("path", { d: "M271.74 196.218L275.123 205.361L284.266 208.744L275.123 212.127L271.74 221.27L268.357 212.127L259.214 208.744L268.357 205.361L271.74 196.218Z", fill: "#A3A3A3" }), jsxRuntime.jsx("path", { d: "M190.196 174.966L130.436 95.8145L73.1945 135.793C67.7948 139.557 66.6526 147.059 70.6504 152.277L107.566 200.433L190.196 174.966Z", fill: "#ADADAD" }), jsxRuntime.jsx("path", { d: "M190.196 174.967L130.437 95.8145L177.009 64.8702C182.538 61.2098 189.963 62.6896 193.675 68.1671L230.408 122.605L190.196 174.967V174.967Z", fill: "#999999" }), jsxRuntime.jsx("path", { d: "M230.409 122.605L230.383 122.553V122.605H230.409ZM168.495 108.535C170.519 104.667 174.18 101.889 178.463 100.98L211.147 94.0489L191.781 65.3372C188.873 61.0538 183.681 58.9251 178.619 59.9375L104.27 74.9943L150.349 143.243L168.495 108.535Z", fill: "url(#paint1_linear_16733_50048)" }), jsxRuntime.jsx("path", { d: "M120.545 126.291L150.27 143.373L150.347 143.243L104.268 74.9941L67.8466 135.221C65.1208 139.738 65.4323 145.45 68.6513 149.655L81.0602 165.854L108.292 128.887C111.122 125.019 116.392 123.903 120.545 126.291V126.291ZM150.373 143.451L150.425 143.399L150.347 143.425L150.373 143.451ZM107.565 200.433L109.59 197.707L107.565 200.407V200.433ZM234.588 89.0645L211.146 94.0488L230.382 122.553L239.208 94.1267C240.117 91.2191 237.547 88.4414 234.588 89.0645V89.0645Z", fill: "url(#paint2_linear_16733_50048)" }), jsxRuntime.jsx("path", { d: "M150.426 143.398L230.383 122.604L150.426 143.372V143.398Z", fill: "#FE506B" }), jsxRuntime.jsx("path", { d: "M178.463 100.981C174.179 101.889 170.545 104.667 168.494 108.535L150.322 143.244L150.4 143.373L230.357 122.605V122.553L211.121 94.0234L178.463 100.981Z", fill: "#CAC134" }), jsxRuntime.jsx("path", { d: "M178.463 100.981C174.179 101.889 170.545 104.667 168.494 108.535L150.322 143.244L150.4 143.373L230.357 122.605V122.553L211.121 94.0234L178.463 100.981Z", fill: "url(#paint3_linear_16733_50048)" }), jsxRuntime.jsx("path", { d: "M150.348 143.243L150.271 143.373L150.348 143.425L150.426 143.399V143.373L150.348 143.243Z", fill: "#FFBA3B" }), jsxRuntime.jsx("path", { d: "M150.348 143.243L150.271 143.373L150.348 143.425L150.426 143.399V143.373L150.348 143.243Z", fill: "#FE506B" }), jsxRuntime.jsx("path", { d: "M74.9083 174.135C72.4161 177.51 73.5064 182.313 77.2187 184.26L107.54 200.433V200.407L81.0348 165.828L74.9083 174.135V174.135Z", fill: "url(#paint4_linear_16733_50048)" }), jsxRuntime.jsx("path", { d: "M150.478 143.503L150.374 143.451L109.591 197.708L150.478 143.503Z", fill: "#FE506B" }), jsxRuntime.jsx("path", { d: "M150.244 143.45L150.269 143.399L120.545 126.317C116.392 123.929 111.122 125.045 108.292 128.887L81.0342 165.828L107.539 200.407L109.59 197.707L150.373 143.425L150.321 143.399L150.244 143.45V143.45Z", fill: "#FFBA3B" }), jsxRuntime.jsx("path", { d: "M150.244 143.45L150.269 143.399L120.545 126.317C116.392 123.929 111.122 125.045 108.292 128.887L81.0342 165.828L107.539 200.407L109.59 197.707L150.373 143.425L150.321 143.399L150.244 143.45V143.45Z", fill: "url(#paint5_linear_16733_50048)" }), jsxRuntime.jsx("path", { d: "M150.347 143.425L150.269 143.373L150.243 143.451L150.347 143.425Z", fill: "#FFBA3B" }), jsxRuntime.jsx("path", { d: "M150.347 143.425L150.269 143.373L150.243 143.451L150.347 143.425Z", fill: "#FE506B" }), jsxRuntime.jsx("path", { d: "M150.347 143.425L150.269 143.373L150.243 143.451L150.347 143.425Z", fill: "#FE506B" }), jsxRuntime.jsx("path", { d: "M177.009 210.168L112.031 231.922C108.293 233.194 104.503 230.183 104.892 226.263L107.566 200.433L190.196 174.966L186.562 199.55C185.446 204.482 181.837 208.506 177.009 210.168Z", fill: "url(#paint6_linear_16733_50048)" }), jsxRuntime.jsx("path", { d: "M243.596 120.373L216.156 151.888C214.287 154.224 212.133 156.301 209.744 158.093L190.145 175.018L230.357 122.631L241.312 117.517C243.129 116.66 244.842 118.815 243.596 120.373V120.373Z", fill: "url(#paint7_linear_16733_50048)" }), jsxRuntime.jsx("path", { d: "M155.306 207.416L159.122 205.963C160.498 205.417 162.082 205.703 163.224 206.663L169.091 211.648C171.324 213.543 170.908 217.099 168.286 218.397L164.756 220.163C163.302 220.89 161.537 220.682 160.291 219.618L154.138 214.348C151.776 212.297 152.451 208.533 155.306 207.416V207.416ZM184.563 251.211L187.419 249.601C188.457 249.004 189.755 248.848 190.82 249.134L196.271 250.718C198.348 251.315 198.53 253.417 196.609 254.715L194.013 256.455C192.948 257.182 191.495 257.415 190.326 257.078L184.589 255.364C182.435 254.715 182.409 252.431 184.563 251.211V251.211Z", fill: "#D1D1D1" }), jsxRuntime.jsx("path", { d: "M60.7273 234.645L64.1105 243.787L73.2534 247.171L64.1105 250.554L60.7273 259.697L57.3441 250.554L48.2012 247.171L57.3441 243.787L60.7273 234.645Z", fill: "#B5B5B5" }), jsxRuntime.jsx("circle", { cx: "244.382", cy: "167.229", r: "4.04494", stroke: "#A3A3A3", "stroke-width": "2.69663" }), jsxRuntime.jsx("g", { filter: "url(#filter1_d_16733_50048)", children: jsxRuntime.jsx("path", { d: "M238.033 156.358C236.314 152.682 233.857 149.383 230.73 146.554C227.615 143.735 223.988 141.523 219.953 139.978C215.785 138.383 211.358 137.574 206.797 137.574C202.237 137.574 197.81 138.383 193.642 139.978C189.607 141.523 185.98 143.737 182.865 146.554C179.738 149.383 177.281 152.682 175.562 156.358C173.788 160.13 172.869 164.247 172.872 168.415C172.872 177.066 176.834 185.25 183.794 191.086C181.577 193.99 178.378 196.622 173.621 199.476C173.332 199.65 173.107 199.913 172.982 200.226C172.857 200.539 172.838 200.885 172.928 201.21C173.018 201.535 173.212 201.822 173.481 202.026C173.749 202.23 174.077 202.34 174.414 202.341C179.109 202.341 183.426 201.874 187.244 200.952C190.498 200.167 193.404 199.05 195.894 197.627C199.427 198.712 203.102 199.262 206.797 199.256C211.358 199.256 215.785 198.447 219.953 196.852C223.988 195.31 227.615 193.094 230.729 190.276C233.857 187.447 236.314 184.149 238.032 180.473C239.804 176.7 240.722 172.583 240.722 168.415C240.722 164.247 239.804 160.131 238.032 156.358H238.033Z", fill: "url(#paint8_linear_16733_50048)" }) }), jsxRuntime.jsx("path", { d: "M204.594 173.353C203.943 168.485 210.548 167.399 210.548 164.391C210.548 162.499 209.06 161.445 206.61 161.445C204.718 161.445 203.168 162.313 201.648 163.895L199.105 161.569C201.09 159.274 203.819 157.755 207.137 157.755C211.634 157.755 214.921 159.863 214.921 163.988C214.921 168.516 208.13 169.074 208.626 173.353H204.594ZM206.641 181.633C205.028 181.633 203.881 180.486 203.881 178.873C203.881 177.261 205.059 176.144 206.641 176.144C208.192 176.144 209.37 177.261 209.37 178.873C209.37 180.486 208.192 181.633 206.641 181.633Z", fill: "white" }), jsxRuntime.jsx("g", { filter: "url(#filter2_f_16733_50048)", children: jsxRuntime.jsx("path", { d: "M97.0057 24.3076L101.083 35.326L112.101 39.4032L101.083 43.4804L97.0057 54.4988L92.9286 43.4804L81.9102 39.4032L92.9286 35.326L97.0057 24.3076Z", fill: "#A4A4A4" }) })] }), jsxRuntime.jsxs("defs", { children: [jsxRuntime.jsxs("filter", { id: "filter0_f_16733_50048", x: "46.5172", y: "155.768", width: "22.2468", height: "22.2468", filterUnits: "userSpaceOnUse", "color-interpolation-filters": "sRGB", children: [jsxRuntime.jsx("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }), jsxRuntime.jsx("feBlend", { mode: "normal", in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), jsxRuntime.jsx("feGaussianBlur", { stdDeviation: "1.34831", result: "effect1_foregroundBlur_16733_50048" })] }), jsxRuntime.jsxs("filter", { id: "filter1_d_16733_50048", x: "159.389", y: "130.833", width: "94.8159", height: "91.7329", filterUnits: "userSpaceOnUse", "color-interpolation-filters": "sRGB", children: [jsxRuntime.jsx("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }), jsxRuntime.jsx("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), jsxRuntime.jsx("feOffset", { dy: "6.74157" }), jsxRuntime.jsx("feGaussianBlur", { stdDeviation: "6.74157" }), jsxRuntime.jsx("feComposite", { in2: "hardAlpha", operator: "out" }), jsxRuntime.jsx("feColorMatrix", { type: "matrix", values: "0 0 0 0 0.937255 0 0 0 0 0.937255 0 0 0 0 0.937255 0 0 0 0.39 0" }), jsxRuntime.jsx("feBlend", { mode: "normal", in2: "BackgroundImageFix", result: "effect1_dropShadow_16733_50048" }), jsxRuntime.jsx("feBlend", { mode: "normal", in: "SourceGraphic", in2: "effect1_dropShadow_16733_50048", result: "shape" })] }), jsxRuntime.jsxs("filter", { id: "filter2_f_16733_50048", x: "79.2135", y: "21.611", width: "35.5847", height: "35.5847", filterUnits: "userSpaceOnUse", "color-interpolation-filters": "sRGB", children: [jsxRuntime.jsx("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }), jsxRuntime.jsx("feBlend", { mode: "normal", in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), jsxRuntime.jsx("feGaussianBlur", { stdDeviation: "1.34831", result: "effect1_foregroundBlur_16733_50048" })] }), jsxRuntime.jsxs("linearGradient", { id: "paint0_linear_16733_50048", x1: "154.5", y1: "-31.7465", x2: "154.5", y2: "264.712", gradientUnits: "userSpaceOnUse", children: [jsxRuntime.jsx("stop", { stopColor: "white", stopOpacity: "0" }), jsxRuntime.jsx("stop", { offset: "1", stopColor: "#D4D4D4" })] }), jsxRuntime.jsxs("linearGradient", { id: "paint1_linear_16733_50048", x1: "167.339", y1: "59.6885", x2: "167.339", y2: "143.243", gradientUnits: "userSpaceOnUse", children: [jsxRuntime.jsx("stop", { stopColor: "#D6D6D6" }), jsxRuntime.jsx("stop", { offset: "1", stopColor: "#A9A9A9" })] }), jsxRuntime.jsxs("linearGradient", { id: "paint2_linear_16733_50048", x1: "152.697", y1: "74.9941", x2: "152.697", y2: "200.433", gradientUnits: "userSpaceOnUse", children: [jsxRuntime.jsx("stop", { stopColor: "#DCDCDC" }), jsxRuntime.jsx("stop", { offset: "1", stopColor: "#A6A6A6" })] }), jsxRuntime.jsxs("linearGradient", { id: "paint3_linear_16733_50048", x1: "190.34", y1: "94.0234", x2: "190.34", y2: "143.373", gradientUnits: "userSpaceOnUse", children: [jsxRuntime.jsx("stop", { stopColor: "#D7D7D7" }), jsxRuntime.jsx("stop", { offset: "1", stopColor: "#B7B7B7" })] }), jsxRuntime.jsxs("linearGradient", { id: "paint4_linear_16733_50048", x1: "90.5522", y1: "165.828", x2: "90.5522", y2: "200.433", gradientUnits: "userSpaceOnUse", children: [jsxRuntime.jsx("stop", { stopColor: "#D7D7D7" }), jsxRuntime.jsx("stop", { offset: "1", stopColor: "#ACACAC" })] }), jsxRuntime.jsxs("linearGradient", { id: "paint5_linear_16733_50048", x1: "115.704", y1: "125.063", x2: "115.704", y2: "200.407", gradientUnits: "userSpaceOnUse", children: [jsxRuntime.jsx("stop", { stopColor: "#D9D9D9" }), jsxRuntime.jsx("stop", { offset: "1", stopColor: "#A9A9A9" })] }), jsxRuntime.jsxs("linearGradient", { id: "paint6_linear_16733_50048", x1: "147.53", y1: "174.966", x2: "147.53", y2: "232.218", gradientUnits: "userSpaceOnUse", children: [jsxRuntime.jsx("stop", { stopColor: "#C4C4C4" }), jsxRuntime.jsx("stop", { offset: "1", stopColor: "#C4C4C4", stopOpacity: "0" })] }), jsxRuntime.jsxs("linearGradient", { id: "paint7_linear_16733_50048", x1: "217.083", y1: "117.322", x2: "217.083", y2: "175.018", gradientUnits: "userSpaceOnUse", children: [jsxRuntime.jsx("stop", { stopColor: "#DEDEDE" }), jsxRuntime.jsx("stop", { offset: "1", stopColor: "#C2C2C2" })] }), jsxRuntime.jsxs("linearGradient", { id: "paint8_linear_16733_50048", x1: "179.339", y1: "155.283", x2: "206.797", y2: "202.341", gradientUnits: "userSpaceOnUse", children: [jsxRuntime.jsx("stop", { stopColor: "#7F7F7F" }), jsxRuntime.jsx("stop", { offset: "1", stopColor: "#A3A3A3" })] })] })] }));
}

const useRestoreScrollPosition = (scrollRef, isScrollTop, scollPathName) => {
    const { isMobile, pathname } = usePathLocale();
    const name = pathname;
    React.useLayoutEffect(() => {
        if (scrollRef.current && (isMobile || isScrollTop)) {
            try {
                const pos = Number(sessionStorage.getItem(`scrollPos:${name}`));
                scrollRef.current.scrollTo(0, pos);
            }
            catch (error) {
                console.error(error);
            }
        }
    }, [isMobile, pathname]);
};
const useMemoScrollPosition = (scrollRef, scollPathName) => {
    const { pathname } = usePathLocale();
    const name = pathname;
    const memoScrollPosition = React.useCallback((id) => {
        try {
            let ele = null;
            if (id && typeof id === 'string') {
                ele = window.document.getElementById(id);
            }
            else if (scrollRef) {
                ele = scrollRef.current;
            }
            if (ele) {
                sessionStorage.setItem(`scrollPos:${name}`, String((ele === null || ele === void 0 ? void 0 : ele.scrollTop) || '0'));
            }
        }
        catch (error) {
            console.error(error);
        }
    }, [pathname]);
    return memoScrollPosition;
};

function UserFollowBtn({ detailData, followCallback, size = 'lg', className }) {
    const [loading, setLoading] = React.useState(false);
    const [following, setFollowing] = React.useState((detailData === null || detailData === void 0 ? void 0 : detailData.followStatus) === exports.FollowStatus.FOLLOWED);
    const setUser = useUserStore(state => state.setUser);
    const t = nextIntl.useTranslations('profile');
    const requestT = nextIntl.useTranslations('request');
    const isLogin = useUserStore(state => state.isLogin);
    const toggleLoginModal = useGlobalStore(state => state.toggleLoginModal);
    const { success, warning } = useNotification();
    const sensors = useSensors();
    const followHandle = React.useCallback(async () => {
        if (!isLogin) {
            toggleLoginModal(true);
            return;
        }
        if ((detailData && !detailData.id) || loading)
            return;
        setLoading(true);
        const isFollow = !following;
        const res = await setUserFollow(`${detailData === null || detailData === void 0 ? void 0 : detailData.id}`, isFollow);
        if (res.success) {
            setFollowing(isFollow);
            followCallback && followCallback(isFollow);
            setLoading(false);
            const { data } = await getUserProfile();
            setUser(data);
            if (isFollow) {
                sensors.track('FollowCreator', {
                    creator_id: data === null || data === void 0 ? void 0 : data.id,
                    creator_name: data === null || data === void 0 ? void 0 : data.name
                });
            }
        }
        else {
            warning({
                content: requestT('error.common')
            });
            setLoading(false);
        }
    }, [detailData, following, loading, isLogin]);
    return (jsxRuntime.jsx(Button$1, { variant: "primary", color: following ? 'gray' : 'brand', className: cn('px-6', className), size: size, onClick: () => {
            followHandle();
        }, loading: loading, tabIndex: -1, autoFocus: false, children: following ? t('following') : t('follow') }));
}

function GalleryMoreActions({ handleDelete }) {
    const t = nextIntl.useTranslations('common');
    const isDesktop = !useGlobalStore(state => state.isMobile);
    return (jsxRuntime.jsxs(DropdownMenu, { children: [jsxRuntime.jsx(DropdownMenuTrigger, { asChild: true, tabIndex: -1, onClick: e => {
                    e.stopPropagation();
                }, children: jsxRuntime.jsx(IconButton, { icon: ForwardRef$E, size: isDesktop ? 'md' : 'sm', variant: "ghost", color: "default" }) }), jsxRuntime.jsx(DropdownMenuContent, { side: "bottom", align: "end", onClick: e => {
                    e.stopPropagation();
                }, children: jsxRuntime.jsx(DropdownMenuItem, { asChild: true, children: jsxRuntime.jsxs("div", { className: "w-full space-x-1.5 cursor-pointer", onClick: handleDelete, children: [jsxRuntime.jsx(Icon, { component: ForwardRef$l, size: "lg", color: "critical" }), jsxRuntime.jsx(Text, { size: "lg", color: "critical", children: t('delete') })] }) }) })] }));
}

function GalleryAuthorInfo({ isMobile, item, botId, deleteCallback, followCallback }) {
    var _a, _b, _c, _d, _e;
    const userId = useUserStore(state => state.userId);
    const router = useRoute();
    const [showDeleteModal, setShowDeleteModal] = React.useState(false);
    const searchParams = navigation.useSearchParams();
    const onClose = () => {
        const from = searchParams.get('from');
        const prevPath = searchParams.get('prevPath');
        if (from === 'profile' && prevPath) {
            router.openUrl(`${prevPath.replace('#', '%23')}?from=gallery`);
        }
        else {
            router.openUrl(`/gallery/${botId}`);
        }
    };
    const handleDelete = () => {
        setShowDeleteModal(true);
    };
    const { error, success } = useNotification();
    const [deleting, setDeleting] = React.useState(false);
    const t = nextIntl.useTranslations();
    const deleteGalleryItemHandle = async () => {
        setDeleting(true);
        const res = await deleteGallery(item.id);
        if (res.success) {
            success({
                content: t('common.delete_success')
            });
            setDeleting(false);
            setShowDeleteModal(false);
            deleteCallback === null || deleteCallback === void 0 ? void 0 : deleteCallback(item.id);
        }
        else {
            error({
                content: t('common.delete_error')
            });
            setDeleting(false);
        }
    };
    const sensors = useSensors();
    const handleFollow = (isFollow) => {
        if (isFollow) {
            sensors.track('GalleryPicFollow', {
                bot_id: item.botId,
                bot_name: item.botName,
                creator_id: item.authInfo.userId,
                creator_name: item.authInfo.name
            });
        }
        followCallback === null || followCallback === void 0 ? void 0 : followCallback();
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { className: "border-b border-default", children: jsxRuntime.jsxs("div", { className: "w-full py-2.5 md:py-4 px-4 md:px-6 flex justify-between items-center space-x-3 overflow-hidden", children: [jsxRuntime.jsxs("div", { className: "flex justify-start items-center space-x-1 w-full overflow-hidden", children: [isMobile && (jsxRuntime.jsx("div", { className: cn('flex z-10 space-x-3 left-4'), children: jsxRuntime.jsx(IconButton, { onClick: onClose, icon: ForwardRef$8, size: "md", variant: "ghost", color: "brand" }) })), jsxRuntime.jsxs("div", { className: "flex items-center space-x-2 overflow-hidden", children: [jsxRuntime.jsx(Avatar, { size: "md", src: getAssetsUrl((_a = item.authInfo) === null || _a === void 0 ? void 0 : _a.avatar) }), jsxRuntime.jsx(Text, { size: "lg", lineClamp: 1, weight: "medium", children: limitStringLength(item.authInfo.name, 10) })] })] }), userId && userId !== ((_b = item.authInfo) === null || _b === void 0 ? void 0 : _b.userId) ? (jsxRuntime.jsx(UserFollowBtn, { size: "sm", detailData: { id: (_c = item.authInfo) === null || _c === void 0 ? void 0 : _c.userId, followStatus: (_d = item.authInfo) === null || _d === void 0 ? void 0 : _d.followStatus }, followCallback: (isFollow) => {
                                handleFollow(isFollow);
                            }, className: "min-w-none" })) : (jsxRuntime.jsx("div", { className: "w-9 h-9" })), userId === ((_e = item.authInfo) === null || _e === void 0 ? void 0 : _e.userId) && handleDelete && jsxRuntime.jsx(GalleryMoreActions, { handleDelete: handleDelete })] }) }), jsxRuntime.jsx(GalleryDeleteTipModal, { open: showDeleteModal, deleting: deleting, onClose: () => setShowDeleteModal(false), onConfirm: () => deleteGalleryItemHandle() })] }));
}

function useGenerateShareLink(type, id, botId) {
    const getApiFn = () => {
        let apiFn;
        switch (type) {
            case 'curve':
                apiFn = () => {
                    return Promise.resolve(id);
                };
                break;
            case 'bot':
            case 'ugc':
            case 'toolbox':
            case 'room':
                apiFn = getBotSharingCode;
                break;
            case 'widget':
                apiFn = getWidgetSharingCode;
                break;
            case 'gallery':
                apiFn = getGallerySharingCode;
                break;
            default:
                apiFn = getBotSharingCode;
        }
        return apiFn;
    };
    const [generating, setGenerating] = reactUse.useToggle(false);
    const generateShareLink = async () => {
        let shareUrl = '';
        try {
            setGenerating(true);
            const code = await getApiFn()(id);
            if (type === 'curve') ;
            else if (type === 'widget') ;
            else if (type === 'gallery') {
                if (code) {
                    shareUrl = `${window.location.origin}/gallery/${botId}/${id}?code=${code}&utm_channel=referral&utm_source=share`;
                }
                else {
                    shareUrl = `${window.location.origin}/gallery/${botId}/${id}?utm_channel=referral&utm_source=share`;
                }
            }
            else ;
            return shareUrl;
        }
        catch (e) {
        }
        finally {
            setGenerating(false);
        }
    };
    return {
        generating,
        generateShareLink
    };
}

function GalleryShareBtn({ id, botId, successCb }) {
    const [shareLink, setShareLink] = React.useState('');
    const { generating, generateShareLink } = useGenerateShareLink('gallery', id, botId);
    const { onCopy } = useCopyClipboard(shareLink);
    const t = nextIntl.useTranslations();
    const copyShareLinkHandle = React.useCallback(async () => {
        let link = shareLink;
        if (!link) {
            const data = await generateShareLink();
            link = data !== null && data !== void 0 ? data : '';
            setShareLink(link);
        }
        onCopy(link);
        successCb === null || successCb === void 0 ? void 0 : successCb();
    }, [generateShareLink, onCopy, shareLink, successCb]);
    return (jsxRuntime.jsx(Button$1, { icon: ForwardRef$O, variant: "outline", color: "default", "aria-label": "share gallery", loading: generating, onClick: copyShareLinkHandle, className: "flex-1 min-w-none", children: t('bot.share') }));
}
var GalleryShareBtn$1 = React.memo(GalleryShareBtn);

function GalleryInfoSkeleon() {
    return (jsxRuntime.jsx("div", { className: "w-full h-full flex justify-center items-center md:p-2", children: jsxRuntime.jsx("div", { className: "flex-1 flex items-center justify-center", children: jsxRuntime.jsx(Spinner, { color: "brand" }) }) }));
}

function GalleryInfo({ item, botId, galleryId, isShare = false, isMobile, deleteCallback, followCallback }) {
    var _a, _b, _c, _d, _e, _f;
    const t = nextIntl.useTranslations();
    const router = useRoute();
    useNotification();
    const { downloading, onDownload } = useDownload();
    const params = navigation.useSearchParams();
    const showNsfw = useUserStore(state => state.showNsfw);
    const isVisitor = useUserStore(state => state.isVisitor);
    const [info, setInfo] = React.useState(item);
    const [isCopied, setIsCopied] = React.useState(false);
    useNotification();
    const sensors = useSensors();
    const nsfw = (info === null || info === void 0 ? void 0 : info.isNsfw) && (isVisitor === 1 || !(showNsfw === 1));
    const onCopySuccess = () => {
        setIsCopied(true);
        setTimeout(() => {
            setIsCopied(false);
            handleMouseLeave();
        }, 5000);
    };
    const { onCopy } = useCopyClipboard('', '', onCopySuccess);
    const [isHovering, setIsHovering] = React.useState(false);
    const handleMouseEnter = () => {
        setIsHovering(true);
    };
    const handleMouseLeave = () => {
        setIsHovering(false);
    };
    React.useMemo(() => {
        const count = (info === null || info === void 0 ? void 0 : info.viewCount) || 0;
        if (count >= 1000) {
            const formatCount = `${(count / 1000).toFixed(1)}k`;
            return formatCount.endsWith('.0') ? `${formatCount.slice(0, -2)}k` : `${formatCount}`;
        }
        return count;
    }, [info === null || info === void 0 ? void 0 : info.viewCount]);
    const [fetchError, setFetchError] = React.useState(false);
    const [fetchLoading, setFetchLoading] = React.useState(false);
    const getDetail = async () => {
        setFetchLoading(true);
        const res = await getGalleryDetailById(galleryId);
        if (res.success) {
            const { data } = res;
            setInfo(data.info);
        }
        else {
            setFetchError(true);
        }
        setFetchLoading(false);
    };
    const searchParams = navigation.useSearchParams();
    const deleteHandle = (galleryId) => {
        const from = searchParams.get('from');
        if (deleteCallback) {
            deleteCallback(galleryId);
        }
        if (isMobile) {
            const prevPath = searchParams.get('prevPath');
            if (from === 'profile' && prevPath) {
                router.openUrl(`${prevPath.replace('#', '%23')}?from=gallery`);
            }
            else {
                router.openUrl(`${isMobile ? '/m' : ''}/gallery/${botId}`);
            }
        }
    };
    React.useEffect(() => {
        if (!(item === null || item === void 0 ? void 0 : item.id)) {
            getDetail();
        }
        else {
            setInfo(info);
        }
    }, [item === null || item === void 0 ? void 0 : item.id]);
    const code = params.get('code');
    React.useEffect(() => {
        if (code) {
            identityService.setSharingCode(code);
        }
    }, []);
    const { pathname } = usePathLocale();
    const scrollRef = React.useRef(null);
    const memoScrollPosition = useMemoScrollPosition(scrollRef);
    const pageId = 'gallery-info-page';
    useRestoreScrollPosition(scrollRef, true);
    React.useEffect(() => {
        function handleScroll() {
            isMobile && memoScrollPosition(pageId);
        }
        const containerEl = scrollRef.current;
        if (containerEl) {
            containerEl.addEventListener('scroll', throttle(handleScroll, 500), true);
        }
        const handleUnload = () => {
            sessionStorage.setItem(`scrollPos:${pathname}`, '0');
        };
        window.addEventListener('beforeunload', handleUnload);
        return () => {
            window.removeEventListener('beforeunload', handleUnload);
            if (containerEl) {
                containerEl.removeEventListener('scroll', handleScroll, true);
            }
        };
    }, []);
    const onBackGallery = () => {
        router.push(`/gallery/${botId}`);
    };
    if (fetchLoading)
        return jsxRuntime.jsx(GalleryInfoSkeleon, {});
    if (!info && !fetchError)
        return null;
    return (jsxRuntime.jsx("div", { className: "w-full h-full flex flex-col md:flex-row overflow-y-hidden md:overflow-y-auto md:overflow-hidden rounded-b-2xl", children: fetchError ? (jsxRuntime.jsxs("div", { className: "w-full h-full flex flex-col justify-center items-center", children: [jsxRuntime.jsx(NotFoundIcon, {}), jsxRuntime.jsx(Display$1, { size: "sm", className: "mt-8 md:mt-12", children: t('invalid_link') }), jsxRuntime.jsx(Text, { size: "sm", color: "subtle", className: "mt-1.5 text-center md:text-left", children: t('invalid_link_tip') }), jsxRuntime.jsx(Button$1, { variant: "primary", size: "lg", className: "mt-6 flex justify-center items-center", onClick: () => {
                        router.openUrl(`/gallery/${botId}`);
                    }, children: t('explore') })] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [isMobile && info && (jsxRuntime.jsx(GalleryAuthorInfo, { isMobile: isMobile, item: info, botId: botId, followCallback: followCallback, deleteCallback: deleteHandle })), jsxRuntime.jsxs("div", { ref: scrollRef, id: pageId, className: "w-full h-auto flex flex-col md:flex-row flex-1 overflow-y-auto md:overflow-y-hidden z-[2]", children: [jsxRuntime.jsxs("div", { className: "relative w-full md:w-[69.9%] max-w-[836px]", children: [jsxRuntime.jsxs("div", { className: cn('w-full h-full flex justify-center bg-surface-default', isShare && 'items-center'), children: [!isMobile && code && (jsxRuntime.jsx("div", { className: cn('absolute left-6 top-3 flex z-10 space-x-3'), children: jsxRuntime.jsx(IconButton, { onClick: onBackGallery, icon: ForwardRef$R, size: "md", variant: "primary", color: "gray" }) })), (info === null || info === void 0 ? void 0 : info.galleryImageLink) && (jsxRuntime.jsx(Image$3, { className: "w-full !h-auto object-none object-top", imgClassName: cn('max-h-[540px] min-w-[96px] min-h-[96px] md:min-h-[96px] md:max-h-[836px] md:max-w-[836px] object-contain object-center', nsfw ? 'min-h-[220px]' : 'min-h-[96px]'), src: info.galleryImageLink, alt: `ai art photo:${(_a = info === null || info === void 0 ? void 0 : info.generationInfo) === null || _a === void 0 ? void 0 : _a.sourceText}` }))] }), nsfw && (jsxRuntime.jsxs("div", { className: "absolute top-0 bottom-0 bg-beta-black-10 w-full h-full flex flex-col items-center justify-center space-y-1", style: {
                                        backdropFilter: 'blur(80px)',
                                        WebkitBackdropFilter: 'blur(80px)',
                                        background: 'linear-gradient(180deg, rgba(0, 0, 0, 0.10) 0%, rgba(0, 0, 0, 0.80) 100%)'
                                    }, children: [jsxRuntime.jsx(Icon, { component: ForwardRef$B, size: "4xl", color: "static" }), jsxRuntime.jsx(Text, { size: "lg", color: "static", children: t('workshop.nsfw_bot_text') }), jsxRuntime.jsx(Text, { size: "sm", className: "opacity-80 text-center max-w-[248px]", color: "static", children: t('workshop.nsfw_gallery_user_content') }), jsxRuntime.jsx(Button$1, { size: "md", icon: ForwardRef$H, iconDirection: "right", color: "brand", variant: "primary", onClick: () => {
                                                router.openUrl('/profile/settings');
                                            }, className: "!mt-3", children: t('workshop.nsfw_bot_user_button') })] }))] }), jsxRuntime.jsxs("div", { className: "relative flex-1 flex-shrink-0 flex flex-col bg-surface-default w-full md:w-[31.1%] min-w-[300px] text-justify md:border-l md:border-default", children: [!isMobile && info && (jsxRuntime.jsx(GalleryAuthorInfo, { isMobile: isMobile, item: info, botId: botId, followCallback: followCallback, deleteCallback: deleteHandle })), jsxRuntime.jsxs("div", { className: "px-3 md:px-4 space-y-4 py-4 flex-1 overflow-y-auto pb-[107px] md:pb-0", children: [jsxRuntime.jsxs(Text, { size: "sm", color: "subtle", className: clsx__default.default('block relative md:p-2 min-h-11', {
                                                'bg-surface-hovered rounded-md': isHovering
                                            }), onClick: () => {
                                                var _a;
                                                if (isMobile) {
                                                    onCopy(`${(_a = info === null || info === void 0 ? void 0 : info.generationInfo) === null || _a === void 0 ? void 0 : _a.sourceText}`);
                                                }
                                            }, onMouseEnter: () => {
                                                if (!isMobile) {
                                                    handleMouseEnter();
                                                }
                                            }, onMouseLeave: () => {
                                                if (!isMobile) {
                                                    handleMouseLeave();
                                                }
                                            }, children: [((_b = info === null || info === void 0 ? void 0 : info.generationInfo) === null || _b === void 0 ? void 0 : _b.sourceText) || t('chat.no_text_input'), ((_c = info === null || info === void 0 ? void 0 : info.generationInfo) === null || _c === void 0 ? void 0 : _c.sourceText) && isHovering && (jsxRuntime.jsx("div", { className: "absolute bottom-2 right-0 p-2 h-7 rounded-full flex justify-center items-center", onClick: e => {
                                                        var _a;
                                                        onCopy(`${(_a = info === null || info === void 0 ? void 0 : info.generationInfo) === null || _a === void 0 ? void 0 : _a.sourceText}`);
                                                    }, children: jsxRuntime.jsx(Button$1, { icon: ForwardRef$F, size: "sm", variant: "primary", color: "gray", "aria-label": "copy text", className: "flex-1 min-w-none", children: isCopied ? t('common.copied') : t('common.copy') }) }))] }), ((_d = info === null || info === void 0 ? void 0 : info.generationInfo) === null || _d === void 0 ? void 0 : _d.sourceImageLink) && (jsxRuntime.jsxs("div", { className: "relative w-14 h-14", onClick: () => {
                                                var _a;
                                                if (nsfw) {
                                                    router.openUrl('/profile/settings');
                                                }
                                                else {
                                                    router.openUrl((_a = info === null || info === void 0 ? void 0 : info.generationInfo) === null || _a === void 0 ? void 0 : _a.sourceImageLink);
                                                }
                                            }, children: [nsfw && ((_e = info === null || info === void 0 ? void 0 : info.generationInfo) === null || _e === void 0 ? void 0 : _e.sourceImageLink) && (jsxRuntime.jsx("div", { className: "absolute top-0 bottom-0 z-[1] bg-beta-black-10 w-full h-full flex flex-col items-center justify-center space-y-1 rounded-xl cursor-pointer", style: {
                                                        backdropFilter: 'blur(20px)',
                                                        background: isMobile
                                                            ? 'linear-gradient(180deg, rgba(0, 0, 0, 0.10) 0%, rgba(0, 0, 0, 0.80) 100%)'
                                                            : ''
                                                    }, children: jsxRuntime.jsx(Icon, { component: ForwardRef$B, size: "xl", color: "inverse" }) })), jsxRuntime.jsx(Avatar, { size: "2xl", src: (_f = info === null || info === void 0 ? void 0 : info.generationInfo) === null || _f === void 0 ? void 0 : _f.sourceImageLink }), jsxRuntime.jsx("div", { className: "absolute right-0 bottom-0 w-4.5 h-4.5 bg-surface-default flex justify-center items-center rounded-md", children: jsxRuntime.jsx(Icon, { component: ForwardRef$s, size: "xs", className: "flex justify-center items-center border-2 border-surface-default" }) })] })), jsxRuntime.jsx("div", { className: "md:px-2 flex-shrink-0 space-x-1 flex justify-start items-center" })] }), jsxRuntime.jsxs("div", { className: "border-t border-default absolute md:relative w-full left-0 bottom-0 z-10 bg-surface-default", children: [jsxRuntime.jsx("div", { className: "w-full py-4 px-4 flex justify-between items-center space-x-4", children: jsxRuntime.jsxs("div", { className: "w-full flex justify-between items-center space-x-4", children: [jsxRuntime.jsx(Button$1, { tabIndex: -1, icon: ForwardRef$T, variant: "outline", color: "default", "aria-label": "download file", loading: downloading, onClick: () => {
                                                            if (info) {
                                                                onDownload(info === null || info === void 0 ? void 0 : info.galleryImageLink, info === null || info === void 0 ? void 0 : info.id, () => {
                                                                    var _a, _b;
                                                                    sensors.track('GalleryPicDownload', {
                                                                        picture_id: info === null || info === void 0 ? void 0 : info.galleryImageLink,
                                                                        bot_id: info === null || info === void 0 ? void 0 : info.botId,
                                                                        bot_name: info === null || info === void 0 ? void 0 : info.botName,
                                                                        creator_id: (_a = info.authInfo) === null || _a === void 0 ? void 0 : _a.userId,
                                                                        creator_name: (_b = info.authInfo) === null || _b === void 0 ? void 0 : _b.name
                                                                    });
                                                                });
                                                            }
                                                        }, className: "flex-1 min-w-none", children: t('chat.Download') }), info && (jsxRuntime.jsx(GalleryShareBtn$1, { id: info === null || info === void 0 ? void 0 : info.id, botId: info === null || info === void 0 ? void 0 : info.botId, successCb: () => {
                                                            var _a, _b;
                                                            sensors.track('GalleryPicShare', {
                                                                picture_id: info === null || info === void 0 ? void 0 : info.galleryImageLink,
                                                                bot_id: info === null || info === void 0 ? void 0 : info.botId,
                                                                bot_name: info === null || info === void 0 ? void 0 : info.botName,
                                                                creator_id: (_a = info === null || info === void 0 ? void 0 : info.authInfo) === null || _a === void 0 ? void 0 : _a.userId,
                                                                creator_name: (_b = info === null || info === void 0 ? void 0 : info.authInfo) === null || _b === void 0 ? void 0 : _b.name
                                                            });
                                                        } }))] }) }), isShare && (jsxRuntime.jsx("div", { className: "px-4 pb-4", children: jsxRuntime.jsx(Button$1, { icon: GenerateIcon, isBlock: true, variant: "primary", color: "brand", onClick: () => {
                                                    router.openUrl(`/chat/${botId}`);
                                                }, children: t('chat.go_to_gallery') }) }))] })] })] })] })) }));
}

function GalleryCard({ item, from = 'gallery', deleteCallback, followCallback }) {
    var _a;
    const isMobile = useGlobalStore(state => state.isMobile);
    const t = nextIntl.useTranslations();
    const [showInfo, setShowInfo] = React.useState(false);
    const [showDeleteModal, setShowDeleteModal] = React.useState(false);
    const pathName = navigation.usePathname();
    const showNsfw = useUserStore(state => state.showNsfw);
    const isVisitor = useUserStore(state => state.isVisitor);
    const nsfw = (item === null || item === void 0 ? void 0 : item.isNsfw) && (isVisitor === 1 || !(showNsfw === 1));
    const userId = useUserStore(state => state.userId);
    const sensors = useSensors();
    React.useMemo(() => {
        const count = item === null || item === void 0 ? void 0 : item.viewCount;
        if (count >= 1000) {
            const formatCount = `${(item.viewCount / 1000).toFixed(1)}k`;
            return formatCount.endsWith('.0') ? `${formatCount.slice(0, -2)}k` : `${formatCount}`;
        }
        return count;
    }, [item === null || item === void 0 ? void 0 : item.viewCount]);
    const [isHovering, setIsHovering] = React.useState(false);
    const handleMouseEnter = () => {
        setIsHovering(true);
    };
    const handleMouseLeave = () => {
        setIsHovering(false);
    };
    const showDeleteModalHandle = () => {
        setShowDeleteModal(true);
    };
    const { error, success } = useNotification();
    const [deleting, setDeleting] = React.useState(false);
    const deleteGalleryItemHandle = async () => {
        setDeleting(true);
        const res = await deleteGallery(item.id);
        if (res.success) {
            success({
                content: t('common.delete_success')
            });
            setDeleting(false);
            setShowDeleteModal(false);
            deleteCallback === null || deleteCallback === void 0 ? void 0 : deleteCallback(item.id);
        }
        else {
            error({
                content: t('common.delete_error')
            });
            setDeleting(false);
        }
    };
    const cardClickHandle = (e) => {
        sensors.track('GalleryPicClick', {
            bot_id: item.botId,
            bot_name: item.botName,
            picture_id: item.galleryImageLink,
            creator_id: item.authInfo.userId,
            creator_name: item.authInfo.name
        });
        if (!isMobile) {
            e.preventDefault();
            e.stopPropagation();
            setShowInfo(true);
        }
    };
    React.useEffect(() => {
        if (!showInfo) {
            document.body.style.pointerEvents = '';
        }
    }, [showInfo]);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(Link$1, { href: `${isMobile ? '/m' : ''}/gallery/${item.botId}/${item.id}?from=${from}&prevPath=${pathName}`, className: "block relative rounded-xl overflow-hidden cursor-pointer", onMouseEnter: () => {
                    if (!isMobile) {
                        handleMouseEnter();
                    }
                }, onMouseLeave: () => {
                    if (!isMobile) {
                        handleMouseLeave();
                    }
                }, onClick: cardClickHandle, children: [jsxRuntime.jsx("div", { className: "rounded-xl overflow-hidden ease-in-out duration-300 hover:scale-105", children: jsxRuntime.jsx(Image$3, { className: "rounded-xl min-h-[220px] max-h-[360px] md:max-h-[440px] bg-surface-container-hovered overflow-hidden", imgClassName: "min-h-[220px] max-h-[360px] md:max-h-[440px] object-cover", src: item.galleryImageLink, alt: `ai art photo:${(_a = item === null || item === void 0 ? void 0 : item.generationInfo) === null || _a === void 0 ? void 0 : _a.sourceText}` }) }), jsxRuntime.jsxs("div", { className: cn('absolute z-10 w-full p-3 overflow-hidden', nsfw ? 'bottom-0 left-0 h-full flex flex-col justify-end rounded-xl' : 'bottom-0 left-0 rounded-b-xl'), style: {
                            backdropFilter: nsfw ? 'blur(32px)' : '',
                            WebkitBackdropFilter: nsfw ? 'blur(32px)' : '',
                            background: nsfw
                                ? 'linear-gradient(180deg, rgba(0, 0, 0, 0.10) 0%, rgba(0, 0, 0, 0.80) 100%)'
                                : 'linear-gradient(180deg, rgba(0, 0, 0, 0.00) 0%, rgba(0, 0, 0, 0.60) 100%)'
                        }, children: [nsfw && (jsxRuntime.jsxs("div", { className: "absolute top-0 left-0 p-5 w-full h-full flex flex-col justify-center items-center space-y-1 rounded-xl", children: [jsxRuntime.jsx(Icon, { component: ForwardRef$B, size: "4xl", color: "static" }), jsxRuntime.jsx(Text, { size: "lg", color: "static", children: t('workshop.nsfw_bot_text') }), jsxRuntime.jsx(Text, { size: "sm", className: "opacity-60 text-center", color: "static", children: t('workshop.nsfw_gallery_user_content') })] })), jsxRuntime.jsxs("div", { className: "flex justify-between", children: [jsxRuntime.jsxs("div", { className: "flex-1 flex justify-start items-center space-x-1.5 max-w-[70%]", children: [jsxRuntime.jsx(Avatar, { size: "xs", src: getAssetsUrl(item.authInfo.avatar) }), jsxRuntime.jsx(Text, { size: "sm", className: "w-full", weight: "medium", color: "static", lineClamp: 1, children: isMobile ? item.authInfo.name : limitStringLength(item.authInfo.name, 10) })] }), jsxRuntime.jsx("div", { className: "flex-shrink-0 space-x-1 flex justify-end items-center" })] })] }), userId === item.authInfo.userId && isHovering && (jsxRuntime.jsx("div", { className: "absolute z-20 top-2 right-2 p-2 rounded-full bg-beta-black-20 h-9 w-9 flex justify-center items-center", style: { backdropFilter: 'blur(12px)' }, onClick: e => {
                            e.stopPropagation();
                            e.preventDefault();
                            showDeleteModalHandle();
                        }, children: jsxRuntime.jsx(Icon, { component: ForwardRef$l, color: "static" }) }))] }), jsxRuntime.jsx(Modal, { open: showInfo, onClose: () => {
                    setShowInfo(false);
                }, onOpenChange: open => {
                    !open && setShowInfo(false);
                }, overlayClassName: "z-[90]", contentClassName: "w-[90%] max-w-[1197px] h-[calc(100vh-64px)] max-h-[836px] overflow-hidden rounded-2xl z-[100] bg-transparent", fullScreen: true, overlayClose: false, children: jsxRuntime.jsx("div", { className: "relative overflow-hidden w-full h-full rounded-2xl", children: jsxRuntime.jsx("div", { className: "w-full h-full relative overflow-hidden", children: jsxRuntime.jsx(GalleryInfo, { item: item, botId: item.botId, galleryId: item.id, deleteCallback: () => {
                                setShowInfo(false);
                                deleteCallback === null || deleteCallback === void 0 ? void 0 : deleteCallback(item.id);
                            }, followCallback: followCallback }) }) }) }), jsxRuntime.jsx(GalleryDeleteTipModal, { open: showDeleteModal, deleting: deleting, onClose: () => setShowDeleteModal(false), onConfirm: () => deleteGalleryItemHandle() })] }));
}

function GalleryListSkeleton({ isMobile }) {
    return (jsxRuntime.jsx("div", { className: "h-screen flex-1 flex items-center justify-center", children: jsxRuntime.jsx(Spinner, { color: "brand" }) }));
}

function useGetGalleryList({ userId, botId }) {
    const galleryList = useGalleryStore(state => state.galleryList);
    const setGalleryList = useGalleryStore(state => state.setGalleryList);
    const galleryUserList = useGalleryStore(state => state.galleryUserList);
    const setGalleryUserList = useGalleryStore(state => state.setGalleryUserList);
    const [hasMore, setHasMore] = React.useState(false);
    const [loading, setLoading] = React.useState(false);
    const [nextPageToken, setNextPageToken] = React.useState('0');
    const pageCount = React.useRef(0);
    const [fetchError, setFetchError] = React.useState(false);
    const [fetchEmpty, setFetchEmpty] = React.useState(false);
    const getGalleryData = async (pageToken) => {
        if (pageToken !== '0' && hasMore === false) {
            return;
        }
        setLoading(true);
        const res = await getGalleryList({ pageToken, botId, userId });
        setLoading(false);
        const { data } = res;
        if (res.success) {
            const d = Array.isArray(data.list) ? data.list.filter((item) => !!item && typeof item === 'object') : [];
            if (userId) {
                setGalleryUserList(pageToken === '0' ? d : [...galleryUserList, ...d]);
            }
            else {
                setGalleryList(pageToken === '0' ? d : [...galleryList, ...d]);
            }
            setFetchEmpty(pageToken === '0' && d.length === 0);
            setNextPageToken(data.listResponse.nextPageToken);
            setHasMore(data.listResponse.hasMore);
            pageCount.current += 1;
        }
        else {
            setFetchError(false);
        }
    };
    return {
        loading,
        hasMore,
        nextPageToken,
        fetchError,
        fetchEmpty,
        getGalleryData
    };
}

function GalleryList({ className, userId, containerRef }) {
    const t = nextIntl.useTranslations();
    const isMobile = useGlobalStore(state => state.isMobile);
    const galleryUserList = useGalleryStore(state => state.galleryUserList);
    const setGalleryUserList = useGalleryStore(state => state.setGalleryUserList);
    const { fetchEmpty, fetchError, loading, getGalleryData, hasMore, nextPageToken } = useGetGalleryList({
        userId
    });
    React.useEffect(() => {
        getGalleryData('0');
    }, []);
    const handleScroll = React.useCallback(() => {
        if (containerRef.current) {
            const { scrollTop, scrollHeight, clientHeight } = containerRef.current;
            if (scrollTop + clientHeight >= scrollHeight - 10) {
                getGalleryData(nextPageToken);
            }
        }
    }, [nextPageToken]);
    React.useEffect(() => {
        const container = containerRef.current;
        if (container) {
            container.addEventListener('scroll', handleScroll);
            return () => container.removeEventListener('scroll', handleScroll);
        }
    }, [handleScroll]);
    const deleteCallback = (id) => {
        const galleryListFilter = galleryUserList === null || galleryUserList === void 0 ? void 0 : galleryUserList.filter(item => item.id !== id);
        setGalleryUserList(galleryListFilter);
    };
    const followCallback = (userId) => {
        const galleryListUpdate = galleryUserList === null || galleryUserList === void 0 ? void 0 : galleryUserList.map(item => {
            const status = item.authInfo.followStatus === exports.FollowStatus.FOLLOWED ? exports.FollowStatus.NOT_FOLLOWED : exports.FollowStatus.FOLLOWED;
            item.authInfo.userId === userId && (item.authInfo.followStatus = status);
            return item;
        });
        setGalleryUserList(galleryListUpdate);
    };
    if (!userId) {
        return null;
    }
    return (jsxRuntime.jsxs("div", { className: "px-2 md:px-3.5", children: [loading && galleryUserList.length === 0 && jsxRuntime.jsx(GalleryListSkeleton, { isMobile: isMobile }), !fetchError && (galleryUserList === null || galleryUserList === void 0 ? void 0 : galleryUserList.length) > 0 ? (jsxRuntime.jsxs(Masonry, { className: "my-masonry-grid", columnClassName: "my-masonry-grid_column", children: [galleryUserList === null || galleryUserList === void 0 ? void 0 : galleryUserList.map((item, i) => {
                        return (jsxRuntime.jsx(GalleryCard, { item: item, deleteCallback: (id) => deleteCallback(id), followCallback: () => {
                                followCallback(item.authInfo.userId);
                            }, from: "profile" }, item.id));
                    }), hasMore &&
                        loading &&
                        [...Array(15)].map((_, index) => {
                            const height = Math.random() * 500;
                            return (jsxRuntime.jsx(Skeleton, { style: {
                                    height: height < 300 ? 300 : height
                                } }, index));
                        })] })) : null, !loading && !fetchError && (fetchEmpty || galleryUserList.length === 0) && (jsxRuntime.jsxs("div", { className: "w-full h-full flex flex-col justify-center items-center px-10 space-y-3", children: [jsxRuntime.jsx(Icon, { component: PhotoStackIcon, size: "4xl", color: "subtlest" }), jsxRuntime.jsxs("div", { className: "flex flex-col justify-center items-center space-y-1", children: [jsxRuntime.jsx(Display$1, { size: "sm", color: "default", children: t('chat.no_content_yet') }), jsxRuntime.jsx(Text, { size: "sm", color: "subtlest", children: t('chat.be_fist_publish') })] })] })), fetchError && (jsxRuntime.jsx(ErrorState, { onClick: () => {
                    getGalleryData('0');
                }, className: "pt-20" }))] }));
}

const formatCount = (count) => {
    const num = Number(count);
    if (num > 1000) {
        return `${(num / 1000).toFixed(1)}k`;
    }
    return num;
};
function FollowInfo({ user }) {
    usePathLocale();
    const t = nextIntl.useTranslations('profile');
    if (!user)
        return null;
    return (jsxRuntime.jsxs("div", { className: "text-base flex items-center", children: [jsxRuntime.jsx("span", { className: "text-subtle mr-1", children: t('follower') }), jsxRuntime.jsx("span", { className: "text-default font-medium", children: formatCount(user === null || user === void 0 ? void 0 : user.fansCount) }), jsxRuntime.jsx("p", { className: "border-r mx-2 h-[16px]" }), jsxRuntime.jsx("span", { className: "text-subtle mr-1", children: t('following') }), jsxRuntime.jsx("span", { className: "text-default font-medium", children: formatCount(user === null || user === void 0 ? void 0 : user.followedCount) })] }));
}

function TryTTSBtn({ widgetId }) {
    const { warning } = useNotification();
    const t = nextIntl.useTranslations('workshop');
    const { value: loading, setTrue, setFalse } = usehooksTs.useBoolean(false);
    const { value: playing, setTrue: setPlaying, setFalse: setPlayingFalse } = usehooksTs.useBoolean(false);
    const [trailVoiceUrl, setTrailVoiceUrl] = React.useState();
    const ref = React.useRef(null);
    const onPlay = () => {
        setPlaying();
    };
    const handlePlay = () => {
        if (ref.current) {
            if (ref.current.paused) {
                ref.current.play();
            }
        }
    };
    const handlePause = () => {
        if (ref.current && !ref.current.paused) {
            ref.current.pause();
            setPlayingFalse();
        }
    };
    const handleError = () => {
        warning({
            content: t('tts_widget_trail_failed')
        });
        setTrailVoiceUrl(undefined);
    };
    const handleEnded = () => {
        if (ref.current) {
            setPlayingFalse();
        }
    };
    const handleClick = async (e) => {
        e.preventDefault();
        if (playing) {
            handlePause();
        }
        else {
            if (!trailVoiceUrl) {
                await tryVoice();
            }
            handlePlay();
        }
    };
    const tryVoice = async () => {
        try {
            setTrue();
            const { data, success } = await ttsWidgetTrail(widgetId);
            if (!success) {
                warning({
                    content: t('tts_widget_trail_failed')
                });
                return;
            }
            setTrailVoiceUrl(data);
        }
        catch (e) {
        }
        finally {
            setFalse();
        }
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Button$1, { variant: "primary", color: "default", className: "w-7 h-7 px-1 min-w-7", onClick: handleClick, loading: loading, children: playing ? (jsxRuntime.jsx(ForwardRef$r, { className: "w-[14px] h-[14px] text-brand stroke-[2px]" })) : (jsxRuntime.jsx(ForwardRef$p, { className: "w-[14px] h-[14px] text-brand stroke-[2px]" })) }), trailVoiceUrl && (jsxRuntime.jsx("audio", { ref: ref, src: trailVoiceUrl, onError: handleError, autoPlay: true, onPlay: onPlay, onEnded: handleEnded }))] }));
}

function TagItem({ iconUrl, label, link, hoverContent, showHoverableContent, className }) {
    const Item = () => {
        return (jsxRuntime.jsxs("div", { className: "flex gap-[2px] items-center", children: [iconUrl && jsxRuntime.jsx("img", { src: iconUrl, alt: "tag emoji", className: "size-[14px]" }), jsxRuntime.jsx("span", { className: "text-xs text-default font-medium truncate line-clamp-1", children: label })] }));
    };
    return (jsxRuntime.jsx("li", { className: cn('inline-block px-2 py-[3px] shrink-0 rounded-md bg-surface-accent-gray-subtler', className), children: link ? (jsxRuntime.jsx(Link$1, { href: link, className: cn('w-full h-full'), children: jsxRuntime.jsx(Item, {}) })) : (jsxRuntime.jsx(jsxRuntime.Fragment, { children: showHoverableContent ? (jsxRuntime.jsx(Tooltip, { description: hoverContent, showArrow: false, contentClassName: "max-w-80", triggerClassName: "inline", children: jsxRuntime.jsx(Item, {}) })) : (jsxRuntime.jsx(Item, {})) })) }));
}
function Tag({ showHoverableContent = false, hoverContent = '', iconUrl, label, link, className }) {
    return (jsxRuntime.jsx(TagItem, { iconUrl: iconUrl, link: link, label: label, hoverContent: hoverContent, showHoverableContent: showHoverableContent, className: className }));
}

function Tags({ tags, beforeTag, tagLink, showCount }) {
    if (!tags.length)
        return null;
    return (jsxRuntime.jsx("ul", { className: "w-full flex items-center flex-wrap", children: (tags !== null && tags !== void 0 ? tags : []).slice(0, showCount !== null && showCount !== void 0 ? showCount : (tags !== null && tags !== void 0 ? tags : []).length).map(item => {
            var _a, _b;
            return (jsxRuntime.jsx(Tag, { showHoverableContent: (_a = item.extra) === null || _a === void 0 ? void 0 : _a.isShowHover, hoverContent: (_b = item.extra) === null || _b === void 0 ? void 0 : _b.hoverText, iconUrl: item.iconUrl, label: item.label, link: tagLink && item.seoId && `${tagLink}/${item.seoId}?filter=${item.seoId}`, className: "mr-1.5 mb-1.5" }, item.id));
        }) }));
}

function NormalCard(props) {
    var _a;
    const { item, isLine, showChat, size = 'default', className, linkClassName, inBox, showTags, setShowUserDetail, from, disableJumpToChat, onClick, dividerClassName } = props;
    const { isMobile } = usePathLocale();
    const t = nextIntl.useTranslations();
    const router = navigation.useRouter();
    const [buttonUrl, clickUrl] = React.useMemo(() => {
        var _a;
        return [
            (item === null || item === void 0 ? void 0 : item.buttonUrl)
                ? `${item === null || item === void 0 ? void 0 : item.buttonUrl}${((_a = item === null || item === void 0 ? void 0 : item.buttonUrl) === null || _a === void 0 ? void 0 : _a.includes('?')) ? '&' : '?'}${from ? `from=${from}` : ''}`
                : item === null || item === void 0 ? void 0 : item.buttonUrl,
            (item === null || item === void 0 ? void 0 : item.clickUrl)
                ? `${item === null || item === void 0 ? void 0 : item.clickUrl}${(item === null || item === void 0 ? void 0 : item.clickUrl.includes('?')) ? '&' : '?'}${from ? `from=${from}` : ''}`
                : item === null || item === void 0 ? void 0 : item.clickUrl
        ];
    }, [item === null || item === void 0 ? void 0 : item.buttonUrl, item === null || item === void 0 ? void 0 : item.clickUrl, from]);
    return (jsxRuntime.jsxs("div", { className: cn('normal-item w-full cursor-pointer rounded-xl overflow-hidden', className), onClick: onClick ? () => onClick(item === null || item === void 0 ? void 0 : item.id) : undefined, children: [jsxRuntime.jsxs(Link$1, { className: cn('w-full px-0 md:px-2.5 flex flex-row justify-start items-center rounded-xl overflow-hidden', size === 'sm' ? 'h-18' : 'h-[88px]', !inBox && 'hover:bg-surface-container-hovered transition-all', linkClassName), href: disableJumpToChat ? '' : `${showChat ? buttonUrl : clickUrl}`, children: [jsxRuntime.jsx(Avatar, { size: size === 'sm' ? 'xl' : '4xl', src: item === null || item === void 0 ? void 0 : item.logoUrl, alt: "avatar" }), jsxRuntime.jsx("div", { className: cn('w-[calc(100%-84px)] flex-1 flex flex-col justify-center items-start ml-3 text-sm', size === 'sm' ? 'h-[46px]' : 'h-[84px]'), children: jsxRuntime.jsxs("div", { className: cn('w-full', showChat || (item === null || item === void 0 ? void 0 : item.showVoice) ? 'flex justify-center items-center' : ''), children: [jsxRuntime.jsxs("div", { className: cn('h-full flex-1 flex flex-col  text-sm space-y-0.5', !(item === null || item === void 0 ? void 0 : item.showVoice) ? 'md:justify-between items-start' : 'min-w-0'), children: [jsxRuntime.jsx(Text, { size: "lg", weight: "medium", color: inBox ? 'static' : 'default', lineClamp: 1, children: item === null || item === void 0 ? void 0 : item.title }), showTags ? (jsxRuntime.jsx("div", { className: "flex gap-2", children: ((_a = ((item === null || item === void 0 ? void 0 : item.tags) || [])) === null || _a === void 0 ? void 0 : _a.length) > 0 ? (jsxRuntime.jsx(Tags, { tags: item.tags, showCount: 4 })) : (jsxRuntime.jsx("div", { className: "h-[22px]" })) })) : (jsxRuntime.jsx(Text, { size: "sm", weight: "regular", color: inBox ? 'static' : 'subtler', lineClamp: size === 'sm' ? 1 : 2, className: cn('max-w-full break-words', inBox && 'text-beta-white-80'), style: {
                                                wordBreak: 'break-word'
                                            }, dangerous: true, children: (item === null || item === void 0 ? void 0 : item.description) || t('bot.no_desc') })), item.authorName && item.authorNameTag && (jsxRuntime.jsxs(Description$1, { size: "lg", weight: "medium", lineClamp: 1, className: cn('text-brand max-w-full break-words hover:underline'), style: {
                                                wordBreak: 'break-word'
                                            }, onClick: e => {
                                                e.stopPropagation();
                                                e.preventDefault();
                                                if (isMobile) {
                                                    const userUrl = `${window.location.origin}/explore/profile/${encodeURIComponent(`${item.authorName}`)}/${encodeURIComponent(`${item.authorNameTag}`)}`;
                                                    router.push(userUrl);
                                                }
                                                else {
                                                    typeof setShowUserDetail === 'function' &&
                                                        setShowUserDetail({
                                                            name: encodeURIComponent(`${item.authorName}`),
                                                            nameTag: encodeURIComponent(`${item.authorNameTag}`)
                                                        });
                                                }
                                            }, children: ["@", item.authorName] }))] }), showChat && (item === null || item === void 0 ? void 0 : item.buttonTitle) && (item === null || item === void 0 ? void 0 : item.buttonUrl) && (jsxRuntime.jsx(Button$1, { variant: "static", size: "sm", children: item === null || item === void 0 ? void 0 : item.buttonTitle })), (item === null || item === void 0 ? void 0 : item.showVoice) && (jsxRuntime.jsx("div", { className: "flex-shrink-0 ml-2", children: jsxRuntime.jsx(TryTTSBtn, { widgetId: item.id }) }))] }) })] }), isLine && (jsxRuntime.jsx("div", { className: cn('pl-4', size === 'sm' ? 'ml-12' : 'ml-[72px]'), children: jsxRuntime.jsx("hr", { className: cn('w-full border-t-0 border-b border-default mt-2', dividerClassName) }) }))] }, `normal-item-${item === null || item === void 0 ? void 0 : item.id}`));
}

function CustomSketelon({ customClass, children, animate = true }) {
    return jsxRuntime.jsx("div", { className: cn('bg-surface-container-hovered', customClass, animate && 'animate-pulse '), children: children });
}

function NormalCardSkeleton({ className, size = 'default' }) {
    return (jsxRuntime.jsxs("div", { className: cn('w-full px-0 md:px-2.5 flex flex-row justify-start items-center rounded-xl overflow-hidden', className, size === 'sm' ? 'h-18' : 'h-[88px]'), children: [jsxRuntime.jsx(CustomSketelon, { customClass: cn('flex-shrink-0 rounded-2xl mr-3', size === 'sm' ? 'h-[48px] w-[48px]' : 'h-18 w-18') }), jsxRuntime.jsxs("div", { className: "flex justify-center flex-col w-full space-y-1", children: [size === 'default' && jsxRuntime.jsx(CustomSketelon, { customClass: "w-[60%] h-[16px] rounded" }), jsxRuntime.jsx(CustomSketelon, { customClass: "w-full h-[16px] rounded" }), jsxRuntime.jsx(CustomSketelon, { customClass: cn('h-[16px] rounded', size === 'default' ? 'w-[20%]' : 'w-[35%]') })] })] }));
}

function UserBotList({ bots, loading, disableJumpToChat, onBotClick, selectedBotId, from, containerClassName, itemBoxClassName, itemLinkClassName, itemDividerClassName }) {
    var _a;
    const t = nextIntl.useTranslations('profile');
    const botList = (bots === null || bots === void 0 ? void 0 : bots.map(item => {
        return {
            title: item.name,
            description: item.description,
            logoUrl: item.logoUrl,
            id: item.id,
            clickUrl: `/chat/${item.id}`,
            clickMobileUrl: `/chat/${item.id}`,
            type: 'BOT'
        };
    })) || [];
    return (jsxRuntime.jsx(jsxRuntime.Fragment, { children: loading && bots.length === 0 ? (jsxRuntime.jsx("div", { className: cn('grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-2', containerClassName), children: (_a = Array(4)
                .fill(1)) === null || _a === void 0 ? void 0 : _a.map((item, index) => {
                return jsxRuntime.jsx(NormalCardSkeleton, { size: "sm" }, `bots-skeleton-${index}`);
            }) })) : (jsxRuntime.jsx("div", { className: cn('grid grid-cols-1 gap-x-4 gap-y-2', (bots === null || bots === void 0 ? void 0 : bots.length) > 0 ? 'md:grid-cols-2' : '', containerClassName), children: (botList === null || botList === void 0 ? void 0 : botList.length) > 0 ? (jsxRuntime.jsx(jsxRuntime.Fragment, { children: botList === null || botList === void 0 ? void 0 : botList.map((item, index) => {
                    return (jsxRuntime.jsx(NormalCard, { className: itemBoxClassName, linkClassName: itemLinkClassName, dividerClassName: cn(selectedBotId === item.id ? 'border-brand' : '', itemDividerClassName), from: from || 'Aipp Launch', size: "sm", item: item, isLine: true, disableJumpToChat: disableJumpToChat, onClick: () => {
                            const bot = bots.find(({ id }) => id === item.id);
                            if (!bot) {
                                return;
                            }
                            onBotClick === null || onBotClick === void 0 ? void 0 : onBotClick(bot);
                        } }, `bots-common-item-${index}`));
                }) })) : (jsxRuntime.jsx("div", { className: "text-default h-[120px] flex justify-center items-center", children: t('no_public_bots') }, "no_public_bots")) })) }));
}

const CameraIcon = (props) => (jsxRuntime.jsxs(react.Icon, Object.assign({ viewBox: "0 0 24 24", fill: "none" }, props, { children: [jsxRuntime.jsx("path", { d: "M12 9C9.92893 9 8.25 10.6789 8.25 12.75C8.25 14.8211 9.92893 16.5 12 16.5C14.0711 16.5 15.75 14.8211 15.75 12.75C15.75 10.6789 14.0711 9 12 9Z", fill: "currentColor" }), jsxRuntime.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.34429 3.07113C10.2236 3.02391 11.109 3 12 3C12.891 3 13.7764 3.02391 14.6557 3.07113C15.6233 3.12309 16.4854 3.65612 16.9882 4.46184L17.8094 5.77786C18.0485 6.16099 18.4544 6.42131 18.9195 6.48741C19.3049 6.54218 19.6888 6.60145 20.0713 6.66518C21.5031 6.90378 22.5 8.15785 22.5 9.57403V18C22.5 19.6569 21.1569 21 19.5 21H4.5C2.84315 21 1.5 19.6569 1.5 18V9.57402C1.5 8.15784 2.49686 6.90377 3.92872 6.66517C4.31116 6.60144 4.6951 6.54217 5.08048 6.4874C5.54556 6.42131 5.95152 6.16099 6.19061 5.77785L7.01181 4.46184C7.5146 3.65612 8.37667 3.12309 9.34429 3.07113ZM6.75 12.75C6.75 9.8505 9.1005 7.5 12 7.5C14.8995 7.5 17.25 9.8505 17.25 12.75C17.25 15.6495 14.8995 18 12 18C9.1005 18 6.75 15.6495 6.75 12.75ZM18.75 11.25C19.1642 11.25 19.5 10.9142 19.5 10.5C19.5 10.0858 19.1642 9.75 18.75 9.75C18.3358 9.75 18 10.0858 18 10.5C18 10.9142 18.3358 11.25 18.75 11.25Z", fill: "currentColor" })] })));

var BotStatusEnum;
(function (BotStatusEnum) {
    BotStatusEnum["BOT_STATUS_UNSPECIFIED"] = "BOT_STATUS_UNSPECIFIED";
    BotStatusEnum["Public"] = "Public";
    BotStatusEnum["Active"] = "Active";
    BotStatusEnum["Inactive"] = "Inactive";
})(BotStatusEnum || (BotStatusEnum = {}));
var VoiceStatus;
(function (VoiceStatus) {
    VoiceStatus["Pending"] = "pending";
    VoiceStatus["Processing"] = "processing";
    VoiceStatus["Failed"] = "failed";
    VoiceStatus["Done"] = "done";
})(VoiceStatus || (VoiceStatus = {}));
var BotPhotoTypeEnum;
(function (BotPhotoTypeEnum) {
    BotPhotoTypeEnum["BACKGROUND"] = "BACKGROUND";
    BotPhotoTypeEnum["OTHER"] = "OTHER";
})(BotPhotoTypeEnum || (BotPhotoTypeEnum = {}));
var LLMModelCategoryEnum;
(function (LLMModelCategoryEnum) {
    LLMModelCategoryEnum["BOT_CHAT_MODEL_CATEGORY_UNSPECIFIED"] = "BOT_CHAT_MODEL_CATEGORY_UNSPECIFIED";
    LLMModelCategoryEnum["BOT_CHAT_MODEL_CATEGORY_CLOSESOURCE"] = "BOT_CHAT_MODEL_CATEGORY_CLOSESOURCE";
    LLMModelCategoryEnum["BOT_CHAT_MODEL_CATEGORY_OPENSOURCE"] = "BOT_CHAT_MODEL_CATEGORY_OPENSOURCE";
    LLMModelCategoryEnum["BOT_CHAT_MODEL_CATEGORY_SELFDEVELOP"] = "BOT_CHAT_MODEL_CATEGORY_SELFDEVELOP";
})(LLMModelCategoryEnum || (LLMModelCategoryEnum = {}));
var LLMModelStatusEnum;
(function (LLMModelStatusEnum) {
    LLMModelStatusEnum["BOT_CHAT_MODEL_STATUS_UNSPECIFIED"] = "BOT_CHAT_MODEL_STATUS_UNSPECIFIED";
    LLMModelStatusEnum["BOT_CHAT_MODEL_STATUS_ACTIVE"] = "BOT_CHAT_MODEL_STATUS_ACTIVE";
    LLMModelStatusEnum["BOT_CHAT_MODEL_STATUS_INVISIBLE"] = "BOT_CHAT_MODEL_STATUS_INVISIBLE";
    LLMModelStatusEnum["BOT_CHAT_MODEL_STATUS_DISABLE"] = "BOT_CHAT_MODEL_STATUS_DISABLE";
})(LLMModelStatusEnum || (LLMModelStatusEnum = {}));

const getTypeFromExt = (ext) => {
    if (ext === 'jpg') {
        return 'image/jpeg';
    }
    return `image/${ext}`;
};
function UserCropperModal({ type, file, open, onClose }) {
    var _a, _b, _c;
    const isMobile = useIsMobile();
    const [loading, setLoading] = React.useState(false);
    const [imageSrc, setImageSrc] = React.useState('');
    const [ratio, setRatio] = React.useState(1);
    const [originRatio, setOriginRatio] = React.useState(1);
    const cropperRef = React.createRef();
    const cropper2Ref = React.createRef();
    const commonT = nextIntl.useTranslations('common');
    const [imgNaturalWidth, setImgNaturalWidth] = React.useState(0);
    const [imgNaturalHeight, setImgNaturalHeight] = React.useState(0);
    const bestCropperWH = React.useMemo(() => {
        if (imgNaturalHeight === 0 || imgNaturalWidth === 0)
            return null;
        let maxWidth;
        let maxHeight;
        if (isMobile) {
            maxWidth = 320;
            maxHeight = 540;
        }
        else {
            maxWidth = 720;
            maxHeight = 480;
        }
        const aspectRatio = imgNaturalWidth / imgNaturalHeight;
        let scaledWidth = imgNaturalWidth;
        let scaledHeight = imgNaturalHeight;
        if (scaledWidth > maxWidth || scaledHeight > maxHeight) {
            if (aspectRatio > maxWidth / maxHeight) {
                scaledWidth = maxWidth;
                scaledHeight = scaledWidth / aspectRatio;
            }
            else {
                scaledHeight = maxHeight;
                scaledWidth = scaledHeight * aspectRatio;
            }
        }
        return {
            width: scaledWidth,
            height: scaledHeight
        };
    }, [imgNaturalHeight, imgNaturalWidth, isMobile]);
    const maxRatio = React.useMemo(() => {
        return (originRatio || 1) * 3;
    }, [originRatio]);
    const step = React.useMemo(() => {
        return (originRatio || 1) / 10;
    }, [originRatio]);
    const ext = (_c = (_b = (_a = file.name) === null || _a === void 0 ? void 0 : _a.split('.')) === null || _b === void 0 ? void 0 : _b.pop()) !== null && _c !== void 0 ? _c : 'png';
    const { warning } = useNotification();
    React.useEffect(() => {
        const reader = new FileReader();
        reader.onload = () => {
            const dataUrl = reader.result;
            setImageSrc(dataUrl);
        };
        reader.readAsDataURL(file);
    }, [file]);
    const handleUpLoadImg = React.useCallback(async () => {
        var _a;
        setLoading(true);
        try {
            const dataUrl = (_a = cropper2Ref.current) === null || _a === void 0 ? void 0 : _a.cropper.getCroppedCanvas().toDataURL('image/jpeg', 0.6);
            fetch(dataUrl)
                .then(res => res.blob())
                .then(blob => {
                const _file = new File([blob], `${lodashEs.uniqueId()}-cropped-image.${ext}`, { type: getTypeFromExt(ext) });
                return uploadFileToS3(Scenario.SCENARIO_USER_BACKGROUND, ext, _file);
            })
                .then((res) => {
                onClose(true, res);
                return res;
            })
                .catch(() => {
                warning({
                    content: 'Upload Failed!'
                });
                onClose(false);
            })
                .finally(() => {
                setLoading(false);
            });
        }
        catch (e) {
            return null;
        }
    }, [cropper2Ref, ext, onClose, type, warning]);
    const handleReady = React.useCallback(() => {
        const cRef = cropperRef.current;
        if (cRef) {
            const { naturalHeight, naturalWidth } = cRef.cropper.getCanvasData();
            setImgNaturalWidth(naturalWidth);
            setImgNaturalHeight(naturalHeight);
        }
    }, [cropperRef]);
    const handleReady2 = React.useCallback(() => {
        const cRef = cropper2Ref.current;
        if (cRef) {
            const { height, naturalHeight } = cRef.cropper.getCanvasData();
            const originRatio = height / naturalHeight;
            setRatio(originRatio);
            setOriginRatio(originRatio);
        }
    }, [cropper2Ref]);
    const handleScaleReduce = () => {
        let _ratio = ratio - step;
        if (_ratio < originRatio) {
            _ratio = originRatio;
        }
        handleScale(_ratio);
    };
    const handleScalePlus = () => {
        let _ratio = ratio + step;
        if (_ratio > maxRatio) {
            _ratio = maxRatio;
        }
        handleScale(_ratio);
    };
    const handleScale = (value) => {
        setRatio(value);
        const cRef = cropper2Ref.current;
        if (cRef) {
            cRef.cropper.zoomTo(value);
        }
    };
    return (jsxRuntime.jsxs(react.Modal, { closeOnEsc: false, closeOnOverlayClick: false, isOpen: open, onClose: () => onClose(false), isCentered: true, children: [jsxRuntime.jsx(react.ModalOverlay, {}), jsxRuntime.jsxs(react.ModalContent, { w: "auto", maxW: "auto", maxH: "auto", className: "bg-surface-container-default", borderRadius: "24px", color: "#141718", p: 0, children: [jsxRuntime.jsxs(react.ModalHeader, { display: "flex", className: "relative", p: 4, children: [jsxRuntime.jsxs(react.Flex, { w: "full", justifyContent: "space-between", alignItems: "center", children: [jsxRuntime.jsx(react.Center, { w: "36px", h: "36px", cursor: "pointer", onClick: () => onClose(false), children: jsxRuntime.jsx(ForwardRef$R, { className: "w-[24px] h-[24px] stroke-icon" }) }), jsxRuntime.jsx(react.Text, { className: "flex-grow leading-loose text-default", fontSize: "18px", lineHeight: "28px", fontWeight: "600", children: commonT('cover_pic') })] }), jsxRuntime.jsx(react.Button, { ml: 4, variant: "ghost", p: "8px 16px", h: "36px", className: "bg-surface-primary-default", _hover: {
                                    background: 'var(--surface-primary-default)'
                                }, minW: "65px", rounded: "full", color: "#fff", onClick: handleUpLoadImg, isLoading: loading, children: commonT('save') })] }), jsxRuntime.jsxs(react.ModalBody, { p: 0, children: [jsxRuntime.jsx(react.Center, { bgColor: "#F5F7FA", children: jsxRuntime.jsxs(react.Box, { position: "relative", overflow: "hidden", w: "fit-content", h: "fit-content", children: [bestCropperWH && (jsxRuntime.jsx(Cropper__default.default, { className: "min-w-[200px] min-h-[200px]", style: bestCropperWH, ref: cropper2Ref, src: imageSrc, viewMode: 1, minCropBoxHeight: 10, minCropBoxWidth: 10, background: false, responsive: true, cropBoxResizable: false, cropBoxMovable: false, checkOrientation: true, guides: true, dragMode: "move", modal: false, autoCropArea: 1, zoomOnWheel: false, zoomOnTouch: false, ready: handleReady2, aspectRatio: type === BotPhotoTypeEnum.BACKGROUND ? 5 : 1 })), jsxRuntime.jsx(Cropper__default.default, { className: "hidden w-[100px] h-[100px]", ref: cropperRef, src: imageSrc, ready: handleReady })] }) }), jsxRuntime.jsxs(react.Flex, { p: 4, className: "space-x-3", children: [jsxRuntime.jsx(ForwardRef$x, { className: "w-5 h-5 cursor-pointer stroke-icon", onClick: handleScaleReduce }), jsxRuntime.jsxs(react.Slider, { "aria-label": "slider-ex-1", value: ratio, min: originRatio || 1, max: maxRatio, step: step, onChange: (value) => handleScale(value), children: [jsxRuntime.jsx(react.SliderTrack, { bg: "var(--border)", height: "6px", children: jsxRuntime.jsx(react.SliderFilledTrack, { bg: "var(--surface-primary-default)" }) }), jsxRuntime.jsx(react.SliderThumb, { bg: "var(--surface-primary-default)", width: "18px", height: "18px" })] }), jsxRuntime.jsx(ForwardRef$w, { className: "w-5 h-5 cursor-pointer  stroke-icon", onClick: handleScalePlus })] })] })] })] }));
}

const AcceptedImageSuffixs = ['png', 'jpeg', 'jpg'];
function UserBg({ bgPhoto, onActionSuccess, loading, className, showUpload = false }) {
    const inputRef = React.useRef(null);
    const [file, setFile] = React.useState();
    const [cropperModalVisible, setCropperModalVisible] = React.useState(false);
    const { warning } = useNotification();
    const commonT = nextIntl.useTranslations('common');
    const handleFileChange = (e) => {
        const file = e.target.files[0];
        if (file) {
            const fileSuffix = getFileExtension(file.name);
            if (!AcceptedImageSuffixs.some(s => s === fileSuffix)) {
                warning({ content: commonT('unsupported_img_file_type') });
                return;
            }
            if (file.size > 1048576 * 5) {
                warning({ content: commonT('image_up_to_5m') });
                return;
            }
            if (file.size > 1048576 * 2) {
                new Compressor__default.default(file, {
                    quality: 0.6,
                    success(result) {
                        setFile(result);
                        setCropperModalVisible(true);
                    },
                    error(err) {
                        setFile(file);
                        setCropperModalVisible(true);
                    }
                });
            }
            else {
                setFile(file);
                setCropperModalVisible(true);
            }
        }
        if (inputRef.current) {
            inputRef.current.value = '';
        }
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("div", { className: clsx__default.default('w-full relative', className || 'h-[120px] md:max-h-[190px] md:h-[12.2vw]'), children: [loading ? (jsxRuntime.jsx(Image__default.default, { alt: "user detail background image", src: BotDetailBg__default.default, fill: true, priority: true, className: "object-cover" })) : (jsxRuntime.jsx(Image__default.default, { alt: "user detail background image", src: bgPhoto || BotDetailBg__default.default, fill: true, priority: true, className: "object-cover" })), showUpload && (jsxRuntime.jsx(react.Center, { position: "absolute", w: "full", h: "full", children: jsxRuntime.jsxs("label", { children: [jsxRuntime.jsx(react.Box, { p: "8px 12px", bgColor: "white", boxShadow: "0px 1px 0px 0px rgba(0, 0, 0, 0.05)", rounded: "full", cursor: "pointer", children: jsxRuntime.jsx(CameraIcon, { color: "var(--surface-primary-default)", fontSize: "20px" }) }), jsxRuntime.jsx("span", { className: "hidden", children: "\u9009\u62E9\u56FE\u7247\u4E0A\u4F20" }), jsxRuntime.jsx("input", { ref: inputRef, type: "file", className: "hidden", accept: "image/png, image/jpeg", onChange: handleFileChange, disabled: loading })] }) }))] }), cropperModalVisible && (jsxRuntime.jsx(UserCropperModal, { type: BotPhotoTypeEnum.BACKGROUND, file: file, open: cropperModalVisible, onClose: (needRefresh = false, data) => {
                    console.log('onClose', data);
                    setCropperModalVisible(false);
                    setFile(undefined);
                    needRefresh && onActionSuccess && data && onActionSuccess(data === null || data === void 0 ? void 0 : data.objectKey);
                } }))] }));
}

function UserLevel({ user }) {
    const t = nextIntl.useTranslations('profile');
    return (jsxRuntime.jsx("span", { className: clsx__default.default('flex-shrink-0 h-6 leading-6 px-[10px] bg-[#EBE1FF] rounded-lg text-xs text-[#391C79] font-bold', user && (user.isGenesisPasscard || (user === null || user === void 0 ? void 0 : user.isPasscard))
            ? 'bg-[#FFF2E2] text-[#FDA500] dark:bg-[#4F3E2C] dark:text-[#FFC453]'
            : (user === null || user === void 0 ? void 0 : user.level) === 2
                ? 'bg-[#E0E5FF] text-[#3E5CFA] dark:bg-[#2C334F] dark:text-[#5974FF]'
                : 'bg-[#EDEEEF] text-[#414345] dark:bg-[#42434A] dark:text-[#B8BCCF]'), children: user && (user.isGenesisPasscard || (user === null || user === void 0 ? void 0 : user.isPasscard))
            ? t('genesis')
            : (user === null || user === void 0 ? void 0 : user.level) === 2
                ? t('standard')
                : t('basic') }));
}

const useGetInvitation = () => {
    const setInviteLink = useUserStore(state => state.setInviteLink);
    const setUserInviteCode = useUserStore(state => state.setUserInviteCode);
    const setInvitationCount = useUserStore(state => state.setInvitationCount);
    const setValidInvitationCount = useUserStore(state => state.setValidInvitationCount);
    const setTgValidInvitationCount = useUserStore(state => state.setTgValidInvitationCount);
    const isLogin = useUserStore(state => state.isLogin);
    const destroy$ = React.useMemo(() => new rxjs.Subject(), []);
    const [invitationLoading, setInvitationLoading] = React.useState(false);
    const fetchGetInvitation = async () => {
        setInvitationLoading(true);
        const res = await getInvitation();
        if (res.success) {
            const { code, invitationCount, validInvitationCount, tgValidInvitationCount } = res.data;
            setInvitationCount(invitationCount);
            setValidInvitationCount(validInvitationCount);
            setTgValidInvitationCount(tgValidInvitationCount);
            setUserInviteCode(code);
            setInviteLink(`${window.location.origin}/invite/${code}`);
        }
        setInvitationLoading(false);
    };
    React.useEffect(() => {
        if (!isLogin)
            return;
        fetchGetInvitation();
    }, [destroy$, isLogin, setValidInvitationCount, setUserInviteCode, setInviteLink]);
    return {
        invitationLoading
    };
};

function UserShareBtn(props) {
    const [loading, setLoading] = React.useState(false);
    const [shareLink, setShareLink] = React.useState('');
    const { onCopy } = useCopyClipboard(shareLink);
    const sensors = useSensors();
    useGetInvitation();
    const inviteCode = useUserStore(state => state.inviteCode);
    const { userName, nameTag, userId } = props;
    const generateShareLink = () => {
        if (!userName)
            return;
        setLoading(true);
        let userShareUrl = '';
        if (nameTag) {
            userShareUrl = `${isClient() ? window.location.origin : ''}/explore/profile/${encodeURIComponent(userName)}?nametag=${encodeURIComponent(nameTag)}${inviteCode && `&invite=${inviteCode}`}`;
            setShareLink(userShareUrl);
            onCopy(userShareUrl);
        }
        if (sensors && sensors.track) {
            sensors === null || sensors === void 0 ? void 0 : sensors.track('ShareItem', {
                item_type: 'creator',
                item_id: userId,
                item_name: userName
            });
        }
        setLoading(false);
    };
    return (jsxRuntime.jsx("button", { className: "bg-white rounded-full border border-[#E4E9F0] w-9 h-9 cursor-pointer shadow-button-basic flex justify-center items-center disabled:opacity-70 disabled:cursor-not-allowed", onClick: generateShareLink, disabled: loading, children: !loading ? (jsxRuntime.jsx(ForwardRef$O, { className: "w-5 h-[22px] text-[#202223]" })) : (jsxRuntime.jsx(Spinner, { size: "sm", className: "text-brand" })) }));
}

function trimNewlines(str) {
    return str.replace(/^\n+|\n+$/g, '');
}
function Description({ showMore = true, desc = '' }) {
    const trimmedDesc = trimNewlines(desc);
    const t = nextIntl.useTranslations('common');
    const [show, setShow] = reactUse.useToggle(false);
    const textRef = React.useRef(null);
    const [hasMore, setHasMore] = React.useState(false);
    const isDesktop = !useGlobalStore(state => state.isMobile);
    React.useEffect(() => {
        const handleCalcActualSize = () => {
            setShow(false);
            if (textRef.current) {
                const lineHeight = parseInt(window.getComputedStyle(textRef.current).lineHeight);
                const maxHeight = isDesktop ? lineHeight * 2 : lineHeight * 3;
                setHasMore(textRef.current.scrollHeight > maxHeight);
            }
        };
        handleCalcActualSize();
        window.addEventListener('resize', lodashEs.throttle(handleCalcActualSize, 500));
        return () => {
            window.removeEventListener('resize', handleCalcActualSize);
        };
    }, [isDesktop, trimmedDesc]);
    const handleToggle = () => setShow(!show);
    if (!trimmedDesc)
        return null;
    return (jsxRuntime.jsx("div", { className: "text-sm flex flex-col w-full whitespace-pre-line", children: jsxRuntime.jsxs("div", { className: "relative w-full flex flex-col gap-1", children: [jsxRuntime.jsx("p", { ref: textRef, className: clsx__default.default('text-subtler leading-[1.5]', hasMore && !show && 'line-clamp-3 md:line-clamp-2'), style: {
                        maxHeight: show ? 'none' : isDesktop ? '3rem' : '4.5rem'
                    }, children: trimmedDesc }), hasMore && showMore && (jsxRuntime.jsx(Text, { className: "px-0.5 text-brand cursor-pointer", weight: "medium", size: "sm", onClick: handleToggle, children: t(show ? 'show_less' : 'show_more') }))] }) }));
}

function WidgetList({ showSimplifyTags = false, widgets, pinnedCallback, onClose, setShowUserDetail }) {
    const workshopT = nextIntl.useTranslations('workshop');
    const widgetList = (widgets === null || widgets === void 0 ? void 0 : widgets.map(item => {
        return {
            title: item.name,
            description: item.description,
            logoUrl: item.logoUrl,
            id: item.id,
            clickUrl: `/robot-workshop/widget/${item.id}`,
            clickMobileUrl: `/robot-workshop/widget/${item.id}`,
            showVoice: item.chatCallerType === WidgetChatCallerTypeEnum.WIDGET_CHAT_CALLER_TYPE_VOICE,
            type: 'WIDGET',
            tags: item.tags
        };
    })) || [];
    return widgetList.length ? (jsxRuntime.jsx("div", { className: cn('grid grid-cols-1 gap-x-4 gap-y-2', widgetList.length > 0 ? 'md:grid-cols-2' : ''), children: widgetList.map((widget, index) => {
            return jsxRuntime.jsx(NormalCard, { size: "sm", showTags: true, item: widget, isLine: true }, widget.id);
        }) })) : (jsxRuntime.jsx("div", { className: "text-default h-[120px] flex justify-center items-center", children: workshopT('no_widgets_available') }));
}

function UserDetail({ showInsideScroller = false, detailData, showTopActions = false, defaultTab = 'bots', onClose, followCallback }) {
    const searchParams = navigation.useSearchParams();
    const from = searchParams.get('from');
    const [fetchLoading, setFetchLoading] = React.useState(false);
    const [activeContent, setActiveContent] = React.useState(from === 'gallery' ? 'gallery' : defaultTab);
    const [showUserDetail, setShowUserDetail] = React.useState(null);
    const [widgets, setWidgets] = React.useState();
    const [bots, setBots] = React.useState();
    const t = nextIntl.useTranslations();
    const botT = nextIntl.useTranslations('bot');
    const workshopT = nextIntl.useTranslations('workshop');
    const { isMobile } = usePathLocale();
    const setGalleryUserList = useGalleryStore(state => state.setGalleryUserList);
    const queryData = React.useCallback(async () => {
        var _a;
        try {
            if (detailData === null || detailData === void 0 ? void 0 : detailData.id) {
                setFetchLoading(true);
                const [botList, widgetList] = await Promise.all([
                    getBotsByUser(detailData === null || detailData === void 0 ? void 0 : detailData.id),
                    getWidgetsByUser(detailData === null || detailData === void 0 ? void 0 : detailData.id)
                ]);
                setBots(botList.data);
                setWidgets((_a = widgetList.data) === null || _a === void 0 ? void 0 : _a.widgets);
                setFetchLoading(false);
            }
        }
        catch (error) {
            console.error(error);
            setFetchLoading(false);
        }
    }, [detailData === null || detailData === void 0 ? void 0 : detailData.id]);
    React.useEffect(() => {
        if (fetchLoading)
            return;
        queryData();
        return () => {
            setGalleryUserList([]);
        };
    }, [detailData === null || detailData === void 0 ? void 0 : detailData.id]);
    const containerRef = React.useRef(null);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("div", { className: `UserDetail ${showInsideScroller ? 'overflow-hidden h-full md:overflow-auto' : 'h-full overflow-hidden'} flex w-full flex-col flex-nowrap bg-surface-container-default text-default relative md:rounded-4xl`, children: [showTopActions && (jsxRuntime.jsx(jsxRuntime.Fragment, { children: isMobile ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { className: clsx__default.default('absolute top-[10px] md:top-5 flex z-10 space-x-3 left-5'), children: jsxRuntime.jsx("div", { className: "bg-white rounded-full border border-[#E4E9F0] w-9 h-9 cursor-pointer shadow-button-basic flex justify-center items-center", onClick: onClose, children: jsxRuntime.jsx(ForwardRef$8, { className: "w-[22px] h-[22px] text-[#202223]" }) }) }), jsxRuntime.jsx("div", { className: clsx__default.default('absolute top-[10px] md:top-5 flex z-10 space-x-3 right-5'), children: jsxRuntime.jsx(UserShareBtn, { userName: detailData === null || detailData === void 0 ? void 0 : detailData.name, nameTag: detailData === null || detailData === void 0 ? void 0 : detailData.nameTag, userId: detailData === null || detailData === void 0 ? void 0 : detailData.id }) })] })) : (jsxRuntime.jsxs("div", { className: clsx__default.default('absolute top-[10px] md:top-5 flex z-10 space-x-3', isMobile ? 'left-4' : 'right-5'), children: [jsxRuntime.jsx(UserShareBtn, { userName: detailData === null || detailData === void 0 ? void 0 : detailData.name, nameTag: detailData === null || detailData === void 0 ? void 0 : detailData.nameTag, userId: detailData === null || detailData === void 0 ? void 0 : detailData.id }), jsxRuntime.jsx("div", { className: "bg-white rounded-full border border-[#E4E9F0] w-9 h-9 cursor-pointer shadow-button-basic flex justify-center items-center", onClick: onClose, children: jsxRuntime.jsx(ForwardRef$j, { className: "w-[22px] h-[22px] text-[#202223]" }) })] })) })), jsxRuntime.jsx("div", { ref: containerRef, className: clsx__default.default('flex flex-col flex-grow items-center relative overflow-auto'), children: jsxRuntime.jsxs("div", { className: "flex flex-col w-full h-full pb-[8px] md:h-full md:pb-[12px]", children: [jsxRuntime.jsxs("div", { className: "w-full", children: [jsxRuntime.jsx(UserBg, { bgPhoto: getAssetsUrl(detailData === null || detailData === void 0 ? void 0 : detailData.backgroundUrl), showUpload: false }), jsxRuntime.jsxs("div", { className: "relative flex space-x-3 md:space-x-5", children: [jsxRuntime.jsx(BotLogo, { logoUrl: getAssetsUrl(detailData === null || detailData === void 0 ? void 0 : detailData.avatar) }), !isMobile && (jsxRuntime.jsxs("div", { className: "grow flex items-end justify-between pr-6 pb-1", children: [jsxRuntime.jsxs("div", { className: "flex flex-col", children: [jsxRuntime.jsxs("div", { className: "flex items-center space-x-1.5 pr-1.5 pb-1", children: [jsxRuntime.jsx("span", { className: clsx__default.default('text-2xl md:text-[28px] md:leading-[36px] font-semibold text-default line-clamp-1 break-all'), children: detailData === null || detailData === void 0 ? void 0 : detailData.name }), jsxRuntime.jsx(UserLevel, { user: detailData })] }), jsxRuntime.jsx(FollowInfo, { user: detailData })] }), ((detailData === null || detailData === void 0 ? void 0 : detailData.followStatus) === exports.FollowStatus.FOLLOWED ||
                                                            (detailData === null || detailData === void 0 ? void 0 : detailData.followStatus) === exports.FollowStatus.NOT_FOLLOWED) && (jsxRuntime.jsx(UserFollowBtn, { detailData: detailData, followCallback: followCallback }))] })), isMobile &&
                                                    ((detailData === null || detailData === void 0 ? void 0 : detailData.followStatus) === exports.FollowStatus.FOLLOWED ||
                                                        (detailData === null || detailData === void 0 ? void 0 : detailData.followStatus) === exports.FollowStatus.NOT_FOLLOWED) && (jsxRuntime.jsx("div", { className: "absolute right-0 top-0 px-4 py-3", children: jsxRuntime.jsx(UserFollowBtn, { detailData: detailData, size: "md", followCallback: followCallback, className: "min-w-[76px]" }) }))] })] }), isMobile && (jsxRuntime.jsxs("div", { className: "flex flex-col px-4 mt-2", children: [jsxRuntime.jsxs("div", { className: "flex items-center space-x-1.5 pr-1.5 pb-1", children: [jsxRuntime.jsx("span", { className: clsx__default.default('text-2xl md:text-[28px] md:leading-[36px] font-semibold text-default line-clamp-1 break-all'), children: detailData === null || detailData === void 0 ? void 0 : detailData.name }), jsxRuntime.jsx(UserLevel, { user: detailData })] }), jsxRuntime.jsx(FollowInfo, { user: detailData })] })), (detailData === null || detailData === void 0 ? void 0 : detailData.description) && (jsxRuntime.jsx("div", { className: "px-2 ml-6", children: jsxRuntime.jsx(Description, { desc: detailData === null || detailData === void 0 ? void 0 : detailData.description }) })), jsxRuntime.jsxs("div", { className: clsx__default.default('flex-1 pt-[6px] md:pb-5 flex flex-col space-y-4 mt-2 md:mt-5 ', activeContent === 'gallery' ? '' : 'md:px-6'), children: [jsxRuntime.jsx("div", { className: clsx__default.default('sticky bg-surface-container-default top-0 z-[2] md:relative md:bg-inherit md:z-auto mx-4 md:mx-2', activeContent === 'gallery' ? 'md:px-6' : ''), children: jsxRuntime.jsx("div", { className: "flex justify-between items-center border-b border-default", children: jsxRuntime.jsx("div", { className: "flex space-x-2 items-center", children: jsxRuntime.jsxs("div", { className: "flex space-x-6 items-center", children: [jsxRuntime.jsx("div", { className: clsx__default.default('cursor-pointer relative z-[1] font-[500] text-sm md:text-base text-center', activeContent === 'bots'
                                                                    ? 'pb-[5px] border-b-[2px] border-brand text-brand'
                                                                    : 'pb-[7px] text-subtle'), onClick: () => setActiveContent('bots'), children: botT('robot') }), jsxRuntime.jsx("div", { className: clsx__default.default('cursor-pointer relative z-[1] font-[500] text-sm md:text-base text-center', activeContent === 'widgets'
                                                                    ? 'pb-[5px] border-b-[2px] border-brand text-brand'
                                                                    : 'pb-[7px] text-subtle'), onClick: () => setActiveContent('widgets'), children: workshopT('widget') }), jsxRuntime.jsx("div", { className: clsx__default.default('cursor-pointer relative z-[1] font-[500] text-sm md:text-base text-center', activeContent === 'gallery'
                                                                    ? 'pb-[5px] border-b-[2px] border-brand text-brand'
                                                                    : 'pb-[7px] text-subtle'), onClick: () => setActiveContent('gallery'), children: t('chat.gallery') })] }) }) }) }), activeContent === 'bots' && (jsxRuntime.jsx("div", { className: "mx-4 md:mx-0", children: jsxRuntime.jsx(UserBotList, { bots: bots || [], onClose: onClose, loading: fetchLoading }) })), activeContent === 'widgets' && (jsxRuntime.jsx("div", { className: "mx-4 md:mx-0", children: jsxRuntime.jsx(WidgetList, { widgets: widgets !== null && widgets !== void 0 ? widgets : [], pinnedCallback: () => {
                                                    queryData();
                                                }, onClose: onClose, setShowUserDetail: setShowUserDetail }) })), activeContent === 'gallery' && jsxRuntime.jsx(GalleryList, { userId: detailData === null || detailData === void 0 ? void 0 : detailData.id, containerRef: containerRef })] })] }) })] }), !isMobile && !!(showUserDetail === null || showUserDetail === void 0 ? void 0 : showUserDetail.name) && (jsxRuntime.jsx(UserDetailModal, { isOpen: !!(showUserDetail === null || showUserDetail === void 0 ? void 0 : showUserDetail.name), onClose: () => {
                    onClose && onClose();
                    setShowUserDetail(null);
                }, userName: showUserDetail.name, nameTag: showUserDetail.nameTag }))] }));
}

function UserDetailModal({ isOpen, onClose, detailData, userName, nameTag, defaultTab }) {
    const [detail, setDetail] = React.useState(detailData);
    const [isNotFound, setIsNotFound] = React.useState(false);
    const { isMobile } = usePathLocale();
    const t = nextIntl.useTranslations('profile');
    const commonT = nextIntl.useTranslations('common');
    const isOpenLoginModal = useGlobalStore(state => state.isOpenLoginModal);
    const getUserHandle = async () => {
        const res = await getUserProfile({ name: userName, nameTag });
        if (res.success) {
            setDetail(res.data);
            setIsNotFound(false);
        }
        else {
            setIsNotFound(true);
        }
    };
    React.useEffect(() => {
        if (!(detailData === null || detailData === void 0 ? void 0 : detailData.id) && !!userName && !!nameTag) {
            getUserHandle();
        }
    }, [userName, nameTag]);
    const followCallback = () => {
        getUserHandle();
    };
    if (isNotFound) {
        return (jsxRuntime.jsx(Modal, { open: isOpen, onClose: onClose, contentClassName: "w-[90%] md:w-[380px] p-4 z-[120]", overlayClassName: "z-[120]", children: jsxRuntime.jsxs("div", { className: "flex flex-col space-y-2", children: [jsxRuntime.jsx("div", { className: "w-12 h-12 rounded-full flex items-center justify-center bg-[#CCD4FF] dark:bg-[#2C334F] border-[6px] border-[#F2F4FE] dark:border-[#292C38] flex-shrink-0 ", children: jsxRuntime.jsx(ForwardRef$U, { className: "w-6 h-6 stroke-surface-primary-default" }) }), jsxRuntime.jsxs("div", { className: "flex flex-col space-y-2 text-default", children: [jsxRuntime.jsx("h2", { className: "text-xl text-default", children: t('user_not_found_title') }), jsxRuntime.jsx(react.Text, { fontSize: "14px", lineHeight: "20px", className: "text-subtle", children: t('user_not_found_content') })] }), jsxRuntime.jsx(react.Button, { variant: "unstyled", boxShadow: "0px -1px 0px 0px rgba(0, 0, 0, 0.20) inset, 0px 1px 0px 0px rgba(0, 0, 0, 0.08)", color: "white", rounded: "full", display: "flex", justifyContent: "center", alignItems: "center", className: "mt-4 w-full bg-surface-primary-default h-[44px] outline-none px-6 py-2.5 font-bold", _loading: {
                            _hover: {
                                bgColor: '#3E5CFA'
                            }
                        }, onClick: onClose, children: commonT('confirm') })] }) }));
    }
    if (detail) {
        return (jsxRuntime.jsx(Modal, { open: isOpenLoginModal ? false : isOpen, onClose: onClose, contentClassName: cn('overflow-hidden shadow bg-transparent', isMobile ? 'w-full h-full' : 'w-[80vw] max-w-[880px] min-h-[418px] h-[90vh] max-h-[800px] rounded-4xl'), children: jsxRuntime.jsx(UserDetail, { detailData: detail, showInsideScroller: true, showTopActions: true, onClose: onClose, followCallback: followCallback, defaultTab: defaultTab }) }));
    }
    return null;
}

function GalleryPublishTipModal$1({ publishing, open, publishState, onClose, onConfirm }) {
    const t = nextIntl.useTranslations();
    const router = useRoute();
    const user = useUserStore(state => state.user);
    const isMobile = useGlobalStore(state => state.isMobile);
    const [showUserDetail, setShowUserDetail] = React.useState(false);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Modal, { overlayClose: !publishing, hideClose: publishing, open: open, onClose: onClose, onConfirm: () => {
                    if (publishState === 'success' && user) {
                        if (isMobile) {
                            router.openUrl(`/m/explore/profile/${encodeURIComponent(user.name)}/${encodeURIComponent(user.nameTag)}?from=gallery`);
                        }
                        else {
                            setShowUserDetail(true);
                            onClose();
                        }
                    }
                    else {
                        onConfirm();
                    }
                }, state: publishState || 'info', confirmText: publishState === 'success' ? t('chat.go_to_profile') : t('workshop.publish'), isNotification: true, title: publishState === 'success' ? t('chat.publish_success') : t('chat.user_tips'), description: publishState === 'success' ? t('chat.publish_success_content') : t('chat.publish_tip_content'), confirmLoading: publishing, overlayClassName: "z-[110]", contentClassName: "z-[110]" }), showUserDetail && (jsxRuntime.jsx(UserDetailModal, { isOpen: showUserDetail, onClose: () => setShowUserDetail(false), userName: user === null || user === void 0 ? void 0 : user.name, nameTag: user === null || user === void 0 ? void 0 : user.nameTag, defaultTab: "gallery" }))] }));
}

const MobilePreview$3 = dynamic__default.default(() => Promise.resolve().then(function () { return index$3; }), {
    ssr: false
});
const PcPreview$1 = dynamic__default.default(() => Promise.resolve().then(function () { return index$2; }), {
    ssr: false
});
function ImgVideoPreview$2({ imgVideoList, activeIndex, open, onClose }) {
    const { message } = useDisplayContext();
    const { publish } = React.useContext(MessageContext);
    const { publishSingleImgToGallery, publishing, everPublished } = publish || {};
    const [publishState, setPublishState] = React.useState('info');
    const [popupConfirmItem, setPopupConfirmItem] = React.useState(undefined);
    const { isMobile } = useDevice();
    const publishSuccessCb = React.useCallback(() => {
        if (publishState === 'info' && !everPublished) {
            setPublishState('success');
        }
        else {
            setPublishState('info');
            setPopupConfirmItem(undefined);
            onClose();
        }
    }, [publishState, everPublished, setPublishState, setPopupConfirmItem, onClose]);
    const confirmHandler = React.useCallback(() => {
        if (publishState === 'success') {
            setPopupConfirmItem(undefined);
            onClose();
        }
        else {
            popupConfirmItem && (publishSingleImgToGallery === null || publishSingleImgToGallery === void 0 ? void 0 : publishSingleImgToGallery(popupConfirmItem, publishSuccessCb));
        }
    }, [publishState, onClose, popupConfirmItem, publishSingleImgToGallery, publishSuccessCb]);
    const publishGalleryHandle = React.useCallback((index) => {
        var _a, _b, _c;
        const imgItem = imgVideoList[index];
        const publishObj = {
            imageLink: imgItem.url,
            messageId: (_a = message === null || message === void 0 ? void 0 : message.id) !== null && _a !== void 0 ? _a : '',
            naturalHeight: ((_b = imgItem.mediaFileMetadata) === null || _b === void 0 ? void 0 : _b.height) || 0,
            naturalWidth: ((_c = imgItem.mediaFileMetadata) === null || _c === void 0 ? void 0 : _c.width) || 0
        };
        if (everPublished) {
            publishSingleImgToGallery === null || publishSingleImgToGallery === void 0 ? void 0 : publishSingleImgToGallery(publishObj, publishSuccessCb);
        }
        else {
            setPopupConfirmItem === null || setPopupConfirmItem === void 0 ? void 0 : setPopupConfirmItem(publishObj);
        }
    }, [imgVideoList, message === null || message === void 0 ? void 0 : message.id, everPublished, publishSingleImgToGallery, publishSuccessCb, setPopupConfirmItem]);
    return (imgVideoList.length > 0 && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Modal, { open: open, onClose: onClose, contentClassName: "w-full h-full max-h-none p-0 rounded-none bg-beta-black-10", hideClose: true, children: jsxRuntime.jsx("div", { className: "overflow-hidden p-0", children: isMobile ? (jsxRuntime.jsx(MobilePreview$3, { imgVideoList: imgVideoList, activeIndex: activeIndex, onClose: onClose, publishGalleryHandle: publishGalleryHandle, publishing: publishing })) : (jsxRuntime.jsx(PcPreview$1, { imgVideoList: imgVideoList, activeIndex: activeIndex, onClose: onClose, publishGalleryHandle: publishGalleryHandle, publishing: publishing })) }) }), jsxRuntime.jsx(GalleryPublishTipModal$1, { open: !!popupConfirmItem, onClose: () => {
                    setPopupConfirmItem(undefined);
                    publishState === 'success' && onClose();
                }, onConfirm: confirmHandler, publishState: publishState, publishing: publishing !== null && publishing !== void 0 ? publishing : false })] })));
}

function ImgVideoList({ imgVideoList, driving }) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const isMobile = !useGlobalStore(state => state.isMobile);
    const fileLen = imgVideoList.length;
    const [viewModalVisible, setViewModalVisible] = React.useState(false);
    const [index, setIndex] = React.useState(0);
    const onOpenViewModal = (index) => {
        if (!driving) {
            setIndex(index !== null && index !== void 0 ? index : 0);
            setViewModalVisible(true);
        }
    };
    const singleFileDimension = React.useMemo(() => {
        var _a;
        const maxSize = !isMobile ? 301 : 536;
        const singleFileItem = imgVideoList[0];
        if (((_a = singleFileItem.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.width) && singleFileItem.mediaFileMetadata.height) {
            const w = singleFileItem.mediaFileMetadata.width;
            const h = singleFileItem.mediaFileMetadata.height;
            if (w > maxSize && h > maxSize) {
                if (w > h) {
                    return { width: maxSize, height: h * (maxSize / w) };
                }
                return { height: maxSize, width: w * (maxSize / h) };
            }
            if (w > maxSize) {
                return { width: maxSize, height: h * (maxSize / w) };
            }
            if (h > maxSize) {
                return { height: maxSize, width: w * (maxSize / h) };
            }
        }
        return { width: 'auto', height: 'auto' };
    }, [imgVideoList, isMobile]);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { className: clsx__default.default('rounded-xl overflow-hidden max-w-full w-[1000px] min-w-24', fileLen === 1 && 'max-w-fit max-h-fit'), style: fileLen === 1
                    ? {
                        width: singleFileDimension.width,
                        height: singleFileDimension.height
                    }
                    : {}, children: fileLen === 1 ? (jsxRuntime.jsx("div", { className: "rounded-xl overflow-hidden w-full h-full", children: jsxRuntime.jsx(MemorizedDisplayItem, { type: imgVideoList[0].type, url: imgVideoList[0].url, clickEvent: () => onOpenViewModal(), customClass: "w-auto h-auto", imageModel: (_b = (_a = imgVideoList[0]) === null || _a === void 0 ? void 0 : _a.mediaFileMetadata) === null || _b === void 0 ? void 0 : _b.generateModel, index: 0 }) })) : fileLen === 2 || fileLen === 4 ? (jsxRuntime.jsx("div", { className: "grid grid-cols-2 gap-1 w-full", children: imgVideoList.map((file, index) => {
                        var _a;
                        return (jsxRuntime.jsx(MemorizedDisplayItem, { type: file.type, url: file.url, clickEvent: () => onOpenViewModal(index), customClass: "aspect-square w-full", imageModel: (_a = file === null || file === void 0 ? void 0 : file.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.generateModel, index: index }, file.url + index));
                    }) })) : fileLen === 3 ? (jsxRuntime.jsxs("div", { className: "grid grid-cols-2 gap-1 w-full", children: [jsxRuntime.jsx(MemorizedDisplayItem, { type: imgVideoList[0].type, url: imgVideoList[0].url, clickEvent: () => onOpenViewModal(), customClass: "aspect-[5/4] md:aspect-[2] col-span-2 w-full", imageModel: (_d = (_c = imgVideoList[0]) === null || _c === void 0 ? void 0 : _c.mediaFileMetadata) === null || _d === void 0 ? void 0 : _d.generateModel, index: 0 }), imgVideoList.slice(1).map((file, index) => {
                            var _a;
                            return (jsxRuntime.jsx(MemorizedDisplayItem, { type: file.type, url: file.url, clickEvent: () => onOpenViewModal(1 + index), customClass: "aspect-square w-full", imageModel: (_a = file === null || file === void 0 ? void 0 : file.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.generateModel, index: index }, file.url + index));
                        })] })) : fileLen === 5 || fileLen === 8 ? (jsxRuntime.jsxs("div", { className: "grid grid-cols-6 gap-1 w-full", children: [jsxRuntime.jsx(MemorizedDisplayItem, { type: imgVideoList[0].type, url: imgVideoList[0].url, clickEvent: () => onOpenViewModal(), customClass: "aspect-square col-span-3 w-full", imageModel: (_f = (_e = imgVideoList[0]) === null || _e === void 0 ? void 0 : _e.mediaFileMetadata) === null || _f === void 0 ? void 0 : _f.generateModel, index: 0 }), jsxRuntime.jsx(MemorizedDisplayItem, { type: imgVideoList[1].type, url: imgVideoList[1].url, clickEvent: () => onOpenViewModal(1), customClass: "aspect-square col-span-3 w-full", imageModel: (_h = (_g = imgVideoList[1]) === null || _g === void 0 ? void 0 : _g.mediaFileMetadata) === null || _h === void 0 ? void 0 : _h.generateModel, index: 1 }), imgVideoList.slice(2).map((file, index) => {
                            var _a;
                            return (jsxRuntime.jsx(MemorizedDisplayItem, { type: file.type, url: file.url, clickEvent: () => onOpenViewModal(2 + index), customClass: "col-span-2 aspect-square w-full", imageModel: (_a = file === null || file === void 0 ? void 0 : file.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.generateModel, index: index }, file.url + index));
                        })] })) : fileLen === 6 || fileLen === 9 ? (jsxRuntime.jsx("div", { className: "grid grid-cols-3 gap-1 w-full", children: imgVideoList.map((file, index) => {
                        var _a;
                        return (jsxRuntime.jsx(MemorizedDisplayItem, { type: file.type, url: file.url, clickEvent: () => onOpenViewModal(index), customClass: "aspect-square w-full", imageModel: (_a = file === null || file === void 0 ? void 0 : file.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.generateModel, index: index }, file.url + index));
                    }) })) : (jsxRuntime.jsxs("div", { className: "flex flex-col space-y-1 w-full", children: [jsxRuntime.jsx(MemorizedDisplayItem, { type: imgVideoList[0].type, url: imgVideoList[0].url, clickEvent: () => onOpenViewModal(), customClass: clsx__default.default('w-full', fileLen === 7 ? 'aspect-[2]' : 'aspect-[5/4] md:aspect-[2]'), imageModel: (_k = (_j = imgVideoList[0]) === null || _j === void 0 ? void 0 : _j.mediaFileMetadata) === null || _k === void 0 ? void 0 : _k.generateModel, index: 0 }), jsxRuntime.jsx("div", { className: "grid grid-cols-3 gap-1 w-full", children: imgVideoList.slice(1).map((file, index) => {
                                var _a;
                                return (jsxRuntime.jsx(MemorizedDisplayItem, { type: file.type, url: file.url, clickEvent: () => onOpenViewModal(1 + index), customClass: "aspect-square w-full", imageModel: (_a = file === null || file === void 0 ? void 0 : file.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.generateModel, index: index }, file.url + index));
                            }) })] })) }), jsxRuntime.jsx(ImgVideoPreview$2, { open: viewModalVisible, onClose: () => {
                    setIndex(0);
                    setViewModalVisible(false);
                }, imgVideoList: imgVideoList, activeIndex: index })] }));
}
function DisplayItem({ type, url, imageModel, clickEvent, customClass, index }) {
    return type === EmbedObjType.IMAGE ? (jsxRuntime.jsx(MemorizedImageOverview, { url: url, imageModel: imageModel, onViewImage: clickEvent, customClass: customClass, index: index })) : (jsxRuntime.jsx(MemorizedVideoOverview$1, { url: url, onViewVideo: clickEvent, customClass: customClass }));
}
const MemorizedDisplayItem = React.memo(DisplayItem);
const MediaFileList = React.memo(ImgVideoList);

function FileDisplay$1({ embedObjs, mdImages = [], driving }) {
    const validEmbedObjs = React.useMemo(() => {
        return [...mdImages, ...embedObjs].filter(embed => embed.type !== EmbedObjType.UNKNOWN &&
            embed.type !== EmbedObjType.AUDIO_CONTENT &&
            embed.type !== EmbedObjType.TEXT_CONTENT);
    }, [embedObjs, mdImages]);
    const imgVideoList = React.useMemo(() => {
        return validEmbedObjs.filter(embed => embed.type === EmbedObjType.IMAGE || embed.type === EmbedObjType.VIDEO);
    }, [validEmbedObjs]);
    const otherFileList = React.useMemo(() => {
        return validEmbedObjs.filter(embed => embed.type === EmbedObjType.AUDIO || embed.type === EmbedObjType.DOC);
    }, [validEmbedObjs]);
    if (!validEmbedObjs.length)
        return null;
    return (jsxRuntime.jsxs("div", { className: "flex flex-col gap-2 w-full overflow-hidden", children: [!!imgVideoList.length && jsxRuntime.jsx(MediaFileList, { driving: driving, imgVideoList: imgVideoList }), !!otherFileList.length &&
                otherFileList.map(file => file.type === EmbedObjType.DOC || file.type === EmbedObjType.TEXT_CONTENT ? (jsxRuntime.jsx(Doc, { doc: file }, file.url)) : (jsxRuntime.jsx(Audio$1, { title: file.title, url: file.url }, file.url)))] }));
}

function Reference({ reference }) {
    return (jsxRuntime.jsx(Link$1, { href: reference.link, target: "_blank", children: jsxRuntime.jsxs("div", { className: "p-1 flex items-center space-x-1.5 rounded-md bg-surface-accent-gray-subtler hover:bg-surface-accent-gray-subtle", children: [jsxRuntime.jsx("img", { src: `https://s2.googleusercontent.com/s2/favicons?domain=${reference.displayLint}&sz=48`, alt: reference.displayLint, className: "w-6 h-6 rounded-md" }), jsxRuntime.jsx("div", { className: "grow truncate text-subtle text-sm", children: reference.title })] }) }));
}
var Reference$1 = React.memo(Reference);

function References({ references, className }) {
    const t = nextIntl.useTranslations('chat');
    if (!(references === null || references === void 0 ? void 0 : references.length)) {
        return null;
    }
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Separator, { className: "border-dashed" }), jsxRuntime.jsxs("div", { className: clsx__default.default('py-3 flex flex-col gap-1.5', className), children: [jsxRuntime.jsx("div", { className: "text-xs text-subtle font-medium", children: t('sources') }), jsxRuntime.jsx("div", { className: "flex flex-col gap-1.5", children: references.map(refer => (jsxRuntime.jsx(Reference$1, { reference: refer }, refer.link))) })] })] }));
}

({
    isAutopushOn: true,
    isAudioOn: false,
    isAudioPlayOn: false,
    isTranscriptionOn: true,
    isTranslationOn: true,
    speakingLanguage: ChatSettingSpeakingLangEnum$1.AUTO,
    audioSpeed: ChatSettingAudioSpeed.ONE
});
const AudioSpeedMap = {
    BOT_CHAT_SETTING_AUDIO_SPEED_ZERO_POINT_FIVE: 0.5,
    BOT_CHAT_SETTING_AUDIO_SPEED_ZERO_POINT_SEVEN_FIVE: 0.75,
    BOT_CHAT_SETTING_AUDIO_SPEED_ONE: 1,
    BOT_CHAT_SETTING_AUDIO_SPEED_ONE_POINT_TWENTY_FIVE: 1.25,
    BOT_CHAT_SETTING_AUDIO_SPEED_ONE_POINT_FIVE: 1.5
};

function PlayIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    d: "M6.3 2.84A1.5 1.5 0 0 0 4 4.11v11.78a1.5 1.5 0 0 0 2.3 1.27l9.344-5.891a1.5 1.5 0 0 0 0-2.538L6.3 2.841Z"
  }));
}
const ForwardRef$7 = /*#__PURE__*/ React__namespace.forwardRef(PlayIcon);

const AudioPlayer$1 = React.forwardRef(({ src, onManuallyInteracted, onEnded, serverDuration, onProgressUpdate, initialTime }, ref) => {
    const AudioComp = useAudioPlayer();
    const [audio, state, controls] = reactUse.useAudio(jsxRuntime.jsx(AudioComp, { src: src, onTimeUpdate: () => {
            onProgressUpdate === null || onProgressUpdate === void 0 ? void 0 : onProgressUpdate(state.time);
        }, onEnded: () => {
            controls.seek(0);
            onEnded === null || onEnded === void 0 ? void 0 : onEnded();
        } }));
    const { paused, time, playing } = state;
    const duration = state.duration || serverDuration || 0;
    React.useImperativeHandle(ref, () => ({
        play: () => {
            controls.play();
        },
        pause: () => {
            controls.pause();
        }
    }));
    const onAudioToggle = () => {
        if (paused) {
            const audios = document.getElementsByTagName('audio');
            for (let i = 0, len = audios.length; i < len; i++) {
                audios[i].pause();
            }
            if (state.time !== 0) {
                controls.seek(state.time);
            }
            controls.play();
            onManuallyInteracted === null || onManuallyInteracted === void 0 ? void 0 : onManuallyInteracted(true);
        }
        else {
            controls.pause();
            onManuallyInteracted === null || onManuallyInteracted === void 0 ? void 0 : onManuallyInteracted(false);
        }
    };
    reactUse.useEffectOnce(() => {
        if (initialTime) {
            state.time = initialTime;
        }
    });
    return (jsxRuntime.jsxs("div", { className: "flex flex-col gap-1 w-full overflow-hidden", children: [jsxRuntime.jsx("div", { className: "bg-surface-primary-default h-px w-full items-start", style: { width: `${getPercent(time, duration) * 100}%` } }), jsxRuntime.jsxs("div", { className: "flex items-center gap-[6px]", children: [jsxRuntime.jsx("div", { className: "size-6 flex justify-center items-center", children: jsxRuntime.jsx(IconButton, { className: "size-5", onClick: onAudioToggle, loading: !src || !duration, children: paused ? jsxRuntime.jsx(ForwardRef$7, { className: "size-3 ml-0.5" }) : jsxRuntime.jsx(AudioPlaying, {}) }) }), jsxRuntime.jsx("div", { className: "flex flex-col grow overflow-hidden", children: jsxRuntime.jsx("div", { className: "text-sm text-brand truncate", children: durationFormatter(((playing || paused) && time) || duration) }) })] }), audio] }));
});
AudioPlayer$1.displayName = 'AudioPlayer';

function useRegenerate(type, id, partialUpdateMessage, partialUpdateRegenMessage, enQueue, setEnergyInfo) {
    const [generating, setGenerating] = reactUse.useToggle(false);
    const handleRegenerate = async (messageId, regenMsgId) => {
        try {
            setGenerating(true);
            const { success, data, msg } = await ttsRegen(messageId);
            if (success) {
                const { audioUrl, audioSpeed, energyInfo, duration } = data;
                if (messageId === regenMsgId) {
                    partialUpdateMessage === null || partialUpdateMessage === void 0 ? void 0 : partialUpdateMessage(messageId, {
                        audioUrl,
                        audioSpeed: AudioSpeedMap[audioSpeed],
                        duration
                    });
                    enQueue === null || enQueue === void 0 ? void 0 : enQueue(messageId);
                }
                else {
                    partialUpdateRegenMessage === null || partialUpdateRegenMessage === void 0 ? void 0 : partialUpdateRegenMessage(messageId, regenMsgId, {
                        audioUrl,
                        audioSpeed: AudioSpeedMap[audioSpeed],
                        duration
                    });
                    enQueue === null || enQueue === void 0 ? void 0 : enQueue(regenMsgId);
                }
                setEnergyInfo === null || setEnergyInfo === void 0 ? void 0 : setEnergyInfo(energyInfo);
            }
            else {
                console.error(msg);
            }
        }
        catch (e) {
            console.error(e);
        }
        finally {
            setGenerating(false);
        }
    };
    return {
        generating,
        handleRegenerate
    };
}

function RegenPlaceholder() {
    const { type, entityInfo, setEnergyInfo } = React.useContext(StaticContext);
    const { partialUpdateMessage, partialUpdateRegenMessage, enQueue } = React.useContext(MessageContext);
    const { id } = entityInfo;
    const { message, displayMessage, setAudioPlayProgress } = useDisplayContext();
    const isVisitor = useUserStore(state => state.isVisitor);
    const { generating, handleRegenerate } = useRegenerate(type, id, partialUpdateMessage, partialUpdateRegenMessage, enQueue, setEnergyInfo);
    const onRegenerate = () => {
        setAudioPlayProgress === null || setAudioPlayProgress === void 0 ? void 0 : setAudioPlayProgress(0);
        handleRegenerate(message === null || message === void 0 ? void 0 : message.id, displayMessage.id);
    };
    return (jsxRuntime.jsx("div", { className: "flex flex-col gap-1 w-full overflow-hidden", children: jsxRuntime.jsx("div", { className: "flex items-center gap-[6px]", children: isVisitor === VisitorEnum.YES ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(IconButton, { className: "size-5", onClick: onRegenerate, loading: generating, children: jsxRuntime.jsx(ForwardRef$f, { className: "size-3 ml-0.5" }) }), jsxRuntime.jsx("div", { className: "flex flex-col grow overflow-hidden", children: jsxRuntime.jsx("div", { className: "text-sm text-brand truncate", children: durationFormatter(0) }) })] })) : (jsxRuntime.jsxs(Button$1, { variant: "primary", size: "sm", color: "brand", className: "h-6 px-2", onClick: onRegenerate, loading: generating, children: [jsxRuntime.jsx("div", { className: "rounded-full bg-white size-[14px] flex justify-center items-center", children: jsxRuntime.jsx(ForwardRef$f, { className: "size-[10px] text-icon-brand ml-[1.5px]" }) }), jsxRuntime.jsx(Separator, { orientation: "vertical", className: "h-3 border-beta-white-20 mx-[6px]" }), jsxRuntime.jsxs("div", { className: "flex gap-[2px] items-center", children: [jsxRuntime.jsx(Image__default.default, { alt: "energy cost", src: "https://www.myshellstatic.com/image/chat/embed_obj/172/202405210853/icon-wrapper-16px@2x.png.png", width: 16, height: 16, className: "size-4 rounded-[4px]" }), jsxRuntime.jsx(Text, { size: "xs", className: "text-inherit", children: "1" })] })] })) }) }));
}

function AudioDisplay({ showAudio = false }) {
    const audioPlayerRef = React.useRef(null);
    const { audioPlayProgress, setAudioPlayProgress, displayMessage: message, prevMessageIndex, currentMessageIndex } = useDisplayContext();
    const { chatSetting } = React.useContext(StaticContext);
    const { playingAudio, playNext, enQueue, clearQueue } = React.useContext(MessageContext);
    const { audioUrl, status, id, source } = message;
    const audioRegenNeeded = React.useMemo(() => {
        if (showAudio && (message === null || message === void 0 ? void 0 : message.status) === 'DONE' && !(message === null || message === void 0 ? void 0 : message.audioUrl)) {
            return true;
        }
        if ((chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.audioSpeed) && (message === null || message === void 0 ? void 0 : message.audioSpeed) !== AudioSpeedMap[chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.audioSpeed]) {
            return true;
        }
        return false;
    }, [showAudio, message === null || message === void 0 ? void 0 : message.status, message === null || message === void 0 ? void 0 : message.audioUrl, message === null || message === void 0 ? void 0 : message.audioSpeed, chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.audioSpeed]);
    React.useEffect(() => {
        var _a, _b;
        if (playingAudio === id && audioUrl) {
            (_a = audioPlayerRef.current) === null || _a === void 0 ? void 0 : _a.play();
        }
        else {
            (_b = audioPlayerRef.current) === null || _b === void 0 ? void 0 : _b.pause();
        }
    }, [playingAudio, audioUrl, status, id]);
    React.useEffect(() => {
        if (prevMessageIndex !== currentMessageIndex) {
            playNext === null || playNext === void 0 ? void 0 : playNext();
            setAudioPlayProgress === null || setAudioPlayProgress === void 0 ? void 0 : setAudioPlayProgress(0);
        }
    }, [currentMessageIndex]);
    const onEnded = () => {
        playNext === null || playNext === void 0 ? void 0 : playNext();
    };
    const onManuallyInteracted = (play) => {
        clearQueue === null || clearQueue === void 0 ? void 0 : clearQueue();
        if (play) {
            enQueue === null || enQueue === void 0 ? void 0 : enQueue(id);
        }
    };
    const onTimeUpdate = (duration) => {
        setAudioPlayProgress === null || setAudioPlayProgress === void 0 ? void 0 : setAudioPlayProgress(duration);
    };
    if (source === 'USER') {
        if (message === null || message === void 0 ? void 0 : message.audioUrl) {
            return jsxRuntime.jsx(AudioPlayer$1, { src: message === null || message === void 0 ? void 0 : message.audioUrl });
        }
    }
    else {
        if (showAudio) {
            if (audioRegenNeeded) {
                return jsxRuntime.jsx(RegenPlaceholder, {});
            }
            return (jsxRuntime.jsx(AudioPlayer$1, { ref: audioPlayerRef, src: message === null || message === void 0 ? void 0 : message.audioUrl, onEnded: onEnded, onManuallyInteracted: onManuallyInteracted, serverDuration: message === null || message === void 0 ? void 0 : message.duration, initialTime: audioPlayProgress, onProgressUpdate: onTimeUpdate }));
        }
        return null;
    }
}

var atelierHeathLight = {
  "hljs-comment": {
    "color": "#776977"
  },
  "hljs-quote": {
    "color": "#776977"
  },
  "hljs-variable": {
    "color": "#ca402b"
  },
  "hljs-template-variable": {
    "color": "#ca402b"
  },
  "hljs-attribute": {
    "color": "#ca402b"
  },
  "hljs-tag": {
    "color": "#ca402b"
  },
  "hljs-name": {
    "color": "#ca402b"
  },
  "hljs-regexp": {
    "color": "#ca402b"
  },
  "hljs-link": {
    "color": "#ca402b"
  },
  "hljs-selector-id": {
    "color": "#ca402b"
  },
  "hljs-selector-class": {
    "color": "#ca402b"
  },
  "hljs-number": {
    "color": "#a65926"
  },
  "hljs-meta": {
    "color": "#a65926"
  },
  "hljs-built_in": {
    "color": "#a65926"
  },
  "hljs-builtin-name": {
    "color": "#a65926"
  },
  "hljs-literal": {
    "color": "#a65926"
  },
  "hljs-type": {
    "color": "#a65926"
  },
  "hljs-params": {
    "color": "#a65926"
  },
  "hljs-string": {
    "color": "#918b3b"
  },
  "hljs-symbol": {
    "color": "#918b3b"
  },
  "hljs-bullet": {
    "color": "#918b3b"
  },
  "hljs-title": {
    "color": "#516aec"
  },
  "hljs-section": {
    "color": "#516aec"
  },
  "hljs-keyword": {
    "color": "#7b59c0"
  },
  "hljs-selector-tag": {
    "color": "#7b59c0"
  },
  "hljs": {
    "display": "block",
    "overflowX": "auto",
    "background": "#f7f3f7",
    "color": "#695d69",
    "padding": "0.5em"
  },
  "hljs-emphasis": {
    "fontStyle": "italic"
  },
  "hljs-strong": {
    "fontWeight": "bold"
  }
};

var __rest$b = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const capitalizationLanguageNameMap = {
    sql: 'SQL',
    javascript: 'JavaScript',
    java: 'Java',
    typescript: 'TypeScript',
    vbscript: 'VBScript',
    css: 'CSS',
    html: 'HTML',
    xml: 'XML',
    php: 'PHP',
    python: 'Python',
    yaml: 'Yaml',
    mermaid: 'Mermaid',
    markdown: 'MarkDown',
    makefile: 'MakeFile',
    echarts: 'ECharts',
    shell: 'Shell',
    powershell: 'PowerShell',
    json: 'JSON',
    latex: 'Latex',
    svg: 'SVG'
};
const getCorrectCapitalizationLanguageName = (language) => {
    if (!language)
        return 'Plain';
    if (language in capitalizationLanguageNameMap)
        return capitalizationLanguageNameMap[language];
    return language.charAt(0).toUpperCase() + language.substring(1);
};
const punctuationMap = {
    '，': ',',
    '；': ';',
    '。': '.',
    '：': ':',
    '！': '!',
    '？': '?',
    '“': '"',
    '”': '"',
    '‘': "'",
    '’': "'",
    '【': '[',
    '】': ']',
    '（': '(',
    '）': ')',
    '《': '<',
    '》': '>',
    '、': ','
};
const Mermaid = ({ content }) => {
    const [svg, setSvg] = React.useState('');
    React.useEffect(() => {
        (async () => {
            if (!content)
                return;
            try {
                const formatCode = content.replace(new RegExp(`[${Object.keys(punctuationMap).join('')}]`, 'g'), match => punctuationMap[match]);
                const { svg } = await mermaid__default.default.render(`mermaid-${Date.now()}`, formatCode);
                setSvg(svg);
            }
            catch (e) {
                console.log('Mermaid Render Error: ', e === null || e === void 0 ? void 0 : e.message);
            }
        })();
    }, [content]);
    return (jsxRuntime.jsx("div", { className: "mermaid w-full h-full overflow-auto min-w-[500px]", dangerouslySetInnerHTML: { __html: svg } }));
};
const CodeBlock = React.memo((_a) => {
    var { inline, className, children } = _a, props = __rest$b(_a, ["inline", "className", "children"]);
    const t = nextIntl.useTranslations('chat');
    const commonT = nextIntl.useTranslations('common');
    const { success, error: notificationError } = useNotification();
    const { resolvedTheme } = nextThemes.useTheme();
    const isDark = resolvedTheme === 'dark';
    const match = /language-(\w+)/.exec(className || '');
    const language = match === null || match === void 0 ? void 0 : match[1];
    const languageShowName = getCorrectCapitalizationLanguageName(language || '');
    const content = String(children);
    const handleClick = () => {
        navigator.clipboard
            .writeText(children)
            .then(() => {
            success({ content: commonT('code_copied') });
        })
            .catch(error => {
            notificationError({
                content: `${commonT('copy_failed')} ${error}`,
                id: `${commonT('copy_failed')} ${error}`
            });
        });
    };
    const renderCodeContent = React.useMemo(() => {
        const codeContent = content.replace(/\n$/, '');
        return (jsxRuntime.jsx(SyntaxHighlighter__default.default, Object.assign({}, props, { style: atelierHeathLight, customStyle: {
                paddingLeft: 12,
                backgroundColor: isDark ? '#27282c' : '#fff'
            }, language: match === null || match === void 0 ? void 0 : match[1], showLineNumbers: true, PreTag: "div", children: codeContent })));
    }, [language, match, props, content]);
    if (language === 'mermaid') {
        return jsxRuntime.jsx(Mermaid, { content: content });
    }
    if ((inline || !match) && !content.includes('\n')) {
        return (jsxRuntime.jsx("code", Object.assign({}, props, { className: cn('px-1', className), children: children })));
    }
    return (jsxRuntime.jsxs("div", { className: "marked-code-block", children: [jsxRuntime.jsxs("div", { className: "marked-code-header bg-surface-container-pressed alt-14 text-subtle", children: [jsxRuntime.jsx("span", { children: languageShowName }), jsxRuntime.jsx("button", { className: "copy-button text-brand", onClick: handleClick, children: t('copy_code') })] }), renderCodeContent] }));
});
CodeBlock.displayName = 'CodeBlock';
const Table = (props) => {
    return (jsxRuntime.jsx("div", { className: "marked-table-container", children: jsxRuntime.jsx("table", { children: props.children }) }));
};
Table.displayName = 'Table';
const Image$2 = ({ src, alt }) => {
    if (!alt) {
        return jsxRuntime.jsx("img", { src: src, "x-intercept-click": "1" });
    }
    return jsxRuntime.jsx("img", { src: src, alt: alt, title: alt, "x-intercept-click": "1" });
};
Image$2.displayName = 'Image';
const Link = ({ children, href }) => {
    return (jsxRuntime.jsx("a", { href: href, target: "_blank", rel: "noopener noreferrer", children: children || href }));
};

const maxWaitTime = 3;
const preprocessLaTeX = (content) => {
    if (typeof content !== 'string')
        return content;
    return content
        .replace(/\\\[([\s\S]*?)\\\]/g, (_, equation) => `$$${equation}$$`)
        .replace(/\\\(([\s\S]*?)\\\)/g, (_, equation) => `$$${equation}$$`)
        .replace(/(^|[^\\])\$(.+?)\$/g, (_, prefix, equation) => `${prefix}$${equation}$`);
};
function MdViewer$2(props) {
    const { hideMedia } = props;
    const SanitizeConfig = {
        ALLOWED_ATTR: [
            'width',
            'height',
            'color',
            'src',
            'alt',
            'value',
            'max',
            'min',
            'href',
            'target',
            'title',
            'controls',
            'type'
        ],
        ALLOWED_TAGS: [
            ...[
                'p',
                'li',
                'strong',
                'h1',
                'h2',
                'h3',
                'h4',
                'h5',
                'h6',
                'meter',
                'ul',
                'br',
                'hr',
                'center',
                'td',
                'b',
                'a',
                'tr',
                'ol',
                'blockquote',
                'table',
                'div',
                'tbody',
                'source',
                'em',
                'summary',
                'progress',
                'font',
                'span'
            ],
            ...(hideMedia ? [] : ['img', 'video'])
        ]
    };
    const mdViewerRef = React.useRef(null);
    const startTime = React.useRef(0);
    const convertString = (content, status, notParseHTML = false) => {
        const imageRegex = /!\[.*?\]\((.*?)\)/g;
        const regex = /!\[(.*?)\]$/;
        const str = content || '';
        let truncatedStr = str.trim();
        let overWaitTime = false;
        let endTime = 0;
        if (startTime.current !== 0) {
            endTime = performance.now();
            overWaitTime = (endTime - startTime.current) / 1000 > maxWaitTime;
        }
        if (!imageRegex.test(truncatedStr) && regex.test(truncatedStr) && status !== 'DONE') {
            if (!overWaitTime) {
                if (startTime.current === 0) {
                    startTime.current = performance.now();
                }
                else {
                    const imageIndex = truncatedStr.search(regex);
                    truncatedStr = imageIndex !== -1 ? truncatedStr.substring(0, imageIndex) : str;
                }
            }
            else if (startTime.current !== 0 && (endTime - startTime.current) / 1000 > 2 * maxWaitTime) {
                startTime.current = 0;
            }
        }
        else if (startTime.current !== 0) {
            startTime.current = 0;
        }
        if (notParseHTML) {
            return preprocessLaTeX(truncatedStr);
        }
        return isomorphicDompurify.sanitize(preprocessLaTeX(truncatedStr), SanitizeConfig);
    };
    return (jsxRuntime.jsx("div", { ref: mdViewerRef, children: jsxRuntime.jsx(ReactMarkdown__default.default, { remarkPlugins: [RemarkMath__default.default, [RemarkGfm__default.default, { singleTilde: false }], RemarkBreaks__default.default], rehypePlugins: [
                RehypeKatex__default.default,
                [RehypeExternalLinks__default.default, { target: '_blank' }],
                ...(props.notParseHTML ? [] : [RehypeRaw__default.default])
            ], className: cn('md-viewer prose-base prose-pre:my-0 prose-pre:p-0 prose-headings:m-0 prose-hr:my-[1em] max-w-fit overflow-hidden', props.nouseProse ? '' : 'prose dark:prose-invert', props.className), components: {
                code: CodeBlock,
                table: Table,
                img: Image$2,
                a: Link
            }, disallowedElements: ['script', 'iframe', 'head', 'html', 'meta', 'link', 'style', 'body'], children: convertString(props.content, props.status, props.notParseHTML) }) }));
}
var MdViewer$3 = React.memo(MdViewer$2);

var MdViewer$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: MdViewer$3
});

const MdViewer$1 = dynamic__default.default(() => Promise.resolve().then(function () { return MdViewer$4; }), {
    loading: () => jsxRuntime.jsx("div", { children: "loading..." }),
    ssr: false
});
function TranslationDisplay() {
    const { translationStatus, translate } = React.useContext(MessageContext);
    const { message } = useDisplayContext();
    const chatLocale = nextIntl.useTranslations('chat');
    const onTranslate = () => {
        translate === null || translate === void 0 ? void 0 : translate(message === null || message === void 0 ? void 0 : message.id);
    };
    const quotedReference = React.useMemo(() => {
        let result;
        if (message === null || message === void 0 ? void 0 : message.referenceText) {
            const referenceText = message.referenceText
                .split('\n')
                .map(line => `> ${line}`)
                .join('\n');
            result = `${referenceText}\n\n`;
        }
        return result;
    }, [message === null || message === void 0 ? void 0 : message.referenceText]);
    reactUse.useEffectOnce(() => {
        if (!(message === null || message === void 0 ? void 0 : message.translation)) {
            onTranslate();
        }
    });
    if (message === null || message === void 0 ? void 0 : message.translation) {
        return jsxRuntime.jsx(MdViewer$1, { content: `${quotedReference !== null && quotedReference !== void 0 ? quotedReference : ''}${message.translation}`, notParseHTML: message.isLlmBot });
    }
    if (translationStatus === 'TRANSLATING') {
        return (jsxRuntime.jsxs("div", { className: "flex items-center gap-1", children: [jsxRuntime.jsx(Text, { className: "leading-7", children: chatLocale('translating') }), jsxRuntime.jsx(ForwardRef$Q, { className: "animate-spin size-[18px]" })] }));
    }
    return (jsxRuntime.jsxs("div", { className: "flex items-center gap-1", children: [jsxRuntime.jsx(Text, { className: "leading-7", children: chatLocale('translation_failed') }), jsxRuntime.jsx(ForwardRef$Q, { className: "size-[18px] ", onClick: onTranslate })] }));
}

function GalleryPublishTipModal({ publishing, open, publishState, onClose, onConfirm }) {
    const t = nextIntl.useTranslations();
    const router = useRoute();
    const user = useUserStore(state => state.user);
    const isMobile = useGlobalStore(state => state.isMobile);
    const [showUserDetail, setShowUserDetail] = React.useState(false);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Modal, { overlayClose: !publishing, hideClose: publishing, open: open, onClose: onClose, onConfirm: () => {
                    if (publishState === 'success' && user) {
                        if (isMobile) {
                            router.openUrl(`/m/explore/profile/${encodeURIComponent(user.name)}/${encodeURIComponent(user.nameTag)}?from=gallery`);
                        }
                        else {
                            setShowUserDetail(true);
                            onClose();
                        }
                    }
                    else {
                        onConfirm();
                    }
                }, state: publishState || 'info', confirmText: publishState === 'success' ? t('chat.go_to_profile') : t('workshop.publish'), isNotification: true, title: publishState === 'success' ? t('chat.publish_success') : t('chat.user_tips'), description: publishState === 'success' ? t('chat.publish_success_content') : t('chat.publish_tip_content'), confirmLoading: publishing, overlayClassName: "z-[110]", contentClassName: "z-[110]" }), showUserDetail && (jsxRuntime.jsx(UserDetailModal, { isOpen: showUserDetail, onClose: () => setShowUserDetail(false), userName: user === null || user === void 0 ? void 0 : user.name, nameTag: user === null || user === void 0 ? void 0 : user.nameTag, defaultTab: "gallery" }))] }));
}

function TextDisplay({ hideMedia = false }) {
    var _a, _b;
    const { message, displayMode, publishState, popupConfirmItem, setPopupConfirmItem, setPublishState, setPopupConfirmVisible, displayMessage } = useDisplayContext();
    React.useContext(StaticContext);
    const { editorMode, publish } = React.useContext(MessageContext);
    const { everPublished, publishing, publishSingleImgToGallery } = publish || {};
    const quotedReference = React.useMemo(() => {
        let result;
        if (message === null || message === void 0 ? void 0 : message.referenceText) {
            const referenceText = message.referenceText
                .split('\n')
                .map(line => `> ${line}`)
                .join('\n');
            result = `${referenceText}\n\n`;
        }
        return result;
    }, [message === null || message === void 0 ? void 0 : message.referenceText]);
    const publishSuccessCb = React.useCallback(() => {
        if (publishState === 'info' && !everPublished) {
            setPublishState === null || setPublishState === void 0 ? void 0 : setPublishState('success');
        }
        else {
            setPublishState === null || setPublishState === void 0 ? void 0 : setPublishState('info');
            setPopupConfirmVisible === null || setPopupConfirmVisible === void 0 ? void 0 : setPopupConfirmVisible(false);
        }
    }, [publishState, everPublished, setPublishState, setPopupConfirmVisible]);
    const confirmHandler = React.useCallback(() => {
        if (publishState === 'success') {
            setPopupConfirmItem === null || setPopupConfirmItem === void 0 ? void 0 : setPopupConfirmItem();
        }
        else {
            popupConfirmItem && (publishSingleImgToGallery === null || publishSingleImgToGallery === void 0 ? void 0 : publishSingleImgToGallery(popupConfirmItem, publishSuccessCb));
        }
    }, [publishState, setPopupConfirmItem, popupConfirmItem, publishSingleImgToGallery, publishSuccessCb]);
    if (displayMode === 'TRANSLATION') {
        return jsxRuntime.jsx(TranslationDisplay, {});
    }
    if ((_a = message === null || message === void 0 ? void 0 : message.slashCommandInput) === null || _a === void 0 ? void 0 : _a.name) {
        return (jsxRuntime.jsxs("p", { children: [jsxRuntime.jsx(Text, { color: "brand", children: message.slashCommandInput.name }), Object.entries(message.slashCommandInput.paramMap).map(([key, value]) => (jsxRuntime.jsxs("p", { children: [jsxRuntime.jsx(Text, { weight: "semibold", children: key }), ": ", jsxRuntime.jsx(Text, { children: value })] }, key)))] }));
    }
    return ((message === null || message === void 0 ? void 0 : message.text) && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { className: "relative", children: jsxRuntime.jsx(MdViewer$3, { content: `${quotedReference !== null && quotedReference !== void 0 ? quotedReference : ''}${(_b = displayMessage === null || displayMessage === void 0 ? void 0 : displayMessage.text) !== null && _b !== void 0 ? _b : ''}`, status: message.status, notParseHTML: message.isLlmBot, className: "leading-6", hideMedia: hideMedia }) }), jsxRuntime.jsx(GalleryPublishTipModal, { open: !!popupConfirmItem, onClose: () => {
                    setPopupConfirmItem === null || setPopupConfirmItem === void 0 ? void 0 : setPopupConfirmItem();
                }, onConfirm: confirmHandler, publishState: publishState !== null && publishState !== void 0 ? publishState : 'info', publishing: publishing !== null && publishing !== void 0 ? publishing : false })] })));
}

const DefaultDisplay = ({ message, showText = true, showAudio = false }) => {
    var _a;
    if ((message.status === 'CANCELING' || message.status === 'CANCELED') &&
        showText &&
        !message.text &&
        showAudio &&
        !message.audioUrl) {
        return jsxRuntime.jsx(ForwardRef$t, { className: "w-6 h-6 text-icon" });
    }
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [showText && jsxRuntime.jsx(TextDisplay, {}), jsxRuntime.jsx(References, { references: message.referenceSource }), showText && showAudio && jsxRuntime.jsx(Separator, { className: "border-dashed" }), jsxRuntime.jsx(AudioDisplay, { showAudio: showAudio }), jsxRuntime.jsx(FileDisplay$1, { embedObjs: (_a = message.embedObjs) !== null && _a !== void 0 ? _a : [] })] }));
};

const LoadingIcon = (props) => (jsxRuntime.jsxs(react.Icon, Object.assign({ viewBox: "0 0 120 30", fill: "#fff", width: "30", height: "14", color: "#6D7175" }, props, { w: 6, h: 6, children: [jsxRuntime.jsxs("circle", { cx: "15", cy: "15", r: "15", fill: "var(--surface-primary-default, red)", children: [jsxRuntime.jsx("animate", { attributeName: "r", begin: "0s", calcMode: "linear", dur: "0.8s", from: "15", repeatCount: "indefinite", to: "15", values: "15;9;15" }), jsxRuntime.jsx("animate", { attributeName: "fill-opacity", begin: "0s", calcMode: "linear", dur: "0.8s", from: "1", repeatCount: "indefinite", to: "1", values: "1;.5;1" })] }), jsxRuntime.jsxs("circle", { cx: "60", cy: "15", r: "9", fill: "var(--surface-primary-default, red)", fillOpacity: ".3", children: [jsxRuntime.jsx("animate", { attributeName: "r", begin: "0s", calcMode: "linear", dur: "0.8s", from: "9", repeatCount: "indefinite", to: "9", values: "9;15;9" }), jsxRuntime.jsx("animate", { attributeName: "fill-opacity", begin: "0s", calcMode: "linear", dur: "0.8s", from: ".5", repeatCount: "indefinite", to: ".5", values: ".5;1;.5" })] }), jsxRuntime.jsxs("circle", { cx: "105", cy: "15", r: "15", fill: "var(--surface-primary-default, red)", children: [jsxRuntime.jsx("animate", { attributeName: "r", begin: "0s", calcMode: "linear", dur: "0.8s", from: "15", repeatCount: "indefinite", to: "15", values: "15;9;15" }), jsxRuntime.jsx("animate", { attributeName: "fill-opacity", begin: "0s", calcMode: "linear", dur: "0.8s", from: "1", repeatCount: "indefinite", to: "1", values: "1;.5;1" })] })] })));

var __rest$a = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const ContextMenu = ContextMenuPrimitive__namespace.Root;
const ContextMenuTrigger = ContextMenuPrimitive__namespace.Trigger;
const ContextMenuSubTrigger = React__namespace.forwardRef((_a, ref) => {
    var { className, inset, children } = _a, props = __rest$a(_a, ["className", "inset", "children"]);
    return (jsxRuntime.jsxs(ContextMenuPrimitive__namespace.SubTrigger, Object.assign({ ref: ref, className: cn('flex cursor-default select-none items-center rounded-lg py-1 px-2 text-sm outline-none hover:bg-surface-hovered data-[state=open]:bg-slate-100 data-[state=open]:text-slate-900 dark:focus:bg-slate-800 dark:focus:text-slate-50 dark:data-[state=open]:bg-slate-800 dark:data-[state=open]:text-slate-50', inset && 'pl-8', className) }, props, { children: [children, jsxRuntime.jsx(lucideReact.ChevronRight, { className: "ml-auto h-4 w-4" })] })));
});
ContextMenuSubTrigger.displayName = ContextMenuPrimitive__namespace.SubTrigger.displayName;
const ContextMenuSubContent = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$a(_a, ["className"]);
    return (jsxRuntime.jsx(ContextMenuPrimitive__namespace.SubContent, Object.assign({ ref: ref, className: cn('flex flex-col gap-y-1 z-50 overflow-hidden rounded-xl border border-opaque bg-surface-container-default p-2 text-default shadow-modal-default', className) }, props)));
});
ContextMenuSubContent.displayName = ContextMenuPrimitive__namespace.SubContent.displayName;
const ContextMenuContent = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$a(_a, ["className"]);
    return (jsxRuntime.jsx(ContextMenuPrimitive__namespace.Portal, { children: jsxRuntime.jsx(ContextMenuPrimitive__namespace.Content, Object.assign({ ref: ref, className: cn('z-50 min-w-[8rem] overflow-hidden rounded-xl border-none bg-surface-default p-1 text-default shadow-modal-default border border-opaque', className) }, props)) }));
});
ContextMenuContent.displayName = ContextMenuPrimitive__namespace.Content.displayName;
const ContextMenuItem = React__namespace.forwardRef((_a, ref) => {
    var { className, inset } = _a, props = __rest$a(_a, ["className", "inset"]);
    return (jsxRuntime.jsx(ContextMenuPrimitive__namespace.Item, Object.assign({ ref: ref, className: cn('relative flex cursor-default select-none items-center rounded-lg py-1 px-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-30 focus:bg-surface-container-selected-default', inset && 'pl-8', className) }, props)));
});
ContextMenuItem.displayName = ContextMenuPrimitive__namespace.Item.displayName;
const ContextMenuCheckboxItem = React__namespace.forwardRef((_a, ref) => {
    var { className, children, checked } = _a, props = __rest$a(_a, ["className", "children", "checked"]);
    return (jsxRuntime.jsxs(ContextMenuPrimitive__namespace.CheckboxItem, Object.assign({ ref: ref, className: cn('relative flex cursor-default select-none items-center rounded-lg py-1 px-2 text-sm outline-none hover:bg-surface-hovered data-[disabled]:pointer-events-none data-[disabled]:opacity-50 dark:focus:bg-slate-800 dark:focus:text-slate-50', className), checked: checked }, props, { children: [jsxRuntime.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: jsxRuntime.jsx(ContextMenuPrimitive__namespace.ItemIndicator, { children: jsxRuntime.jsx(lucideReact.Check, { className: "h-4 w-4" }) }) }), children] })));
});
ContextMenuCheckboxItem.displayName = ContextMenuPrimitive__namespace.CheckboxItem.displayName;
const ContextMenuRadioItem = React__namespace.forwardRef((_a, ref) => {
    var { className, children } = _a, props = __rest$a(_a, ["className", "children"]);
    return (jsxRuntime.jsxs(ContextMenuPrimitive__namespace.RadioItem, Object.assign({ ref: ref, className: cn('relative flex cursor-default select-none items-center rounded-lg py-1 px-2 text-sm outline-none hover:bg-surface-hovered data-[disabled]:pointer-events-none data-[disabled]:opacity-50', className) }, props, { children: [jsxRuntime.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: jsxRuntime.jsx(ContextMenuPrimitive__namespace.ItemIndicator, { children: jsxRuntime.jsx(lucideReact.Circle, { className: "h-2 w-2 fill-current" }) }) }), children] })));
});
ContextMenuRadioItem.displayName = ContextMenuPrimitive__namespace.RadioItem.displayName;
const ContextMenuLabel = React__namespace.forwardRef((_a, ref) => {
    var { className, inset } = _a, props = __rest$a(_a, ["className", "inset"]);
    return (jsxRuntime.jsx(ContextMenuPrimitive__namespace.Label, Object.assign({ ref: ref, className: cn('px-2 py-1.5 text-sm font-semibold text-default', inset && 'pl-8', className) }, props)));
});
ContextMenuLabel.displayName = ContextMenuPrimitive__namespace.Label.displayName;
const ContextMenuSeparator = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$a(_a, ["className"]);
    return (jsxRuntime.jsx(ContextMenuPrimitive__namespace.Separator, Object.assign({ ref: ref, className: cn('my-1 h-px bg-[var(--border)]', className) }, props)));
});
ContextMenuSeparator.displayName = ContextMenuPrimitive__namespace.Separator.displayName;

const LinkIcon = React.forwardRef((props, ref) => (jsxRuntime.jsx(Icon, Object.assign({}, props, { children: jsxRuntime.jsxs("svg", { ref: ref, xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 20 20", fill: "currentColor", children: [jsxRuntime.jsx("path", { d: "M16.5847 3.41529C15.3643 2.1949 13.3857 2.1949 12.1653 3.41529L8.41529 7.16529C7.1949 8.38568 7.1949 10.3643 8.41529 11.5847C8.67435 11.8438 8.96648 12.0471 9.27752 12.1957C9.58899 12.3445 9.72086 12.7176 9.57207 13.0291C9.42328 13.3405 9.05018 13.4724 8.73871 13.3236C8.30141 13.1147 7.89219 12.8294 7.53141 12.4686C5.82286 10.76 5.82286 7.98995 7.53141 6.28141L11.2814 2.53141C12.99 0.822864 15.76 0.822864 17.4686 2.53141C19.1771 4.23995 19.1771 7.01005 17.4686 8.71859L16.0044 10.1827C15.7604 10.4268 15.3646 10.4268 15.1206 10.1827C14.8765 9.93866 14.8765 9.54293 15.1206 9.29885L16.5847 7.83471C17.8051 6.61432 17.8051 4.63568 16.5847 3.41529Z" }), jsxRuntime.jsx("path", { d: "M10.4279 6.97094C10.5767 6.65948 10.9498 6.52761 11.2613 6.67639C11.6986 6.8853 12.1078 7.17062 12.4686 7.53141C14.1771 9.23995 14.1771 12.01 12.4686 13.7186L8.71859 17.4686C7.01005 19.1771 4.23995 19.1771 2.53141 17.4686C0.822864 15.76 0.822864 12.99 2.53141 11.2814L3.99555 9.81727C4.23963 9.57319 4.63536 9.57319 4.87943 9.81727C5.12351 10.0613 5.12351 10.4571 4.87943 10.7011L3.41529 12.1653C2.1949 13.3857 2.1949 15.3643 3.41529 16.5847C4.63568 17.8051 6.61432 17.8051 7.83471 16.5847L11.5847 12.8347C12.8051 11.6143 12.8051 9.63568 11.5847 8.41529C11.3257 8.15623 11.0335 7.95289 10.7225 7.80431C10.411 7.65552 10.2791 7.28241 10.4279 6.97094Z" })] }) }))));

const SaveIcon = React.forwardRef((props, ref) => (jsxRuntime.jsx(Icon, Object.assign({}, props, { children: jsxRuntime.jsxs("svg", { ref: ref, xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 20 20", fill: "currentColor", children: [jsxRuntime.jsx("path", { d: "M10 1.25C10.3452 1.25 10.625 1.52982 10.625 1.875L10.625 10.9911L12.0581 9.55806C12.3021 9.31398 12.6979 9.31398 12.9419 9.55806C13.186 9.80214 13.186 10.1979 12.9419 10.4419L10.4419 12.9419C10.3247 13.0592 10.1658 13.125 10 13.125C9.83424 13.125 9.67527 13.0592 9.55806 12.9419L7.05806 10.4419C6.81398 10.1979 6.81398 9.80213 7.05806 9.55806C7.30214 9.31398 7.69786 9.31398 7.94194 9.55806L9.375 10.9911L9.375 1.875C9.375 1.52982 9.65482 1.25 10 1.25Z" }), jsxRuntime.jsx("path", { d: "M6.25 7.5C5.55964 7.5 5 8.05964 5 8.75V16.25C5 16.9404 5.55964 17.5 6.25 17.5H13.75C14.4404 17.5 15 16.9404 15 16.25V8.75C15 8.05964 14.4404 7.5 13.75 7.5H12.5C12.1548 7.5 11.875 7.22018 11.875 6.875C11.875 6.52982 12.1548 6.25 12.5 6.25H13.75C15.1307 6.25 16.25 7.36929 16.25 8.75V16.25C16.25 17.6307 15.1307 18.75 13.75 18.75H6.25C4.86929 18.75 3.75 17.6307 3.75 16.25V8.75C3.75 7.36929 4.86929 6.25 6.25 6.25H7.5C7.84518 6.25 8.125 6.52982 8.125 6.875C8.125 7.22018 7.84518 7.5 7.5 7.5H6.25Z" })] }) }))));

const CopyImageIcon = React.forwardRef((props, ref) => (jsxRuntime.jsx(Icon, Object.assign({}, props, { children: jsxRuntime.jsx("svg", { ref: ref, xmlns: "http://www.w3.org/2000/svg", width: "20", height: "20", viewBox: "0 0 24 24", fill: "currentColor", children: jsxRuntime.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.11 2H17.2727C17.958 1.99999 18.5147 1.99999 18.9662 2.03688C19.4324 2.07497 19.8477 2.15583 20.2338 2.35256C20.8425 2.66268 21.3373 3.15752 21.6474 3.76616C21.8442 4.15225 21.925 4.56757 21.9631 5.03376C22 5.48534 22 6.04197 22 6.72731V13.89C22 14.5754 22 15.132 21.9631 15.5836C21.925 16.0498 21.8442 16.4651 21.6474 16.8512C21.3373 17.4598 20.8425 17.9547 20.2338 18.2648C19.8905 18.4397 19.4704 18.3032 19.2955 17.9599C19.1205 17.6166 19.257 17.1964 19.6004 17.0215C19.9464 16.8452 20.2278 16.5638 20.4042 16.2177C20.484 16.0611 20.5414 15.8498 20.5724 15.4699C20.6041 15.0819 20.6046 14.5824 20.6046 13.8605V6.75687C20.6046 6.03493 20.6041 5.53544 20.5724 5.14739C20.5414 4.76748 20.484 4.55624 20.4042 4.39964C20.2278 4.05355 19.9464 3.77217 19.6004 3.59582C19.4438 3.51603 19.2325 3.45864 18.8526 3.4276C18.4646 3.39589 17.9651 3.39535 17.2431 3.39535H10.1395C9.41759 3.39535 8.9181 3.39589 8.53005 3.4276C8.15015 3.45864 7.9389 3.51603 7.7823 3.59582C7.43621 3.77217 7.15483 4.05355 6.97849 4.39964C6.80356 4.74295 6.38343 4.87946 6.04012 4.70453C5.6968 4.5296 5.56029 4.10948 5.73522 3.76616C6.04534 3.15752 6.54018 2.66268 7.14882 2.35256C7.53492 2.15583 7.95023 2.07497 8.41643 2.03688C8.868 1.99999 9.42464 1.99999 10.11 2ZM6.72733 5.38266H13.89C14.5753 5.38266 15.132 5.38265 15.5836 5.41955C16.0498 5.45763 16.4651 5.5385 16.8512 5.73522C17.4598 6.04534 17.9547 6.54018 18.2648 7.14882C18.4615 7.53492 18.5424 7.95023 18.5804 8.41643C18.6173 8.868 18.6173 9.42463 18.6173 10.11V17.2727C18.6173 17.958 18.6173 18.5147 18.5804 18.9662C18.5424 19.4324 18.4615 19.8477 18.2648 20.2338C17.9547 20.8425 17.4598 21.3373 16.8512 21.6474C16.4651 21.8442 16.0498 21.925 15.5836 21.9631C15.132 22 14.5754 22 13.89 22H6.72731C6.71085 22 6.69446 22 6.67815 22L5.99447 22C5.76242 22 5.54372 22 5.36953 21.9846C5.36199 21.9839 5.35414 21.9832 5.34601 21.9824C5.23672 21.9775 5.13272 21.9712 5.03376 21.9631C4.56757 21.925 4.15225 21.8442 3.76616 21.6474C3.15752 21.3373 2.66268 20.8425 2.35256 20.2338C2.15583 19.8477 2.07497 19.4324 2.03688 18.9662C1.99999 18.5147 1.99999 17.958 2 17.2727V10.11C1.99999 9.42464 1.99999 8.868 2.03688 8.41643C2.07497 7.95023 2.15583 7.53492 2.35256 7.14882C2.66268 6.54018 3.15752 6.04534 3.76616 5.73522C4.15225 5.5385 4.56757 5.45763 5.03376 5.41955C5.48534 5.38265 6.04198 5.38266 6.72733 5.38266ZM6.75687 20.6046H13.8605C14.5824 20.6046 15.0819 20.6041 15.4699 20.5724C15.8498 20.5414 16.0611 20.484 16.2177 20.4042C16.5638 20.2278 16.8452 19.9464 17.0215 19.6004C17.1013 19.4438 17.1587 19.2325 17.1897 18.8526C17.2214 18.4646 17.222 17.9651 17.222 17.2431V16.5173L14.1548 13.4501C13.9792 13.2745 13.8768 13.1729 13.7957 13.104C13.7586 13.0726 13.7376 13.0582 13.7288 13.0528C13.7043 13.0463 13.6784 13.0463 13.6538 13.0528C13.6451 13.0582 13.624 13.0726 13.587 13.104C13.5059 13.1729 13.4035 13.2745 13.2279 13.4501L6.07486 20.6031C6.27805 20.6046 6.50379 20.6046 6.75687 20.6046ZM13.6586 13.05C13.659 13.0498 13.6586 13.05 13.6586 13.05ZM17.222 14.544L15.1247 12.4467C14.9717 12.2937 14.8286 12.1506 14.6987 12.0403C14.5579 11.9207 14.3873 11.7993 14.1682 11.7281C13.8583 11.6274 13.5244 11.6274 13.2144 11.7281C12.9954 11.7993 12.8248 11.9207 12.6839 12.0403C12.554 12.1506 12.411 12.2937 12.258 12.4467L5.03094 19.6737C4.86683 19.8378 4.71216 19.9924 4.59989 20.1265C4.54589 20.191 4.46983 20.2861 4.40657 20.4077C4.40425 20.4065 4.40194 20.4053 4.39964 20.4042C4.05355 20.2278 3.77217 19.9464 3.59582 19.6004C3.51603 19.4438 3.45864 19.2325 3.4276 18.8526C3.39589 18.4646 3.39535 17.9651 3.39535 17.2431V10.1395C3.39535 9.41759 3.39589 8.9181 3.4276 8.53005C3.45864 8.15015 3.51603 7.9389 3.59582 7.7823C3.77217 7.43621 4.05355 7.15483 4.39964 6.97849C4.55624 6.89869 4.76748 6.8413 5.14739 6.81026C5.53544 6.77855 6.03493 6.77801 6.75687 6.77801H13.8605C14.5824 6.77801 15.0819 6.77855 15.4699 6.81026C15.8498 6.8413 16.0611 6.89869 16.2177 6.97849C16.5638 7.15483 16.8452 7.43621 17.0215 7.7823C17.1013 7.9389 17.1587 8.15015 17.1897 8.53005C17.2214 8.9181 17.222 9.41759 17.222 10.1395V14.544ZM7.34884 9.73784C6.80005 9.73784 6.35518 10.1827 6.35518 10.7315C6.35518 11.2803 6.80005 11.7252 7.34884 11.7252C7.89762 11.7252 8.34249 11.2803 8.34249 10.7315C8.34249 10.1827 7.89762 9.73784 7.34884 9.73784ZM4.95983 10.7315C4.95983 9.41209 6.02942 8.34249 7.34884 8.34249C8.66825 8.34249 9.73784 9.41209 9.73784 10.7315C9.73784 12.0509 8.66825 13.1205 7.34884 13.1205C6.02943 13.1205 4.95983 12.0509 4.95983 10.7315Z" }) }) }))));

function ImageMenuItem({ url, imageModel, naturalHeight, naturalWidth, imageSource, source }) {
    const sensors = useSensors();
    const { type, entityInfo } = React.useContext(StaticContext);
    const { id, name } = entityInfo;
    const { message, setPopupConfirmVisible, setPopupConfirmItem } = useDisplayContext();
    const isVisitor = useUserStore(state => state.isVisitor);
    const toggleLoginModal = useGlobalStore(state => state.toggleLoginModal);
    const { imgGenerator } = React.useContext(StaticContext);
    const { setEditorMode, publish } = React.useContext(MessageContext);
    const { addImg, publishSingleImgToGallery, publishing, everPublished } = publish !== null && publish !== void 0 ? publish : {};
    const t = nextIntl.useTranslations('chat');
    const { onCopy, onCopyImage } = useCopyClipboard(url);
    const { onDownload, onImageDownload } = useDownload();
    const onSendSensors = (action_type) => {
        if (imageModel) {
            sensors === null || sensors === void 0 ? void 0 : sensors.track('MessageAction', Object.assign(Object.assign({ action_type, message_id: message === null || message === void 0 ? void 0 : message.id }, (type === 'widget'
                ? {
                    widget_id: id,
                    widget_name: name
                }
                : {
                    bot_id: id,
                    bot_name: name
                })), { image_model: imageModel }));
        }
        else {
            mediaFileMetadata({
                media_file_url: url
            })
                .then(res => {
                var _a;
                sensors === null || sensors === void 0 ? void 0 : sensors.track('MessageAction', Object.assign(Object.assign({ action_type, message_id: message === null || message === void 0 ? void 0 : message.id }, (type === 'widget'
                    ? {
                        widget_id: id,
                        widget_name: name
                    }
                    : {
                        bot_id: id,
                        bot_name: name
                    })), { image_model: (_a = res === null || res === void 0 ? void 0 : res.meta) === null || _a === void 0 ? void 0 : _a.generateModel }));
            })
                .catch(() => {
                sensors === null || sensors === void 0 ? void 0 : sensors.track('MessageAction', Object.assign(Object.assign({ action_type, message_id: message === null || message === void 0 ? void 0 : message.id }, (type === 'widget'
                    ? {
                        widget_id: id,
                        widget_name: name
                    }
                    : {
                        bot_id: id,
                        bot_name: name
                    })), { image_model: '' }));
            });
        }
    };
    const onDownloadWithSensors = () => {
        console.log('aaaaaa5');
        if (source === 'USER') {
            onDownload(url, generateUUID());
        }
        else {
            onImageDownload(url, generateUUID());
        }
        onSendSensors(MenuActionType.Save_Image);
    };
    const onCopyImageWithSensors = () => {
        onCopyImage();
        onSendSensors(MenuActionType.Copy_Image);
    };
    const onCopyLinkWithSensors = () => {
        onCopy();
        onSendSensors(MenuActionType.Copy_Image_Link);
    };
    const onPublishToGalleryWithSensors = () => {
        if (isVisitor === VisitorEnum.YES) {
            toggleLoginModal(true);
        }
        else if (imageSource === 'markdown') {
            const item = {
                messageId: message.id,
                imageLink: url,
                naturalHeight,
                naturalWidth
            };
            if (everPublished) {
                publishSingleImgToGallery === null || publishSingleImgToGallery === void 0 ? void 0 : publishSingleImgToGallery(item);
                onSendSensors(MenuActionType.Publish_To_Gallery);
            }
            else {
                setPopupConfirmVisible === null || setPopupConfirmVisible === void 0 ? void 0 : setPopupConfirmVisible(true);
                setPopupConfirmItem === null || setPopupConfirmItem === void 0 ? void 0 : setPopupConfirmItem(item);
            }
        }
        else {
            setEditorMode === null || setEditorMode === void 0 ? void 0 : setEditorMode('PUBLISH');
            addImg === null || addImg === void 0 ? void 0 : addImg(url, {
                messageId: message.id,
                imageLink: url,
                naturalHeight,
                naturalWidth
            });
            onSendSensors(MenuActionType.Publish_To_Gallery);
        }
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(ContextMenuItem, { onClick: onDownloadWithSensors, children: [jsxRuntime.jsx(SaveIcon, { className: "w-6 h-6 text-default flex items-center" }), jsxRuntime.jsx(Text, { className: "text-default", children: t('save_image') })] }), jsxRuntime.jsxs(ContextMenuItem, { onClick: onCopyImageWithSensors, children: [jsxRuntime.jsx(CopyImageIcon, { size: "2xl", className: "flex items-center text-default" }), jsxRuntime.jsx(Text, { className: "text-default", children: t('copy_image') })] }), imgGenerator && (message === null || message === void 0 ? void 0 : message.source) === 'OTHER' && (message === null || message === void 0 ? void 0 : message.type) !== 'GREETING' && (jsxRuntime.jsxs(ContextMenuItem, { onClick: onPublishToGalleryWithSensors, disabled: publishing, children: [publishing ? jsxRuntime.jsx(Spinner, {}) : jsxRuntime.jsx(PhotoStackIcon, { size: "2xl", className: "flex items-center text-default" }), jsxRuntime.jsx(Text, { className: "text-default", children: t('publish_to_gallery') })] })), jsxRuntime.jsxs(ContextMenuItem, { onClick: onCopyLinkWithSensors, children: [jsxRuntime.jsx(LinkIcon, { className: "w-6 h-6 text-default flex items-center" }), jsxRuntime.jsx(Text, { className: "text-default", children: t('copy_image_link') })] })] }));
}

function Share(props) {
    const { setEditorMode, share } = React.useContext(MessageContext);
    const { add } = share || {};
    const { message } = useDisplayContext();
    const { source, asMenuItem = false } = props;
    const commonT = nextIntl.useTranslations('bot');
    const onShare = () => {
        add === null || add === void 0 ? void 0 : add(message.id);
        setEditorMode === null || setEditorMode === void 0 ? void 0 : setEditorMode('SHARE');
    };
    if (source === 'menubar') {
        if (asMenuItem) {
            return (jsxRuntime.jsxs(DropdownMenuItem, { onClick: onShare, children: [jsxRuntime.jsx(ForwardRef$O, { className: "w-5 h-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: commonT('share') })] }));
        }
        return (jsxRuntime.jsx(IconButton, { hoverText: commonT('share'), variant: "primary", size: "sm", color: "gray", className: "rounded-lg", onClick: onShare, icon: ForwardRef$O }));
    }
    return (jsxRuntime.jsxs(ContextMenuItem, { onClick: onShare, children: [jsxRuntime.jsx(ForwardRef$O, { className: "w-5 h-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: commonT('share') })] }));
}

const TranscriptionIcon = (props) => (jsxRuntime.jsxs(react.Icon, Object.assign({ viewBox: "0 0 20 20", fill: "none" }, props, { children: [jsxRuntime.jsx("path", { d: "M1.05412 8.20896C1.8842 4.11967 5.49857 1.04163 9.83325 1.04163C14.168 1.04163 17.7823 4.11967 18.6124 8.20896C18.6811 8.54724 18.4625 8.87713 18.1243 8.9458C17.786 9.01447 17.4561 8.79591 17.3874 8.45763C16.6732 4.93942 13.5618 2.29163 9.83325 2.29163C6.5008 2.29163 3.66124 4.4068 2.58571 7.36812L3.96898 6.90703C4.29645 6.79788 4.6504 6.97485 4.75955 7.30232C4.86871 7.62978 4.69173 7.98373 4.36427 8.09289L1.86427 8.92622C1.6526 8.99678 1.41938 8.94914 1.25233 8.80125C1.08528 8.65335 1.00973 8.42762 1.05412 8.20896Z", fill: "currentColor" }), jsxRuntime.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.99996 6.04163C10.2483 6.04163 10.473 6.18862 10.5726 6.41611L13.4892 13.0828C13.6276 13.399 13.4834 13.7675 13.1671 13.9059C12.8509 14.0442 12.4824 13.9 12.344 13.5838L11.5964 11.875H8.40351L7.65589 13.5838C7.51754 13.9 7.14902 14.0442 6.83278 13.9059C6.51654 13.7675 6.37234 13.399 6.51069 13.0828L9.42736 6.41611C9.52689 6.18862 9.75165 6.04163 9.99996 6.04163ZM11.0495 10.625L9.99996 8.22593L8.95039 10.625H11.0495Z", fill: "currentColor" }), jsxRuntime.jsx("path", { d: "M2.27913 11.5423C2.21047 11.204 1.88057 10.9855 1.54229 11.0541C1.20402 11.1228 0.985451 11.4527 1.05412 11.791C1.8842 15.8803 5.49857 18.9583 9.83325 18.9583C14.168 18.9583 17.7823 15.8803 18.6124 11.791C18.6578 11.5673 18.5777 11.3367 18.4035 11.1894C18.2292 11.042 17.9885 11.0014 17.7756 11.0833L15.6089 11.9166C15.2868 12.0405 15.126 12.4022 15.25 12.7243C15.3739 13.0465 15.7355 13.2072 16.0577 13.0833L17.0559 12.6993C15.962 15.6252 13.1404 17.7083 9.83325 17.7083C6.10476 17.7083 2.99329 15.0605 2.27913 11.5423Z", fill: "currentColor" })] })));

function TextException(props) {
    const { addTextDisplayException } = React.useContext(MessageContext);
    const { source, asMenuItem = false } = props;
    const chatLocale = nextIntl.useTranslations('chat');
    const { message } = useDisplayContext();
    const handleClick = () => {
        addTextDisplayException === null || addTextDisplayException === void 0 ? void 0 : addTextDisplayException(message === null || message === void 0 ? void 0 : message.id);
    };
    if (source === 'menubar') {
        if (asMenuItem) {
            return (jsxRuntime.jsxs(DropdownMenuItem, { onClick: handleClick, children: [jsxRuntime.jsx(TranscriptionIcon, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: chatLocale('chat_setting.transcription') })] }));
        }
        return (jsxRuntime.jsx(IconButton, { variant: "primary", size: "sm", color: "gray", className: "rounded-lg", hoverText: chatLocale('chat_setting.transcription'), onClick: handleClick, icon: TranscriptionIcon }));
    }
    return (jsxRuntime.jsxs(ContextMenuItem, { onClick: handleClick, children: [jsxRuntime.jsx(TranscriptionIcon, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: chatLocale('chat_setting.transcription') })] }));
}

function useActionSensors(messageId) {
    const sensors = useSensors();
    const { type, entityInfo } = React.useContext(StaticContext);
    const { id, name } = entityInfo;
    const onSendActionSensors = (action_type, other) => {
        sensors === null || sensors === void 0 ? void 0 : sensors.track('MessageAction', Object.assign(Object.assign({ action_type, message_id: messageId }, (type === 'widget'
            ? {
                widget_id: id,
                widget_name: name
            }
            : {
                bot_id: id,
                bot_name: name
            })), other));
    };
    return {
        onSendActionSensors
    };
}

var __rest$9 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const PauseIcon = (props) => {
    const rest = __rest$9(props, ["fillColor"]);
    return (jsxRuntime.jsxs(react.Icon, Object.assign({ viewBox: "0 0 24 24", fill: "none" }, rest, { children: [jsxRuntime.jsx("path", { d: "M1.26501 9.8508C2.26111 4.94365 6.59836 1.25 11.8 1.25C17.0016 1.25 21.3389 4.94365 22.335 9.8508C22.4174 10.2567 22.1551 10.6526 21.7492 10.735C21.3432 10.8174 20.9474 10.5551 20.865 10.1492C20.008 5.92735 16.2742 2.75 11.8 2.75C7.80103 2.75 4.39356 5.28821 3.10293 8.8418L4.76285 8.28849C5.15581 8.1575 5.58055 8.36987 5.71154 8.76283C5.84252 9.15579 5.63015 9.58053 5.2372 9.71151L2.2372 10.7115C1.9832 10.7962 1.70333 10.739 1.50287 10.5615C1.3024 10.3841 1.21175 10.1132 1.26501 9.8508Z", fill: "currentColor" }), jsxRuntime.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 7.25C12.298 7.25 12.5677 7.4264 12.6871 7.69939L16.1871 15.6994C16.3532 16.0789 16.1801 16.5211 15.8006 16.6871C15.4212 16.8531 14.9789 16.6801 14.8129 16.3006L13.9158 14.25H10.0843L9.18714 16.3006C9.02112 16.6801 8.5789 16.8531 8.19941 16.6871C7.81993 16.5211 7.64688 16.0789 7.81291 15.6994L11.3129 7.69939C11.4323 7.4264 11.7021 7.25 12 7.25ZM13.2595 12.75L12 9.87117L10.7405 12.75H13.2595Z", fill: "currentColor" }), jsxRuntime.jsx("path", { d: "M2.73503 13.8508C2.65263 13.4449 2.25676 13.1826 1.85083 13.265C1.44489 13.3474 1.18261 13.7433 1.26501 14.1492C2.26111 19.0564 6.59836 22.75 11.8 22.75C17.0016 22.75 21.3389 19.0564 22.335 14.1492C22.3895 13.8808 22.2933 13.6041 22.0843 13.4273C21.8752 13.2505 21.5863 13.2017 21.3307 13.3L18.7308 14.3C18.3442 14.4487 18.1513 14.8826 18.3 15.2692C18.4487 15.6558 18.8827 15.8487 19.2693 15.7L20.4672 15.2393C19.1545 18.7503 15.7685 21.25 11.8 21.25C7.32579 21.25 3.59202 18.0726 2.73503 13.8508Z", fill: "currentColor" })] })));
};

function Translation(props) {
    const { source, asMenuItem = false } = props;
    const chatLocale = nextIntl.useTranslations('chat');
    const { message, displayMode, setDisplayMode } = useDisplayContext();
    const { onSendActionSensors } = useActionSensors(message.id);
    const handleClick = () => {
        if (displayMode === 'TRANSLATION') {
            setDisplayMode('NORMAL');
        }
        else {
            setDisplayMode('TRANSLATION');
            onSendActionSensors(MenuActionType.Translate);
        }
    };
    if (source === 'menubar') {
        if (asMenuItem) {
            return (jsxRuntime.jsxs(DropdownMenuItem, { onClick: handleClick, className: clsx__default.default(displayMode === 'TRANSLATION' && 'text-brand'), children: [jsxRuntime.jsx(PauseIcon, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2 text-inherit", children: chatLocale('translate') })] }));
        }
        return (jsxRuntime.jsx(IconButton, { hoverText: chatLocale('translate'), variant: "primary", size: "sm", color: "gray", className: "rounded-lg", onClick: handleClick, children: jsxRuntime.jsx(PauseIcon, { className: clsx__default.default('size-[18px]', displayMode === 'TRANSLATION' ? 'text-brand' : 'text-default') }) }));
    }
    return (jsxRuntime.jsxs(ContextMenuItem, { onClick: handleClick, className: clsx__default.default(displayMode === 'TRANSLATION' && 'text-brand'), children: [jsxRuntime.jsx(PauseIcon, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2 text-inherit", children: chatLocale('translate') })] }));
}

function CopyMessage(props) {
    const { source, asMenuItem = false } = props;
    const commonT = nextIntl.useTranslations('common');
    const { message } = useDisplayContext();
    const { onCopy } = useCopyClipboard('');
    const onCopyMessageWithSensors = () => {
        onCopy(message === null || message === void 0 ? void 0 : message.text);
    };
    if (source === 'menubar') {
        if (asMenuItem) {
            return (jsxRuntime.jsxs(DropdownMenuItem, { onClick: onCopyMessageWithSensors, children: [jsxRuntime.jsx(ForwardRef$F, { className: "w-5 h-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: commonT('copy_message') })] }));
        }
        return (jsxRuntime.jsx(IconButton, { hoverText: commonT('copy_message'), variant: "primary", size: "sm", color: "gray", className: "rounded-lg", onClick: onCopyMessageWithSensors, icon: ForwardRef$F }));
    }
    return (jsxRuntime.jsxs(ContextMenuItem, { onClick: onCopyMessageWithSensors, children: [jsxRuntime.jsx(ForwardRef$F, { className: "w-5 h-5 text-default" }), jsxRuntime.jsx(Text, { className: "ml-2 text-default", children: commonT('copy_message') })] }));
}

function DeleteMessage(props) {
    const { source, asMenuItem } = props;
    const commonT = nextIntl.useTranslations('common');
    const { setDeleteConfirming } = useDisplayContext();
    const onDeleteMessage = () => {
        setDeleteConfirming === null || setDeleteConfirming === void 0 ? void 0 : setDeleteConfirming(true);
    };
    return source === 'menubar' ? (asMenuItem ? (jsxRuntime.jsxs(DropdownMenuItem, { onClick: onDeleteMessage, children: [jsxRuntime.jsx(ForwardRef$l, { className: "size-5 text-critical" }), jsxRuntime.jsx(Text, { className: "ml-2 text-critical", children: commonT('delete') })] })) : (jsxRuntime.jsx(IconButton, { hoverText: commonT('delete'), variant: "primary", size: "sm", color: "gray", className: "rounded-lg", onClick: onDeleteMessage, children: jsxRuntime.jsx(ForwardRef$l, { className: "size-[18px] text-critical" }) }))) : (jsxRuntime.jsxs(ContextMenuItem, { onClick: onDeleteMessage, children: [jsxRuntime.jsx(ForwardRef$l, { className: "size-5 text-critical" }), jsxRuntime.jsx(Text, { className: "ml-2 text-critical", children: commonT('delete') })] }));
}

function DownloadVoice(props) {
    const { source, asMenuItem = false } = props;
    const commonT = nextIntl.useTranslations('common');
    const { entityInfo } = React.useContext(StaticContext);
    const { name } = entityInfo;
    const { message } = useDisplayContext();
    const { downloading, onDownload } = useDownload();
    const onDownloadVoice = async () => {
        try {
            await onDownload(message === null || message === void 0 ? void 0 : message.audioUrl, `MyShell_chat_${dayjs__default.default().format('YY-MM-DD_HH:mm:ss')}_${name}.mp3`);
        }
        catch (e) {
            console.error(e);
        }
    };
    if (source === 'menubar') {
        if (asMenuItem) {
            return (jsxRuntime.jsxs(DropdownMenuItem, { disabled: downloading, onClick: () => {
                    onDownloadVoice();
                }, children: [downloading ? jsxRuntime.jsx(Spinner, {}) : jsxRuntime.jsx(ForwardRef$T, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: commonT('download_voice') })] }));
        }
        return (jsxRuntime.jsx(IconButton, { variant: "primary", size: "sm", color: "gray", className: "rounded-lg", loading: downloading, hoverText: commonT('download_voice'), onClick: onDownloadVoice, children: jsxRuntime.jsx(ForwardRef$T, { className: "size-[18px] text-default" }) }));
    }
    return (jsxRuntime.jsxs(ContextMenuItem, { onClick: onDownloadVoice, disabled: downloading, children: [downloading ? jsxRuntime.jsx(Spinner, { size: "md" }) : jsxRuntime.jsx(ForwardRef$T, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: commonT('download_voice') })] }));
}

function EditMessage(props) {
    const { clearQueue } = React.useContext(MessageContext);
    const workshopLocale = nextIntl.useTranslations('workshop');
    const { source, asMenuItem = false } = props;
    const { setDisplayMode } = useDisplayContext();
    const onEnterEditMode = () => {
        clearQueue === null || clearQueue === void 0 ? void 0 : clearQueue();
        setDisplayMode('EDIT');
    };
    if (source === 'menubar') {
        if (asMenuItem) {
            return (jsxRuntime.jsxs(DropdownMenuItem, { onClick: onEnterEditMode, children: [jsxRuntime.jsx(ForwardRef$q, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: workshopLocale('edit') })] }));
        }
        return (jsxRuntime.jsx(IconButton, { hoverText: workshopLocale('edit'), variant: "primary", size: "sm", color: "gray", className: "rounded-lg", onClick: onEnterEditMode, icon: ForwardRef$q }));
    }
    return (jsxRuntime.jsxs(ContextMenuItem, { onClick: onEnterEditMode, children: [jsxRuntime.jsx(ForwardRef$q, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: workshopLocale('edit') })] }));
}

function HandThumbDownIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    d: "M15.73 5.5h1.035A7.465 7.465 0 0 1 18 9.625a7.465 7.465 0 0 1-1.235 4.125h-.148c-.806 0-1.534.446-2.031 1.08a9.04 9.04 0 0 1-2.861 2.4c-.723.384-1.35.956-1.653 1.715a4.499 4.499 0 0 0-.322 1.672v.633A.75.75 0 0 1 9 22a2.25 2.25 0 0 1-2.25-2.25c0-1.152.26-2.243.723-3.218.266-.558-.107-1.282-.725-1.282H3.622c-1.026 0-1.945-.694-2.054-1.715A12.137 12.137 0 0 1 1.5 12.25c0-2.848.992-5.464 2.649-7.521C4.537 4.247 5.136 4 5.754 4H9.77a4.5 4.5 0 0 1 1.423.23l3.114 1.04a4.5 4.5 0 0 0 1.423.23ZM21.669 14.023c.536-1.362.831-2.845.831-4.398 0-1.22-.182-2.398-.52-3.507-.26-.85-1.084-1.368-1.973-1.368H19.1c-.445 0-.72.498-.523.898.591 1.2.924 2.55.924 3.977a8.958 8.958 0 0 1-1.302 4.666c-.245.403.028.959.5.959h1.053c.832 0 1.612-.453 1.918-1.227Z"
  }));
}
const ForwardRef$6 = /*#__PURE__*/ React__namespace.forwardRef(HandThumbDownIcon);

function HandThumbUpIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    d: "M7.493 18.5c-.425 0-.82-.236-.975-.632A7.48 7.48 0 0 1 6 15.125c0-1.75.599-3.358 1.602-4.634.151-.192.373-.309.6-.397.473-.183.89-.514 1.212-.924a9.042 9.042 0 0 1 2.861-2.4c.723-.384 1.35-.956 1.653-1.715a4.498 4.498 0 0 0 .322-1.672V2.75A.75.75 0 0 1 15 2a2.25 2.25 0 0 1 2.25 2.25c0 1.152-.26 2.243-.723 3.218-.266.558.107 1.282.725 1.282h3.126c1.026 0 1.945.694 2.054 1.715.045.422.068.85.068 1.285a11.95 11.95 0 0 1-2.649 7.521c-.388.482-.987.729-1.605.729H14.23c-.483 0-.964-.078-1.423-.23l-3.114-1.04a4.501 4.501 0 0 0-1.423-.23h-.777ZM2.331 10.727a11.969 11.969 0 0 0-.831 4.398 12 12 0 0 0 .52 3.507C2.28 19.482 3.105 20 3.994 20H4.9c.445 0 .72-.498.523-.898a8.963 8.963 0 0 1-.924-3.977c0-1.708.476-3.305 1.302-4.666.245-.403-.028-.959-.5-.959H4.25c-.832 0-1.612.453-1.918 1.227Z"
  }));
}
const ForwardRef$5 = /*#__PURE__*/ React__namespace.forwardRef(HandThumbUpIcon);

var n=function(r,e){for(var n={};r.length;){var t=r[0],s=t.code,i=t.message,a=t.path.join(".");if(!n[a])if("unionErrors"in t){var u=t.unionErrors[0].errors[0];n[a]={message:u.message,type:u.code};}else n[a]={message:i,type:s};if("unionErrors"in t&&t.unionErrors.forEach(function(e){return e.errors.forEach(function(e){return r.push(e)})}),e){var c=n[a].types,f=c&&c[t.code];n[a]=reactHookForm.appendErrors(a,e,n,s,f?[].concat(f,t.message):t.message);}r.shift();}return n},t=function(o,t,s){return void 0===s&&(s={}),function(i,a,u){try{return Promise.resolve(function(e,n){try{var a=Promise.resolve(o["sync"===s.mode?"parse":"parseAsync"](i,t)).then(function(e){return u.shouldUseNativeValidation&&resolvers.validateFieldsNatively({},u),{errors:{},values:s.raw?i:e}});}catch(r){return n(r)}return a&&a.then?a.then(void 0,n):a}(0,function(r){if(function(r){return Array.isArray(null==r?void 0:r.errors)}(r))return {values:{},errors:resolvers.toNestErrors(n(r.errors,!u.shouldUseNativeValidation&&"all"===u.criteriaMode),u)};throw r}))}catch(r){return Promise.reject(r)}}};

var __rest$8 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const labelVariants = classVarianceAuthority.cva('text-sm font-medium peer-disabled:cursor-not-allowed peer-disabled:opacity-30');
const Label = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$8(_a, ["className"]);
    return (jsxRuntime.jsx(LabelPrimitive__namespace.Root, Object.assign({ ref: ref, className: cn(labelVariants(), className) }, props)));
});
Label.displayName = LabelPrimitive__namespace.Root.displayName;

var __rest$7 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const Form = reactHookForm.FormProvider;
const FormFieldContext = React__namespace.createContext({});
function FormField(_a) {
    var props = __rest$7(_a, []);
    return (jsxRuntime.jsx(FormFieldContext.Provider, { value: { name: props.name }, children: jsxRuntime.jsx(reactHookForm.Controller, Object.assign({}, props)) }));
}
const useFormField = () => {
    const fieldContext = React__namespace.useContext(FormFieldContext);
    const itemContext = React__namespace.useContext(FormItemContext);
    const { getFieldState, formState } = reactHookForm.useFormContext();
    const fieldState = getFieldState(fieldContext.name, formState);
    if (!fieldContext) {
        throw new Error('useFormField should be used within <FormField>');
    }
    const { id } = itemContext;
    return Object.assign({ id, name: fieldContext.name, formItemId: `${id}-form-item`, formDescriptionId: `${id}-form-item-description`, formMessageId: `${id}-form-item-message` }, fieldState);
};
const FormItemContext = React__namespace.createContext({});
const formLayoutVariants = classVarianceAuthority.cva('', {
    variants: {
        layout: {
            Vertical: 'space-y-1.5',
            Horizontal: 'flex flex-row items-center space-x-3'
        }
    },
    defaultVariants: {
        layout: 'Vertical'
    }
});
const FormItem = React__namespace.forwardRef((_a, ref) => {
    var { className, layout } = _a, props = __rest$7(_a, ["className", "layout"]);
    const id = React__namespace.useId();
    const cls = cn(className, formLayoutVariants({ layout }));
    return (jsxRuntime.jsx(FormItemContext.Provider, { value: { id }, children: jsxRuntime.jsx("div", Object.assign({ ref: ref, className: cls }, props)) }));
});
FormItem.displayName = 'FormItem';
const FormLabel = React__namespace.forwardRef((_a, ref) => {
    var { className, required, children } = _a, props = __rest$7(_a, ["className", "required", "children"]);
    const { formItemId } = useFormField();
    return (jsxRuntime.jsxs(Label, Object.assign({ ref: ref, className: className, htmlFor: formItemId }, props, { children: [required ? jsxRuntime.jsx("span", { className: "text-[#EC2F0D] mr-1", children: "*" }) : null, children] })));
});
FormLabel.displayName = 'FormLabel';
const FormControl = React__namespace.forwardRef((_a, ref) => {
    var props = __rest$7(_a, []);
    const { error, formItemId, formDescriptionId, formMessageId } = useFormField();
    return (jsxRuntime.jsx(reactSlot.Slot, Object.assign({ ref: ref, id: formItemId, "aria-describedby": !error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`, "aria-invalid": !!error }, props)));
});
FormControl.displayName = 'FormControl';
const FormDescription = React__namespace.forwardRef((_a, ref) => {
    var { className } = _a, props = __rest$7(_a, ["className"]);
    const { formDescriptionId } = useFormField();
    return jsxRuntime.jsx("p", Object.assign({ ref: ref, id: formDescriptionId, className: cn('text-sm text-subtler', className) }, props));
});
FormDescription.displayName = 'FormDescription';
const FormMessage = React__namespace.forwardRef((_a, ref) => {
    var { className, children } = _a, props = __rest$7(_a, ["className", "children"]);
    const { error, formMessageId } = useFormField();
    const body = error ? String(error === null || error === void 0 ? void 0 : error.message) : children;
    if (!body) {
        return null;
    }
    return (jsxRuntime.jsx("p", Object.assign({ ref: ref, id: formMessageId, className: cn('text-sm font-medium text-critical', className) }, props, { children: body })));
});
FormMessage.displayName = 'FormMessage';

var __rest$6 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const Textarea = React__namespace.forwardRef((_a, ref) => {
    var _b, _c;
    var { className, maxLength, value, error } = _a, props = __rest$6(_a, ["className", "maxLength", "value", "error"]);
    return (jsxRuntime.jsxs("div", { children: [jsxRuntime.jsxs("div", { className: "relative", children: [jsxRuntime.jsx("textarea", Object.assign({ className: cn('w-full min-h-[123px] p-3 pb-10 rounded-lg border border-default bg-surface-search-field ', 'shadow-background-default text-sm text-default ring-offset-surface-default  ', 'hover:border-hovered hover:bg-surface-subtle aria-[invalid=true]:border-critical aria-[invalid=true]:hover:border-surface-critical-hovered aria-[invalid=true]:hover:bg-surface-accent-red-subtlest ', 'aria-[invalid=true]:focus-visible:ring-error file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-subtler', 'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand focus-visible:ring-offset-1 disabled:cursor-not-allowed disabled:opacity-30', (maxLength && (((_b = value === null || value === void 0 ? void 0 : value.toString()) === null || _b === void 0 ? void 0 : _b.length) || 0) > maxLength) || error
                            ? 'border-critical hover:border-critical hover:bg-surface-accent-red-subtlest focus-visible:ring-error'
                            : '', className), ref: ref, maxLength: maxLength, value: value }, props)), maxLength ? (jsxRuntime.jsx("div", { className: "absolute text-right bottom-5 right-4 border-default", children: jsxRuntime.jsx(Text, { size: "sm", color: "subtlest", children: `${((_c = value === null || value === void 0 ? void 0 : value.toString()) === null || _c === void 0 ? void 0 : _c.length) || 0}/${maxLength}` }) })) : null] }), error && (jsxRuntime.jsx("div", { className: "w-full", children: jsxRuntime.jsx(Text, { className: "text-wrap", size: "sm", weight: "regular", color: "critical", children: error }) }))] }));
});
Textarea.displayName = 'Textarea';

const issueItems = [
    {
        label: 'boring',
        value: 'Boring'
    },
    {
        label: 'out_of_character',
        value: 'Out of Character'
    },
    {
        label: 'inaccurate',
        value: 'Inaccurate'
    },
    {
        label: 'incorrect_voice_generation',
        value: 'Incorrect Voice Generation'
    },
    {
        label: 'long_waiting_time',
        value: 'Long Waiting Time'
    },
    {
        label: 'offensive',
        value: 'Offensive'
    },
    {
        label: 'repetitive',
        value: 'Repetitive'
    },
    {
        label: 'incorrect_translation',
        value: 'Incorrect Translation'
    }
];
function FeedbackModal({ open, onClose, onRemoveDislike, onSendFeedback }) {
    const reportLocale = nextIntl.useTranslations('report');
    const commonLocale = nextIntl.useTranslations('common');
    const formSchema = zod.z.object({
        issues: zod.z.array(zod.z.string()),
        other: zod.z.string()
    });
    const form = reactHookForm.useForm({
        defaultValues: {
            issues: [],
            other: ''
        },
        resolver: t(formSchema)
    });
    const { watch } = form;
    const issues = watch('issues');
    const other = watch('other');
    const submitDisabled = React.useMemo(() => {
        return !(issues.length || other.length);
    }, [issues.length, other.length]);
    const onSubmit = async () => {
        onSendFeedback(issues, other);
        onClose();
    };
    return (jsxRuntime.jsxs(Modal, { contentClassName: "w-[620px]", open: open, onClose: onClose, children: [jsxRuntime.jsxs(ModalHeader, { className: "p-4 md:p-5", children: [jsxRuntime.jsx(Heading, { size: "h2", children: reportLocale('tell_us_more') }), jsxRuntime.jsx(Text, { color: "subtle", size: "sm", children: reportLocale('report_msg_tips') })] }), jsxRuntime.jsx(ModalBody, { className: "py-3 px-4 md:px-5", children: jsxRuntime.jsx(Form, Object.assign({}, form, { children: jsxRuntime.jsx("form", { className: "flex flex-col gap-3", children: jsxRuntime.jsxs("section", { className: "flex flex-col gap-3", children: [jsxRuntime.jsx(FormField, { control: form.control, name: "issues", render: ({ field }) => (jsxRuntime.jsx(FormItem, { children: jsxRuntime.jsx("div", { className: "flex flex-wrap gap-3", children: issueItems.map(issue => {
                                                const checked = field.value.includes(issue.value);
                                                return (jsxRuntime.jsxs("button", { type: "button", role: "checkbox", "aria-checked": checked, className: clsx__default.default('flex items-center justify-center gap-1 rounded-lg h-7 px-3 cursor-pointer', checked
                                                        ? 'bg-surface-primary-default text-white'
                                                        : 'bg-surface-accent-gray-subtlest text-default'), onClick: () => {
                                                        if (!checked) {
                                                            field.onChange([...field.value, issue.value]);
                                                        }
                                                        else {
                                                            field.onChange(field.value.filter(v => v !== issue.value));
                                                        }
                                                    }, children: [jsxRuntime.jsx(Text, { className: "text-sm text-inherit", children: reportLocale(issue.label) }), checked && jsxRuntime.jsx(ForwardRef$J, { className: "size-4 text-white" })] }, issue.value));
                                            }) }) })) }), jsxRuntime.jsx(Heading, { size: "h5", children: reportLocale('others_that_apply') }), jsxRuntime.jsx(FormField, { control: form.control, name: "other", render: ({ field }) => (jsxRuntime.jsx(FormItem, { children: jsxRuntime.jsx(FormControl, { children: jsxRuntime.jsx(Textarea, Object.assign({ placeholder: reportLocale('placeholder_tips'), autoFocus: false, className: "h-[138px] px-3 py-2 text-sm resize-none" }, field)) }) })) })] }) }) })) }), jsxRuntime.jsxs(ModalFooter, { className: "p-4 md:p-5 flex items-center gap-4", children: [jsxRuntime.jsx(Button$1, { variant: "outline", color: "default", onClick: onClose, children: commonLocale('cancel') }), jsxRuntime.jsx(Button$1, { variant: "primary", color: "brand", disabled: submitDisabled, onClick: onSubmit, children: reportLocale('send_feedback') })] })] }));
}

function useFeedback(type, messageId, updateFeedbackState, updateFeedbackIssues) {
    const { onSendActionSensors } = useActionSensors(messageId);
    const reportApi = () => {
        let api;
        switch (type) {
            default:
                api = messageReport;
                break;
        }
        return api;
    };
    const feedbackApi = () => {
        let api;
        switch (type) {
            default:
                api = messageFeedback;
                break;
        }
        return api;
    };
    const reportMessage = async (prevState, state) => {
        onSendActionSensors(state === FeedbackState.LIKED ? MenuActionType.Like : MenuActionType.Dislike);
        try {
            updateFeedbackState(state);
            const { success } = await reportApi()(state, messageId);
            if (success) {
                if (prevState === FeedbackState.DISLIKE && state === FeedbackState.NORMAL) {
                    updateFeedbackIssues([]);
                }
            }
            else {
                updateFeedbackState(prevState);
            }
        }
        catch (e) {
            updateFeedbackState(prevState);
            console.error(e);
        }
    };
    const sendMessageFeedback = async (issues, otherDetail) => {
        onSendActionSensors(MenuActionType.Feedback, {
            feedback_detail: issues
        });
        try {
            updateFeedbackIssues([...issues, otherDetail]);
            const { success } = await feedbackApi()('msg_feedback', messageId, issues, otherDetail);
            if (!success) {
                updateFeedbackIssues([]);
            }
        }
        catch (e) {
            updateFeedbackIssues([]);
            console.error(e);
        }
    };
    return {
        reportMessage,
        sendMessageFeedback
    };
}

const displayTxtMap = {
    Boring: 'boring',
    'Out of Character': 'out_of_character',
    Inaccurate: 'inaccurate',
    Offensive: 'offensive',
    Repetitive: 'repetitive',
    'Incorrect Voice Generation': 'incorrect_voice_generation',
    'Long Waiting Time': 'long_waiting_time',
    'Incorrect Translation': 'incorrect_translation',
    Others: 'others'
};
function NormalRender({ source, asMenuItem, onReport }) {
    const reportLocale = nextIntl.useTranslations('report');
    return source === 'menubar' ? (asMenuItem ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(DropdownMenuItem, { onClick: () => onReport(FeedbackState.LIKED), children: [jsxRuntime.jsx(ForwardRef$z, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: reportLocale('like') })] }), jsxRuntime.jsxs(DropdownMenuItem, { onClick: () => onReport(FeedbackState.DISLIKE), children: [jsxRuntime.jsx(ForwardRef$A, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: reportLocale('dislike') })] })] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(IconButton, { variant: "primary", size: "sm", color: "gray", className: "rounded-lg", hoverText: reportLocale('like'), onClick: () => onReport(FeedbackState.LIKED), icon: ForwardRef$z }), jsxRuntime.jsx(IconButton, { variant: "primary", size: "sm", color: "gray", className: "rounded-lg", hoverText: reportLocale('dislike'), onClick: () => onReport(FeedbackState.DISLIKE), icon: ForwardRef$A })] }))) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(ContextMenuItem, { onClick: () => onReport(FeedbackState.LIKED), children: [jsxRuntime.jsx(ForwardRef$z, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: reportLocale('like') })] }), jsxRuntime.jsxs(ContextMenuItem, { onClick: () => onReport(FeedbackState.DISLIKE), children: [jsxRuntime.jsx(ForwardRef$A, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: reportLocale('dislike') })] })] }));
}
function LikedRender({ source, asMenuItem, onReport }) {
    const reportLocale = nextIntl.useTranslations('report');
    return source === 'menubar' ? (asMenuItem ? (jsxRuntime.jsxs(DropdownMenuItem, { onClick: () => onReport(FeedbackState.NORMAL), children: [jsxRuntime.jsx(ForwardRef$5, { className: "size-5 text-brand" }), jsxRuntime.jsx(Text, { className: "ml-2", children: reportLocale('like') })] })) : (jsxRuntime.jsx(IconButton, { variant: "primary", size: "sm", color: "gray", className: "rounded-lg", hoverText: reportLocale('like'), onClick: () => onReport(FeedbackState.NORMAL), icon: ForwardRef$5 }))) : (jsxRuntime.jsxs(ContextMenuItem, { onClick: () => onReport(FeedbackState.NORMAL), children: [jsxRuntime.jsx(ForwardRef$5, { className: "size-5 text-brand" }), jsxRuntime.jsx(Text, { className: "ml-2", children: reportLocale('like') })] }));
}
function DislikeRender({ source, asMenuItem, onReport, feedbackIssues, sendFeedback }) {
    const chatLocale = nextIntl.useTranslations('chat');
    const reportLocale = nextIntl.useTranslations('report');
    const [modalOpen, setModalOpen] = reactUse.useToggle(false);
    const feedbackTxt = React.useMemo(() => {
        var _a, _b;
        return ((_b = (_a = (feedbackIssues !== null && feedbackIssues !== void 0 ? feedbackIssues : [])
            .filter(v => !!v)
            .map(e => (displayTxtMap[e] ? reportLocale(displayTxtMap[e]) : e))) === null || _a === void 0 ? void 0 : _a.join(', ')) !== null && _b !== void 0 ? _b : '');
    }, [feedbackIssues, reportLocale]);
    const handleClick = () => {
        if (feedbackIssues === null || feedbackIssues === void 0 ? void 0 : feedbackIssues.length) {
            onReport(FeedbackState.NORMAL);
        }
        else {
            setModalOpen(true);
        }
    };
    const onRemoveDislike = () => {
        onReport(FeedbackState.NORMAL);
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [source === 'menubar' ? (asMenuItem ? (jsxRuntime.jsxs(DropdownMenuItem, { onClick: handleClick, children: [jsxRuntime.jsx(ForwardRef$6, { className: "size-5 text-critical" }), jsxRuntime.jsx(Text, { color: "critical", className: "ml-2", children: feedbackTxt ? feedbackTxt.slice(0, 8) : chatLocale('feedback') })] })) : (jsxRuntime.jsx(Tooltip, { size: "md", description: reportLocale('dislike'), side: "top", align: "center", children: jsxRuntime.jsx(Button$1, { variant: "outline", size: "sm", color: "default", className: "rounded-lg text-critical", onClick: handleClick, icon: ForwardRef$6, iconClassName: "size-[18px] !text-icon-critical", children: feedbackTxt ? feedbackTxt.slice(0, 8) : chatLocale('feedback') }) }))) : (jsxRuntime.jsxs(ContextMenuItem, { onClick: handleClick, children: [jsxRuntime.jsx(ForwardRef$6, { className: "size-5 text-critical" }), jsxRuntime.jsx(Text, { color: "critical", className: "ml-2", children: feedbackTxt ? feedbackTxt.slice(0, 8) : chatLocale('feedback') })] })), jsxRuntime.jsx(FeedbackModal, { open: modalOpen, onClose: () => setModalOpen(false), onRemoveDislike: onRemoveDislike, onSendFeedback: sendFeedback })] }));
}
function MessageFeedback(props) {
    const { source, asMenuItem } = props;
    const { type } = React.useContext(StaticContext);
    const { partialUpdateMessage } = React.useContext(MessageContext);
    const { message } = useDisplayContext();
    const feedbackState = message === null || message === void 0 ? void 0 : message.feedbackState;
    const feedbackIssues = message === null || message === void 0 ? void 0 : message.feedbackIssues;
    const updateFeedbackState = (state) => {
        partialUpdateMessage === null || partialUpdateMessage === void 0 ? void 0 : partialUpdateMessage(message.id, {
            feedbackState: state
        });
    };
    const updateFeedbackIssues = (issues) => {
        partialUpdateMessage === null || partialUpdateMessage === void 0 ? void 0 : partialUpdateMessage(message.id, {
            feedbackIssues: issues
        });
    };
    const { reportMessage, sendMessageFeedback } = useFeedback(type, message.id, updateFeedbackState, updateFeedbackIssues);
    const handleReport = (state) => {
        reportMessage(feedbackState !== null && feedbackState !== void 0 ? feedbackState : FeedbackState.NORMAL, state);
    };
    const Comp = (message === null || message === void 0 ? void 0 : message.feedbackState) === FeedbackState.LIKED
        ? LikedRender
        : (message === null || message === void 0 ? void 0 : message.feedbackState) === FeedbackState.DISLIKE
            ? DislikeRender
            : NormalRender;
    return (jsxRuntime.jsx(Comp, { source: source, onReport: handleReport, feedbackIssues: feedbackIssues, sendFeedback: sendMessageFeedback, asMenuItem: asMenuItem }));
}

function MenuDivider({ source, asMenuItem }) {
    return source === 'contextmenu' ? jsxRuntime.jsx(ContextMenuSeparator, {}) : asMenuItem ? jsxRuntime.jsx(DropdownMenuSeparator, {}) : null;
}

function RegenerateMessage(props) {
    var _a, _b, _c, _d, _e, _f;
    const { message, replyOriginMessage } = useDisplayContext();
    const chatLocale = nextIntl.useTranslations('chat');
    const { regenerateMessage } = React.useContext(MessageContext);
    const { source, asMenuItem = false } = props;
    const onRegenerate = () => {
        regenerateMessage === null || regenerateMessage === void 0 ? void 0 : regenerateMessage(message, replyOriginMessage);
    };
    if (source === 'menubar') {
        if (asMenuItem) {
            return (jsxRuntime.jsxs(DropdownMenuItem, { onClick: onRegenerate, children: [jsxRuntime.jsx(ForwardRef$Q, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: chatLocale('Regenerate') }), !!((_a = message === null || message === void 0 ? void 0 : message.extraInfo) === null || _a === void 0 ? void 0 : _a.consumeEnergy) && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Separator, { orientation: "vertical", className: "h-3 bg-alpha-facetime-white mx-[6px]" }), jsxRuntime.jsxs("div", { className: "flex gap-[2px] items-center", children: [jsxRuntime.jsx(Image__default.default, { alt: "energy cost", src: "https://www.myshellstatic.com/image/chat/embed_obj/172/202405210853/icon-wrapper-16px@2x.png.png", width: 16, height: 16, className: "size-4 rounded-[4px]" }), jsxRuntime.jsx(Text, { size: "xs", className: "text-inherit", children: (_b = message === null || message === void 0 ? void 0 : message.extraInfo) === null || _b === void 0 ? void 0 : _b.consumeEnergy })] })] }))] }));
        }
        return (jsxRuntime.jsx(Tooltip, { size: "md", description: chatLocale('Regenerate'), side: "top", align: "center", children: ((_c = message === null || message === void 0 ? void 0 : message.extraInfo) === null || _c === void 0 ? void 0 : _c.consumeEnergy) ? (jsxRuntime.jsxs(Button$1, { variant: "primary", size: "sm", color: "gray", className: "rounded-lg px-3 text-default", onClick: onRegenerate, children: [jsxRuntime.jsx(ForwardRef$Q, { className: "size-[18px] !text-default" }), jsxRuntime.jsx(Separator, { orientation: "vertical", className: "h-3 bg-alpha-facetime-white mx-[6px]" }), jsxRuntime.jsxs("div", { className: "flex gap-[2px] items-center", children: [jsxRuntime.jsx(Image__default.default, { alt: "energy cost", src: "https://www.myshellstatic.com/image/chat/embed_obj/172/202405210853/icon-wrapper-16px@2x.png.png", width: 16, height: 16, className: "size-4 rounded-[4px]" }), jsxRuntime.jsx(Text, { size: "xs", className: "text-inherit", children: (_d = message === null || message === void 0 ? void 0 : message.extraInfo) === null || _d === void 0 ? void 0 : _d.consumeEnergy })] })] })) : (jsxRuntime.jsx(IconButton, { variant: "primary", size: "sm", color: "gray", className: "rounded-lg", onClick: onRegenerate, children: jsxRuntime.jsx(ForwardRef$Q, { className: "size-[18px] !text-default" }) })) }));
    }
    return (jsxRuntime.jsxs(ContextMenuItem, { onClick: onRegenerate, children: [jsxRuntime.jsx(ForwardRef$Q, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: chatLocale('Regenerate') }), !!((_e = message === null || message === void 0 ? void 0 : message.extraInfo) === null || _e === void 0 ? void 0 : _e.consumeEnergy) && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Separator, { orientation: "vertical", className: "h-3 bg-alpha-facetime-white mx-[6px]" }), jsxRuntime.jsxs("div", { className: "flex gap-[2px] items-center", children: [jsxRuntime.jsx(Image__default.default, { alt: "energy cost", src: "https://www.myshellstatic.com/image/chat/embed_obj/172/202405210853/icon-wrapper-16px@2x.png.png", width: 16, height: 16, className: "size-4 rounded-[4px]" }), jsxRuntime.jsx(Text, { size: "xs", className: "text-inherit", children: (_f = message === null || message === void 0 ? void 0 : message.extraInfo) === null || _f === void 0 ? void 0 : _f.consumeEnergy })] })] }))] }));
}

var __rest$5 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const SelectTextIcon = (props) => {
    const rest = __rest$5(props, ["fillColor"]);
    return (jsxRuntime.jsxs(react.Icon, Object.assign({ viewBox: "0 0 20 20", fill: "none" }, rest, { children: [jsxRuntime.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.8251 2.20003V13.6C4.8251 13.9176 5.08254 14.175 5.4001 14.175H15.0001V15.425H5.4001C4.39218 15.425 3.5751 14.608 3.5751 13.6V2.20003H4.8251Z", fill: "currentColor" }), jsxRuntime.jsx("path", { d: "M5.5 2.25C5.5 2.94036 4.94036 3.5 4.25 3.5C3.55964 3.5 3 2.94036 3 2.25C3 1.55964 3.55964 1 4.25 1C4.94036 1 5.5 1.55964 5.5 2.25Z", fill: "currentColor" }), jsxRuntime.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M14.3751 17.8001V6.40013C14.3751 6.08257 14.1177 5.82513 13.8001 5.82513H4.2001V4.57513H13.8001C14.808 4.57513 15.6251 5.39221 15.6251 6.40013V17.8001H14.3751Z", fill: "currentColor" }), jsxRuntime.jsx("path", { d: "M13.7001 17.7501C13.7001 17.0597 14.2597 16.5001 14.9501 16.5001C15.6405 16.5001 16.2001 17.0597 16.2001 17.7501C16.2001 18.4404 15.6405 19.0001 14.9501 19.0001C14.2597 19.0001 13.7001 18.4404 13.7001 17.7501Z", fill: "currentColor" })] })));
};

function SelectText(props) {
    const isMobile = useGlobalStore(state => state.isMobile);
    const { source, asMenuItem = false } = props;
    const commonT = nextIntl.useTranslations('common');
    const { setSelectTextVisible } = useDisplayContext();
    const showModal = () => {
        setSelectTextVisible === null || setSelectTextVisible === void 0 ? void 0 : setSelectTextVisible(true);
    };
    if (!isMobile)
        return null;
    if (source === 'menubar') {
        if (asMenuItem) {
            return (jsxRuntime.jsxs(DropdownMenuItem, { onClick: showModal, children: [jsxRuntime.jsx(SelectTextIcon, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2", children: commonT('select_text') })] }));
        }
        return (jsxRuntime.jsx(Tooltip, { description: commonT('select_text'), side: "top", align: "center", children: jsxRuntime.jsx(IconButton, { variant: "primary", size: "sm", color: "gray", className: "rounded-lg", onClick: showModal, children: jsxRuntime.jsx(SelectTextIcon, { className: "size-5" }) }) }));
    }
    return (jsxRuntime.jsxs(ContextMenuItem, { onClick: showModal, children: [jsxRuntime.jsx(SelectTextIcon, { className: "size-5" }), jsxRuntime.jsx(Text, { className: "ml-2 text-default", children: commonT('select_text') })] }));
}

function Actions({ specifiedActions, source, asMenuItem }) {
    const { actions } = useDisplayContext();
    const actualActions = specifiedActions || actions;
    const Component = React.useCallback(({ action_type }) => {
        switch (action_type) {
            case MenuActionType.Copy_Message:
                return jsxRuntime.jsx(CopyMessage, { source: source, asMenuItem: asMenuItem });
            case MenuActionType.Delete:
                return jsxRuntime.jsx(DeleteMessage, { source: source, asMenuItem: asMenuItem });
            case MenuActionType.Download_Voice:
                return jsxRuntime.jsx(DownloadVoice, { source: source, asMenuItem: asMenuItem });
            case MenuActionType.Edit:
                return jsxRuntime.jsx(EditMessage, { source: source, asMenuItem: asMenuItem });
            case MenuActionType.Regenerate:
                return jsxRuntime.jsx(RegenerateMessage, { source: source, asMenuItem: asMenuItem });
            case MenuActionType.Feedback:
                return jsxRuntime.jsx(MessageFeedback, { source: source, asMenuItem: asMenuItem });
            case MenuActionType.Show_Text:
                return jsxRuntime.jsx(TextException, { source: source, asMenuItem: asMenuItem });
            case MenuActionType.Translate:
                return jsxRuntime.jsx(Translation, { source: source, asMenuItem: asMenuItem });
            case MenuActionType.Share:
                return jsxRuntime.jsx(Share, { source: source, asMenuItem: asMenuItem });
            case MenuActionType.Select_Text:
                return jsxRuntime.jsx(SelectText, { source: source, asMenuItem: asMenuItem });
            case MenuActionType.Divider:
                return jsxRuntime.jsx(MenuDivider, { source: source, asMenuItem: asMenuItem });
            default:
                console.error(`${action_type}类型的组件不存在`);
        }
    }, [asMenuItem, source]);
    return actualActions.map((action_type, index) => (jsxRuntime.jsx(Component, { action_type: action_type }, `${action_type}-${index}`)));
}

function MessageMenuItems() {
    return jsxRuntime.jsx(Actions, { source: "contextmenu" });
}

const ContextMenuProvider = ({ children, source }) => {
    const boundaryEle = isClient() ? document.getElementById('renderer-container') : null;
    const { actions, contextMenuDisabled } = useDisplayContext();
    const [previewImage, setPreviewImage] = React.useState();
    const [viewModalVisible, setViewModalVisible] = React.useState(false);
    const [isImage, setIsImage] = React.useState(false);
    const [xImage, setXImage] = React.useState();
    useGlobalStore(state => state.isMobile);
    const { isIos } = useDevice();
    const onContextMenu = (event) => {
        var _a, _b, _c, _d, _e;
        const isImage = ((_b = (_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.tagName) === null || _b === void 0 ? void 0 : _b.toUpperCase()) === 'IMG';
        setIsImage(isImage);
        if (isImage) {
            const imageSource = (_c = event === null || event === void 0 ? void 0 : event.target) === null || _c === void 0 ? void 0 : _c.getAttribute('x-image-source');
            const imageData = Object.assign(Object.assign({ url: (_d = event === null || event === void 0 ? void 0 : event.target) === null || _d === void 0 ? void 0 : _d.getAttribute('src') }, (_e = event === null || event === void 0 ? void 0 : event.target) === null || _e === void 0 ? void 0 : _e.getAttribute('x-image-data')), { naturalHeight: event.target.naturalHeight, naturalWidth: event.target.naturalWidth, source: imageSource || 'markdown' });
            setXImage(imageData);
        }
        if (lodashEs.isEmpty(actions) && !isImage) {
            event.preventDefault();
        }
    };
    const onDomClick = (event) => {
        var _a, _b, _c, _d, _e;
        if (((_b = (_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.tagName) === null || _b === void 0 ? void 0 : _b.toUpperCase()) === 'IMG' && ((_c = event === null || event === void 0 ? void 0 : event.target) === null || _c === void 0 ? void 0 : _c.getAttribute('x-intercept-click')) === '1') {
            setPreviewImage({
                url: (_d = event === null || event === void 0 ? void 0 : event.target) === null || _d === void 0 ? void 0 : _d.getAttribute('src'),
                title: (_e = event === null || event === void 0 ? void 0 : event.target) === null || _e === void 0 ? void 0 : _e.getAttribute('alt'),
                type: EmbedObjType.IMAGE,
                status: EmbedObjStatus.DONE,
                extensionName: '',
                iconUrl: ''
            });
            setViewModalVisible(true);
        }
    };
    const [touchStartTime, setTouchStartTime] = React.useState(0);
    const [touchTimer, setTouchTimer] = React.useState(null);
    const handleLongPress = (event) => {
        const { target } = event;
        if (Date.now() - touchStartTime >= 500) {
            event.preventDefault();
            onContextMenu({ target });
        }
    };
    const handleTouchStart = (event) => {
        setTouchStartTime(Date.now());
        const timer = setTimeout(() => {
            handleLongPress(event);
        }, 500);
        setTouchTimer(timer);
    };
    const handleTouchEnd = () => {
        if (touchTimer) {
            clearTimeout(touchTimer);
        }
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(ContextMenu, { children: [jsxRuntime.jsx(ContextMenuTrigger, Object.assign({ disabled: contextMenuDisabled, className: "select-none md:select-auto" }, (isIos
                        ? {
                            onTouchStart: handleTouchStart,
                            onTouchEnd: handleTouchEnd,
                            onClick: onDomClick
                        }
                        : {
                            onContextMenu,
                            onClick: onDomClick
                        }), { children: children })), jsxRuntime.jsx(ContextMenuContent, { collisionBoundary: [boundaryEle], children: isImage ? (jsxRuntime.jsx(ImageMenuItem, { url: xImage.url, imageModel: xImage === null || xImage === void 0 ? void 0 : xImage.imageModel, naturalHeight: xImage.naturalHeight, naturalWidth: xImage.naturalWidth, imageSource: xImage.source, source: source })) : (jsxRuntime.jsx(MessageMenuItems, {})) })] }), jsxRuntime.jsx(ImgVideoPreview$2, { open: viewModalVisible, onClose: () => {
                    setViewModalVisible(false);
                }, imgVideoList: previewImage ? [previewImage] : [], activeIndex: 0 })] }));
};

function divideToFraction(dividend, divisor) {
    function gcd(a, b) {
        if (b === 0) {
            return a;
        }
        return gcd(b, a % b);
    }
    const commonDivisor = gcd(dividend, divisor);
    const numerator = dividend / commonDivisor;
    const denominator = divisor / commonDivisor;
    return {
        numerator,
        denominator,
        text: `${numerator}/${denominator}`
    };
}

const LUIButtonInteractionContext$1 = React.createContext({
    clickFn: async () => { },
    msgId: ''
});

const COOKIE_LOCALE_NAME = 'NEXT_LOCALE';

const setLocaleCookie = (locale) => {
    document.cookie = `${COOKIE_LOCALE_NAME}=${locale}; max-age=31536000; path=/`;
};

function useUserSettings() {
    const currentLanguage = useUserStore(state => state.language);
    const setLanguage = useUserStore(state => state.setLanguage);
    const userSettingsInfo = useUserStore(state => state.userSettingsInfo);
    const setUserSettingsInfo = useUserStore(state => state.setUserSettingsInfo);
    const setShowNsfw = useUserStore(state => state.setShowNsfw);
    const isLogin = useUserStore(state => state.isLogin);
    const { locale } = usePathLocale();
    const router = navigation.useRouter();
    const languageMap = {
        en: 'en',
        zh: 'zh',
        'zh-CN': 'zh',
        'zh-TW': 'zh-tw',
        ja: 'jp',
        es: 'es',
        ru: 'ru',
        ko: 'ko'
    };
    const handleGetUserSettings = React.useCallback(async (needRedirect = true, callback) => {
        const res = await getUserSettings();
        if (res.success) {
            const { data } = res;
            setUserSettingsInfo(res.data);
            if (data.length > 0 && data.some(item => item.name === UserSettingEnum.SHOW_NSFW)) {
                const showNsfw = data.filter(item => item.name === UserSettingEnum.SHOW_NSFW)[0].value;
                setShowNsfw(showNsfw === '1' ? NsfwEnum.OPEN : NsfwEnum.CLOSE);
            }
            else {
                setShowNsfw(NsfwEnum.CLOSE);
            }
            const navigatorLang = ((navigator.language || '').split('-')[0] || '').toLowerCase();
            let language = locale || languageMap[navigatorLang] || '';
            const { lang } = document.documentElement;
            if (!language || !ALL_LANG_KEYS.includes(language)) {
                language = 'en';
            }
            let userLanguage = '';
            if (data.length > 0 && data.some(item => item.name === UserSettingEnum.LANGUAGE)) {
                userLanguage = data.filter(item => item.name === UserSettingEnum.LANGUAGE)[0].value;
            }
            if (needRedirect && userLanguage && language !== userLanguage) {
                language = userLanguage;
                setLocaleCookie(userLanguage);
                if (needRedirect) {
                    router.refresh();
                }
            }
            else if (needRedirect && language !== lang) {
                router.refresh();
            }
            setLanguage(language);
            callback && callback();
        }
    }, [setUserSettingsInfo, isLogin]);
    const handleUpdateLanguage = React.useCallback(async (value) => {
        await rxjs.lastValueFrom(updateLanguage(value));
        handleGetUserSettings();
    }, [handleGetUserSettings]);
    const handleUpdateUserSettings = React.useCallback(async (setting, reFetchUser, callback) => {
        const res = await updateUserSettings(setting);
        if (res.success) {
            if (reFetchUser) {
                handleGetUserSettings(true, callback);
            }
            else {
                callback && callback();
            }
        }
    }, [updateUserSettings]);
    const handleUpdateRewardsCenterVisited = React.useCallback((seasonName, callback) => {
        handleUpdateUserSettings([
            {
                name: UserSettingEnum.FLAG_ICON_REWARD,
                value: '1'
            },
            {
                name: UserSettingEnum.LAST_SEASON,
                value: seasonName
            }
        ], true, callback);
    }, [handleGetUserSettings]);
    const handleUpdateForumCenterVisited = React.useCallback((seasonName, callback) => {
        handleUpdateUserSettings([
            {
                name: UserSettingEnum.FLAG_ICON_FORUM,
                value: '1'
            },
            {
                name: UserSettingEnum.LAST_SEASON,
                value: seasonName
            }
        ], true, callback);
    }, [handleGetUserSettings]);
    const handleUpdateFirstPublishGallery = React.useCallback((callback) => {
        handleUpdateUserSettings([
            {
                name: UserSettingEnum.FLAG_USET_FIRST_PUBLISH_GALLERY,
                value: '1'
            }
        ], true, callback);
    }, [handleGetUserSettings]);
    const handleUpdateFirstVisitGallery = React.useCallback((callback) => {
        handleUpdateUserSettings([
            {
                name: UserSettingEnum.FLAG_USET_FIRST_VISIT_GALLERY,
                value: '1'
            }
        ], true, callback);
    }, [handleGetUserSettings]);
    const handleUpdateFlagTagNoticeVisited = React.useCallback((seasonName, callback) => {
        handleUpdateUserSettings([
            {
                name: UserSettingEnum.FLAG_TAG_NOTICE,
                value: '1'
            }
        ], true, callback);
    }, [handleGetUserSettings]);
    const handleModelConfigClicked = React.useCallback(() => {
        handleUpdateUserSettings({
            name: UserSettingEnum.FLAG_LLM_MODEL_CONFIG,
            value: '1'
        }, true);
    }, [handleGetUserSettings]);
    const handleShowNsfw = React.useCallback((show, callback) => {
        handleUpdateUserSettings({
            name: UserSettingEnum.SHOW_NSFW,
            value: show ? '1' : '0'
        }, false, () => {
            setShowNsfw(show ? NsfwEnum.OPEN : NsfwEnum.CLOSE);
            callback === null || callback === void 0 ? void 0 : callback();
        });
    }, []);
    const handleNsfwConfirmed = React.useCallback((callback) => {
        handleUpdateUserSettings({
            name: UserSettingEnum.FLAG_NSFW_CONFIRMED,
            value: '1'
        }, true, callback);
    }, [handleGetUserSettings]);
    const handleBlockChainGuruTaskOnceCompleted = React.useCallback((callback) => {
        handleUpdateUserSettings({
            name: UserSettingEnum.FLAG_COMPLETED_OPBNB_CHAIN_TASK,
            value: '1'
        }, true, callback);
    }, [handleGetUserSettings]);
    const handleSilentPeriodConfirmed = React.useCallback((seasonName) => {
        handleUpdateUserSettings({
            name: UserSettingEnum.FLAG_SILENT_PERIOD_CONFIRMED,
            value: seasonName
        }, true);
    }, [handleGetUserSettings]);
    const handleDeductionConfirmed = React.useCallback((seasonName) => {
        handleUpdateUserSettings({
            name: UserSettingEnum.DEDUCTION_CONFIRMED,
            value: seasonName
        }, true);
    }, [handleGetUserSettings]);
    const handleSubscribingEarnViewed = React.useCallback((callback) => {
        handleUpdateUserSettings({
            name: UserSettingEnum.FLAG_stake_earn_VIEWED,
            value: '1'
        }, true, callback);
    }, [handleGetUserSettings]);
    const handleShareKeyEarnPopupConfirmed = React.useCallback((timeStamp) => {
        handleUpdateUserSettings({
            name: UserSettingEnum.FLAG_SHARE_KEY_EARN_POPUP_CONFIRMED,
            value: timeStamp
        }, true);
    }, [handleGetUserSettings]);
    const handleTimezoneChange = React.useCallback((timezone) => {
        handleUpdateUserSettings({
            name: UserSettingEnum.TIME_ZONE,
            value: timezone
        }, true);
    }, [handleUpdateUserSettings]);
    const handleReceiveNotification = React.useCallback(async (open, callback) => {
        await handleUpdateUserSettings({
            name: UserSettingEnum.NOTIFICATION,
            value: open ? '1' : '0'
        }, true, callback);
    }, [handleUpdateUserSettings]);
    return {
        userSettingsInfo,
        handleGetUserSettings,
        handleUpdateLanguage,
        currentLanguage,
        handleUpdateRewardsCenterVisited,
        handleUpdateForumCenterVisited,
        handleUpdateFirstPublishGallery,
        handleUpdateFirstVisitGallery,
        handleUpdateFlagTagNoticeVisited,
        handleModelConfigClicked,
        handleShowNsfw,
        handleNsfwConfirmed,
        handleBlockChainGuruTaskOnceCompleted,
        handleSilentPeriodConfirmed,
        handleDeductionConfirmed,
        handleSubscribingEarnViewed,
        handleShareKeyEarnPopupConfirmed,
        handleTimezoneChange,
        handleReceiveNotification
    };
}

function usePublishGallery() {
    const multiPublishMap = useChatStore(state => state.multiPublishMap);
    const clearMultiPublishMap = useChatStore(state => state.clearMultiPublishMap);
    const setHasUnRead = useChatStore(state => state.setHasUnRead);
    const t = nextIntl.useTranslations();
    const [publishing, setPublishing] = React.useState(false);
    const { success, warning, error } = useNotification();
    const { handleUpdateFirstPublishGallery } = useUserSettings();
    const { getEnergyInfo } = useGetEnergyInfo();
    const { selectedBot } = React.useContext(LUIButtonInteractionContext$1);
    const sensors = useSensors();
    const flagUserFirstPublishGallery = useUserStore(state => state.flagUserFirstPublishGallery);
    const checkGalleryUpdateHandle = async (botId) => {
        var _a, _b, _c;
        const res = await checkGalleryUpdate(botId);
        if (res.success) {
            setHasUnRead(((_c = (_b = (_a = res.data) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.hasUpdate) || false);
        }
    };
    const publishGalleryApi = async (list, successCb) => {
        try {
            setPublishing(true);
            const res = await publishGallery(list);
            if (res.success) {
                if (!flagUserFirstPublishGallery) {
                    success({
                        content: t('chat.suc_send')
                    });
                    handleUpdateFirstPublishGallery();
                }
                clearMultiPublishMap();
                const timer = setTimeout(() => {
                    (list === null || list === void 0 ? void 0 : list[0].botId) && checkGalleryUpdateHandle(list[0].botId);
                    getEnergyInfo();
                    clearTimeout(timer);
                }, 3000);
                successCb === null || successCb === void 0 ? void 0 : successCb();
            }
            else {
                error({
                    content: (res.reason === 'ERROR_REASON_BAD_REQUEST_ERROR' && res.msg) || t('chat.faild_send')
                });
            }
            sensors.track('PublishGallery', {
                bot_id: list[0].botId,
                bot_name: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.name,
                picture_number: list.length,
                result: res.success
            });
        }
        catch (e) {
            error({
                content: t('chat.faild_send')
            });
        }
        finally {
            setPublishing(false);
        }
    };
    const publishGalleryList = async (successCb, list) => {
        const publishList = Object.keys(multiPublishMap).map(item => multiPublishMap[item]);
        publishGalleryApi(list || publishList, successCb);
    };
    return {
        publishing,
        publishGalleryList,
        checkGalleryUpdateHandle
    };
}

function RightClickPublishTip({ position, className }) {
    const t = nextIntl.useTranslations();
    const isMobile = useGlobalStore(state => state.isMobile);
    return (jsxRuntime.jsxs("div", { className: cn('absolute left-4 bottom-1 z-10 w-[150px] md:w-[220px] h-fit flex border-opaque rounded-lg bg-utility-sky-blue-500 py-2 pl-3 pr-5 text-wrap text-left', className), style: Object.assign({}, (position && {
            left: position.x,
            top: position.y
        })), children: [jsxRuntime.jsx(Description$1, { size: "lg", weight: "medium", color: "static", children: isMobile ? t('chat.mob_publish_to_gallery') : t('chat.right_publish_to_gallery') }), jsxRuntime.jsx("span", { className: "absolute left-0 top-3 origin-center", style: {
                    transformOrigin: '0px 0px',
                    transform: 'translateY(50%) rotate(90deg) translateX(-50%)'
                }, children: jsxRuntime.jsx("svg", { className: "fill-utility-sky-blue-500 block", width: "10", height: "5", viewBox: "0 0 30 10", preserveAspectRatio: "none", children: jsxRuntime.jsx("polygon", { points: "0,0 30,0 15,10" }) }) })] }));
}

function FailIcon({ className }) {
    return (jsxRuntime.jsx("svg", { className: className, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: jsxRuntime.jsx("g", { id: "Icon/44/fail", children: jsxRuntime.jsxs("g", { id: "Vector", children: [jsxRuntime.jsx("path", { d: "M13.0372 12.2075C13.0372 11.7648 12.9059 11.332 12.66 10.9639C12.414 10.5958 12.0644 10.3089 11.6554 10.1395C11.2464 9.97007 10.7963 9.92574 10.3621 10.0121C9.92794 10.0985 9.52909 10.3117 9.21605 10.6247C8.903 10.9378 8.68982 11.3366 8.60345 11.7708C8.51708 12.205 8.56141 12.6551 8.73083 13.0641C8.90024 13.4731 9.18714 13.8227 9.55525 14.0687C9.92335 14.3147 10.3561 14.4459 10.7988 14.4459C11.3925 14.4459 11.9618 14.2101 12.3816 13.7903C12.8014 13.3705 13.0372 12.8012 13.0372 12.2075Z", fill: "#C9CCD0" }), jsxRuntime.jsx("path", { d: "M12.9854 19.5906C12.2801 18.5247 10.74 18.4578 9.94495 19.4584L5.62815 24.8919V6.98455H14.9058C15.8034 6.98455 16.4979 6.19785 16.3866 5.30718C16.2932 4.56041 15.6584 4 14.9058 4H6.42672C4.34974 4 2.66602 5.68372 2.66602 7.7607V24.1157C2.66602 26.1927 4.34974 27.8764 6.42672 27.8764H16.9208L14.5183 21.9073L12.9854 19.5906ZM20.8774 4C19.9805 4 19.2863 4.78547 19.3964 5.67554C19.4889 6.42313 20.1241 6.98455 20.8774 6.98455H26.3705V21.9073L22.4818 17.01C21.5852 15.8809 19.8038 16.1394 19.2651 17.4768L17.4804 21.9073L19.8829 27.8764H25.572C27.649 27.8764 29.3327 26.1927 29.3327 24.1157V7.76071C29.3327 5.68373 27.649 4 25.572 4H20.8774Z", fill: "#C9CCD0" })] }) }) }));
}

var __rest$4 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const Image$1 = (_a) => {
    var { src, alt, placeholder, errorMessage = 'Failed', className = '', style, aspectRatio, status, index, imageLoadCallback } = _a, props = __rest$4(_a, ["src", "alt", "placeholder", "errorMessage", "className", "style", "aspectRatio", "status", "index", "imageLoadCallback"]);
    const [loading, setLoading] = React.useState(true);
    const [error, setError] = React.useState(false);
    const { resolvedTheme } = nextThemes.useTheme();
    const handleImageLoad = () => {
        setLoading(false);
        imageLoadCallback === null || imageLoadCallback === void 0 ? void 0 : imageLoadCallback();
    };
    const handleImageError = () => {
        setLoading(false);
        setError(true);
    };
    const chat = nextIntl.useTranslations('chat');
    const isError = status === 'ERROR' || error || (status === 'DONE' && !src);
    return (jsxRuntime.jsxs("div", { className: clsx__default.default('w-full h-full relative bg-surface-container-default overflow-hidden', className), children: [loading && !isError && (jsxRuntime.jsxs("div", { className: "inset-0 flex items-center justify-center text-white bg-surface-container-default dark:bg-[#202126]", children: [jsxRuntime.jsx("img", { src: `/images/${resolvedTheme}.gif`, className: "w-full h-full object-contain", style: style }), status === 'PROCESSING' && String(aspectRatio) !== '5/1' && (jsxRuntime.jsx("div", { className: "text-subtle text-sm absolute z-2 bottom-[22%]", children: chat('generating') }))] })), !isError && !!src && (jsxRuntime.jsx("img", Object.assign({ src: src, alt: alt, onLoad: handleImageLoad, onError: handleImageError, className: `w-full h-full transition-opacity duration-300 ${loading ? 'opacity-60' : 'opacity-100'}` }, props))), isError && (jsxRuntime.jsx("div", { className: "absolute inset-0 flex items-center justify-center text-white ", children: jsxRuntime.jsx(Icon, { component: FailIcon, className: "bg-[#C9CCD0] w-8 h-8" }) }))] }));
};

const left = jsxRuntime.jsx("polyline", { points: "15 18 9 12 15 6" });
const right = jsxRuntime.jsx("polyline", { points: "9 18 15 12 9 6" });
const maximize = (jsxRuntime.jsx("path", { d: "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3" }));
const minimize = (jsxRuntime.jsx("path", { d: "M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3" }));
const play = jsxRuntime.jsx("polygon", { points: "5 3 19 12 5 21 5 3" });
const pause = (jsxRuntime.jsxs(React__namespace.default.Fragment, { children: [jsxRuntime.jsx("rect", { x: "6", y: "4", width: "4", height: "16" }), jsxRuntime.jsx("rect", { x: "14", y: "4", width: "4", height: "16" })] }));
const iconMapper = {
    left,
    right,
    maximize,
    minimize,
    play,
    pause
};
const defaultProps$3 = {
    strokeWidth: 1,
    viewBox: '0 0 24 24'
};
const SVG = (props) => {
    const { strokeWidth, viewBox, icon } = Object.assign(Object.assign({}, defaultProps$3), props);
    return (jsxRuntime.jsx("svg", { className: "image-gallery-svg w-[16px] h-[16px] md:w-[28px] md:h-[28px] focus:outline-none", xmlns: "http://www.w3.org/2000/svg", viewBox: viewBox, fill: "none", stroke: "currentColor", strokeWidth: strokeWidth, strokeLinecap: "round", strokeLinejoin: "round", children: iconMapper[icon] }));
};

const Fullscreen = React__namespace.default.memo(({ isFullscreen, onClick }) => {
    return (jsxRuntime.jsx("button", { type: "button", className: "appearance-none absolute right-0 bottom-0 p-5 text-white bg-transparent border-0 cursor-pointer z-[4] drop-shadow-md", onClick: onClick, "aria-label": "Open Fullscreen", children: jsxRuntime.jsx(SVG, { strokeWidth: 2, icon: isFullscreen ? 'minimize' : 'maximize' }) }));
});

const defaultProps$2 = {
    fullscreen: '',
    isFullscreen: false,
    originalAlt: '',
    originalHeight: '',
    originalWidth: '',
    sizes: '',
    srcSet: '',
    loading: 'eager',
    original: '',
    handleImageLoaded: () => { }
};
const Item = React__namespace.default.memo((props) => {
    const { fullscreen, handleImageLoaded, isFullscreen, onImageError, original, originalAlt, originalHeight, originalWidth, sizes, srcSet, loading } = Object.assign(Object.assign({}, defaultProps$2), props);
    const itemSrc = isFullscreen ? fullscreen || original : original;
    const h = originalHeight ? `${originalHeight}px` : 'auto';
    const w = originalWidth ? `${originalWidth}px` : 'auto';
    const maxW = originalWidth ? `max-w-[${originalWidth}px]` : 'max-w-full';
    return (jsxRuntime.jsx("img", { "data-source": "gallery", className: clsx__default.default('image-gallery-image w-full object-contain h-full max-h-[calc(100vh-180px)]', maxW), src: itemSrc, alt: originalAlt, srcSet: srcSet, height: h, width: w, sizes: sizes, onLoad: event => handleImageLoaded(event, original), onError: onImageError, loading: loading }));
});

const defaultProps$1 = {
    className: '',
    delta: 0,
    onSwiping: () => { },
    onSwiped: () => { }
};
const SwipeWrapper = (props) => {
    const { children, className, delta, onSwiping, onSwiped } = Object.assign(Object.assign({}, defaultProps$1), props);
    const swipeHandlers = reactSwipeable.useSwipeable({
        delta,
        onSwiping,
        onSwiped
    });
    return (jsxRuntime.jsx("div", Object.assign({}, swipeHandlers, { className: className, children: children })));
};

var __rest$3 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const screenChangeEvents = ['fullscreenchange', 'MSFullscreenChange', 'mozfullscreenchange', 'webkitfullscreenchange'];
const defaultProps = {
    onErrorImageURL: '',
    additionalClass: '',
    showNav: true,
    lazyLoad: false,
    infinite: true,
    showIndex: false,
    showBullets: false,
    bulltetPosition: 'inside',
    slideWrapperClass: '',
    showThumbnails: false,
    showFullscreenButton: false,
    disableThumbnailScroll: false,
    disableKeyDown: false,
    disableSwipe: false,
    disableThumbnailSwipe: false,
    useTranslate3D: true,
    useBrowserFullscreen: true,
    flickThreshold: 0.4,
    stopPropagation: false,
    indexSeparator: ' / ',
    startIndex: 0,
    slideDuration: 450,
    swipingTransitionDuration: 0,
    swipingThumbnailTransitionDuration: 0,
    onSlide: null,
    onBeforeSlide: null,
    onScreenChange: null,
    onPause: null,
    onPlay: null,
    onClick: () => { },
    onImageLoad: () => { },
    onImageError: () => { },
    onTouchMove: () => { },
    onTouchEnd: () => { },
    onTouchStart: () => { },
    onMouseOver: () => { },
    onMouseLeave: () => { },
    onBulletClick: () => { },
    onThumbnailError: () => { },
    onThumbnailClick: () => { },
    onContainerClick: () => { },
    renderCustomControls: null,
    renderThumbInner: null,
    renderItem: null,
    slideInterval: 3000,
    slideOnThumbnailOver: false,
    swipeThreshold: 30,
    renderLeftNav: (onClick, disabled) => (jsxRuntime.jsx("div", { className: clsx__default.default('hidden w-6 h-6 rounded-full bg-white absolute left-1 z-10 top-1/2  -translate-y-1/2  justify-center items-center', { hidden: disabled, 'group-hover:flex': !disabled }), children: jsxRuntime.jsx(ForwardRef$I, { onClick: onClick, className: "w-4 h-4 text-black cursor-pointer" }) })),
    renderRightNav: (onClick, disabled) => (jsxRuntime.jsx("div", { className: clsx__default.default('hidden w-6 h-6 rounded-full bg-white absolute right-1 z-10 top-1/2 -translate-y-1/2 justify-center items-center', { hidden: disabled, 'group-hover:flex': !disabled }), children: jsxRuntime.jsx(ForwardRef$H, { onClick: onClick, className: "w-4 h-4 text-black  cursor-pointer" }) })),
    renderFullscreenButton: (onClick, isFullscreen) => (jsxRuntime.jsx(Fullscreen, { onClick: onClick, isFullscreen: isFullscreen })),
    useWindowKeyDown: true
};
const initialState = {
    currentIndex: 0,
    previousIndex: 0,
    isTransitioning: false,
    currentSlideOffset: 0,
    slideStyle: { transition: `all 500ms ease-out` },
    thumbsStyle: {
        transition: `all 500ms ease-out`
    },
    galleryWidth: 0,
    thumbnailsWrapperWidth: 0,
    thumbnailsWrapperHeight: 0,
    thumbsTranslate: 0,
    thumbsSwipedTranslate: 0,
    isFullscreen: false,
    isSwipingThumbnail: false,
    isModalFullscreen: false,
    swipingUpDown: false,
    swipingLeftRight: false,
    resetStyleIndex: -9999
};
const reducer = (state, action) => {
    switch (action.type) {
        case 'SetState':
            return Object.assign(Object.assign({}, state), action.payload);
        default:
            return state;
    }
};
const ImageGallery = (props) => {
    const _a = Object.assign(Object.assign({}, defaultProps), props), { images, infinite, slideDuration, useBrowserFullscreen, disableKeyDown, useTranslate3D, disableSwipe, disableThumbnailScroll, stopPropagation, swipingTransitionDuration, swipingThumbnailTransitionDuration, swipeThreshold, flickThreshold, useWindowKeyDown, startIndex, onContainerClick } = _a, restProps = __rest$3(_a, ["images", "infinite", "slideDuration", "useBrowserFullscreen", "disableKeyDown", "useTranslate3D", "disableSwipe", "disableThumbnailScroll", "stopPropagation", "swipingTransitionDuration", "swipingThumbnailTransitionDuration", "swipeThreshold", "flickThreshold", "useWindowKeyDown", "startIndex", "onContainerClick"]);
    const [state, dispatch] = React.useReducer(reducer, Object.assign(Object.assign({}, initialState), { currentIndex: startIndex }));
    const loadedImagesRef = React.useRef({});
    const imageGalleryRef = React.useRef(null);
    const thumbnailsWrapperRef = React.useRef(null);
    const thumbnailsRef = React.useRef(null);
    const imageGallerySlideWrapperRef = React.useRef(null);
    const transitionTimerRef = React.useRef(0);
    const isTransitioningRef = React.useRef(false);
    React.useRef(null);
    const resizeSlideWrapperObserverRef = React.useRef(null);
    const resizeThumbnailWrapperObserverRef = React.useRef(null);
    const lazyLoadedRef = React.useRef([]);
    const directionRef = React.useRef('');
    const len = images.length;
    const canSlide = len >= 2;
    const canSlidePrevious = state.currentIndex > 0;
    const canSlideLeft = infinite || canSlidePrevious;
    const canSlideNext = state.currentIndex < len - 1;
    const canSlideRight = infinite || canSlideNext;
    const isFirstOrLastSlide = React.useCallback((index) => {
        const totalSlides = images.length - 1;
        const isLastSlide = index === totalSlides;
        const isFirstSlide = index === 0;
        return isLastSlide || isFirstSlide;
    }, [images.length]);
    const ignoreIsTransitioning = React.useCallback(() => {
        const { previousIndex, currentIndex } = state;
        const totalSlides = images.length - 1;
        const slidingMoreThanOneSlideLeftOrRight = Math.abs(previousIndex - currentIndex) > 1;
        const notGoingFromFirstToLast = !(previousIndex === 0 && currentIndex === totalSlides);
        const notGoingFromLastToFirst = !(previousIndex === totalSlides && currentIndex === 0);
        return slidingMoreThanOneSlideLeftOrRight && notGoingFromFirstToLast && notGoingFromLastToFirst;
    }, [state.currentIndex, state.previousIndex, images.length]);
    const slideIsTransitioning = React.useCallback((index) => {
        const { previousIndex, currentIndex } = state;
        const indexIsNotPreviousOrNextSlide = !(index === previousIndex || index === currentIndex);
        return isTransitioningRef.current && indexIsNotPreviousOrNextSlide;
    }, [isTransitioningRef.current, state.previousIndex, state.currentIndex]);
    const isSlideVisible = React.useCallback((index) => {
        return !slideIsTransitioning(index) || (ignoreIsTransitioning() && !isFirstOrLastSlide(index));
    }, [slideIsTransitioning, ignoreIsTransitioning, isFirstOrLastSlide]);
    React.useEffect(() => {
        transitionTimerRef.current = window.setTimeout(() => {
            if (isTransitioningRef.current) {
                isTransitioningRef.current = false;
                dispatch({
                    type: 'SetState',
                    payload: {
                        isSwipingThumbnail: false
                    }
                });
                clearTimeout(transitionTimerRef.current);
            }
        }, slideDuration + 50);
    }, [slideDuration, isTransitioningRef.current]);
    const setThumbsTranslate = React.useCallback((thumbsTranslate) => {
        dispatch({
            type: 'SetState',
            payload: {
                thumbsTranslate
            }
        });
    }, []);
    React.useCallback((item) => {
        const imageExists = loadedImagesRef.current[item.original];
        if (imageExists) {
            return true;
        }
        loadedImagesRef.current[item.original] = true;
        return false;
    }, []);
    const handleImageLoaded = (event, original) => {
        const imageExists = loadedImagesRef.current[original];
        if (!imageExists && props.onImageLoad) {
            loadedImagesRef.current[original] = true;
            props.onImageLoad();
        }
    };
    const handleImageError = (event) => { };
    const addScreenChangeEvent = React.useCallback(() => {
        screenChangeEvents.forEach(eventName => {
            document.addEventListener(eventName, handleScreenChange);
        });
    }, []);
    const removeScreenChangeEvent = React.useCallback(() => {
        screenChangeEvents.forEach(eventName => {
            document.removeEventListener(eventName, handleScreenChange);
        });
    }, []);
    const fullScreen = React.useCallback(() => {
        const gallery = imageGalleryRef.current;
        if (useBrowserFullscreen) {
            if (gallery.requestFullscreen) {
                gallery.requestFullscreen();
            }
            else if (gallery.msRequestFullscreen) {
                gallery.msRequestFullscreen();
            }
            else if (gallery.mozRequestFullScreen) {
                gallery.mozRequestFullScreen();
            }
            else if (gallery.webkitRequestFullscreen) {
                gallery.webkitRequestFullscreen();
            }
            else {
                dispatch({
                    type: 'SetState',
                    payload: {
                        isModalFullScreen: true,
                        isFullscreen: true
                    }
                });
            }
        }
        else {
            dispatch({
                type: 'SetState',
                payload: {
                    isModalFullScreen: true,
                    isFullscreen: true
                }
            });
        }
    }, []);
    const setModalFullscreen = React.useCallback((isModalFullscreen) => {
        dispatch({
            type: 'SetState',
            payload: {
                isFullscreen: !state.isFullscreen
            }
        });
        if (restProps.onScreenChange) ;
    }, [state.isFullscreen]);
    const exitFullScreen = React.useCallback(() => {
        if (state.isFullscreen) {
            if (useBrowserFullscreen) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
                else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                }
                else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                else {
                    setModalFullscreen(false);
                }
            }
            else {
                setModalFullscreen(false);
            }
            dispatch({
                type: 'SetState',
                payload: {
                    isFullscreen: false
                }
            });
        }
    }, [state.isFullscreen, useBrowserFullscreen, setModalFullscreen]);
    const handleScreenChange = React.useCallback(() => {
        const fullScreenElement = document.fullscreenElement ||
            document.msFullscreenElement ||
            document.mozFullScreenElement ||
            document.webkitFullscreenElement;
        const isFullscreen = imageGalleryRef.current === fullScreenElement;
        if (restProps.onScreenChange) ;
        if (useBrowserFullscreen) {
            dispatch({
                type: 'SetState',
                payload: {
                    isFullscreen
                }
            });
        }
    }, [useBrowserFullscreen]);
    React.useCallback(() => {
        if (state.isFullscreen) {
            exitFullScreen();
        }
        else {
            fullScreen();
        }
    }, [state.isFullscreen, exitFullScreen, fullScreen]);
    const unthrottledSlideToIndex = React.useCallback((index, event) => {
        if (!isTransitioningRef.current) {
            const slideCount = images.length - 1;
            let nextIndex = index;
            if (index < 0) {
                nextIndex = slideCount;
            }
            else if (index > slideCount) {
                nextIndex = 0;
            }
            if (restProps.onBeforeSlide && nextIndex !== state.currentIndex) ;
            (isTransitioningRef.current = nextIndex !== state.currentIndex),
                dispatch({
                    type: 'SetState',
                    payload: {
                        previousIndex: state.currentIndex,
                        currentIndex: nextIndex,
                        isTransitioning: nextIndex !== state.currentIndex,
                        currentSlideOffset: 0,
                        slideStyle: { transition: `all ${slideDuration}ms ease-out` }
                    }
                });
        }
    }, [images.length, state.currentIndex, isTransitioningRef.current]);
    const slideToIndex = React.useMemo(() => {
        return throttle(unthrottledSlideToIndex, slideDuration, { trailing: false });
    }, [slideDuration, unthrottledSlideToIndex]);
    const slideToIndexWithStyleReset = React.useCallback((nextIndex, event) => {
        const { currentIndex, currentSlideOffset } = state;
        dispatch({
            type: 'SetState',
            payload: {
                currentSlideOffset: currentSlideOffset + (currentIndex > nextIndex ? 0.001 : -0.001),
                slideStyle: { transition: 'none' },
                resetStyleIndex: nextIndex
            }
        });
    }, [state.currentIndex, state.currentSlideOffset]);
    const slideTo = React.useCallback((event, direction) => {
        const nextIndex = state.currentIndex + (direction === 'left' ? -1 : 1);
        if (isTransitioningRef.current)
            return;
        if (images.length === 2) {
            slideToIndexWithStyleReset(nextIndex, event);
        }
        else {
            slideToIndex(nextIndex, event);
        }
    }, [images.length, state.currentIndex, slideToIndexWithStyleReset, slideToIndex]);
    const slideLeft = React.useCallback((event) => {
        event.stopPropagation();
        slideTo(event, 'left');
    }, [slideTo]);
    const slideRight = React.useCallback((event) => {
        event.stopPropagation();
        slideTo(event, 'right');
    }, [slideTo]);
    const onBulletClick = React.useCallback((event, index) => {
        event.stopPropagation();
        event.target.blur();
        if (state.currentIndex !== index) {
            if (images.length === 2) {
                slideToIndexWithStyleReset(index, event);
            }
            else {
                slideToIndex(index, event);
            }
        }
    }, [images.length, state.currentIndex, slideToIndex, slideToIndexWithStyleReset]);
    const onThumbnailClick = React.useCallback((event, index) => {
        event.stopPropagation();
        event.target.parentNode.parentNode.blur();
        if (state.currentIndex !== index) {
            if (images.length === 2) {
                slideToIndexWithStyleReset(index, event);
            }
            else {
                slideToIndex(index, event);
            }
        }
    }, [slideToIndexWithStyleReset, slideToIndex, state.currentIndex, images.length]);
    const handleSwiping = React.useCallback(({ event, absX, dir }) => {
        const { galleryWidth, swipingUpDown, swipingLeftRight } = state;
        if ((dir === reactSwipeable.UP || dir === reactSwipeable.DOWN || swipingUpDown) && !swipingLeftRight) {
            if (!swipingUpDown) {
                dispatch({
                    type: 'SetState',
                    payload: {
                        swipingUpDown: true
                    }
                });
            }
            return;
        }
        if ((dir === reactSwipeable.LEFT || dir === reactSwipeable.RIGHT) && !swipingLeftRight) {
            dispatch({
                type: 'SetState',
                payload: {
                    swipingLeftRight: true
                }
            });
        }
        if (disableSwipe)
            return;
        if (stopPropagation) {
            event.preventDefault();
        }
        if (!isTransitioningRef.current) {
            const side = dir === reactSwipeable.RIGHT ? 1 : -1;
            let currentSlideOffset = (absX / galleryWidth) * 100;
            if (Math.abs(currentSlideOffset) >= 100) {
                currentSlideOffset = 100;
            }
            const swipingTransition = {
                transition: `transform ${swipingTransitionDuration}ms ease-out`
            };
            dispatch({
                type: 'SetState',
                payload: {
                    currentSlideOffset: side * currentSlideOffset,
                    slideStyle: swipingTransition
                }
            });
        }
        else {
            dispatch({
                type: 'SetState',
                payload: {
                    currentSlideOffset: 0
                }
            });
        }
    }, [state]);
    const handleThumbnailSwiping = React.useCallback(({ event, absX, absY, dir }) => {
        if (restProps.disableThumbnailSwipe) {
            return;
        }
        const { thumbsSwipedTranslate, thumbnailsWrapperHeight, thumbnailsWrapperWidth, swipingUpDown, swipingLeftRight } = state;
        if ((dir === reactSwipeable.UP || dir === reactSwipeable.DOWN || swipingUpDown) && !swipingLeftRight) {
            if (!swipingUpDown) {
                dispatch({
                    type: 'SetState',
                    payload: {
                        cswipingUpDown: true
                    }
                });
                return;
            }
        }
        if ((dir === reactSwipeable.LEFT || dir === reactSwipeable.RIGHT) && !swipingLeftRight) {
            dispatch({
                type: 'SetState',
                payload: {
                    swipingLeftRight: true
                }
            });
        }
        const thumbsElement = thumbnailsRef.current;
        const emptySpaceMargin = 20;
        let thumbsTranslate;
        let totalSwipeableLength;
        let hasSwipedPassedEnd;
        let hasSwipedPassedStart;
        let isThumbnailBarSmallerThanContainer;
        if (thumbsElement) {
            const slideX = dir === reactSwipeable.RIGHT ? absX || 0 : -(absX || 0);
            thumbsTranslate = thumbsSwipedTranslate + slideX;
            totalSwipeableLength = thumbsElement.scrollWidth - thumbnailsWrapperWidth + emptySpaceMargin;
            hasSwipedPassedEnd = Math.abs(thumbsTranslate) > totalSwipeableLength;
            hasSwipedPassedStart = thumbsTranslate > emptySpaceMargin;
            isThumbnailBarSmallerThanContainer = thumbsElement.scrollWidth <= thumbnailsWrapperWidth;
        }
        if (isThumbnailBarSmallerThanContainer) {
            return;
        }
        if ((dir === reactSwipeable.LEFT || dir === reactSwipeable.UP) && hasSwipedPassedEnd) {
            return;
        }
        if ((dir === reactSwipeable.RIGHT || dir === reactSwipeable.DOWN) && hasSwipedPassedStart) {
            return;
        }
        if (stopPropagation)
            event.stopPropagation();
        const swipingTransition = {
            transition: `transform ${swipingThumbnailTransitionDuration}ms ease-out`
        };
        dispatch({
            type: 'SetState',
            payload: {
                thumbsTranslate,
                thumbsStyle: swipingTransition
            }
        });
    }, [restProps.disableThumbnailSwipe, state]);
    const sufficientSwipe = React.useCallback(() => {
        const { currentSlideOffset } = state;
        return Math.abs(currentSlideOffset) > swipeThreshold;
    }, [state.currentSlideOffset, swipeThreshold]);
    const resetSwipingDirection = React.useCallback(() => {
        const { swipingUpDown, swipingLeftRight } = state;
        if (swipingUpDown) {
            dispatch({
                type: 'SetState',
                payload: {
                    swipingUpDown: false
                }
            });
        }
        if (swipingLeftRight) {
            dispatch({
                type: 'SetState',
                payload: {
                    swipingLeftRight: false
                }
            });
        }
    }, [state.swipingLeftRight, state.swipingUpDown]);
    const handleOnThumbnailSwiped = React.useCallback(() => {
        if (restProps.disableThumbnailSwipe) {
            return;
        }
        const { thumbsTranslate } = state;
        resetSwipingDirection();
        dispatch({
            type: 'SetState',
            payload: {
                isSwipingThumbnail: true,
                thumbsSwipedTranslate: thumbsTranslate,
                thumbsStyle: { transition: `all ${slideDuration}ms ease-out` }
            }
        });
    }, [resetSwipingDirection, state.thumbsTranslate, slideDuration]);
    const handleOnSwipedTo = React.useCallback((swipeDirection, isLeftRightFlick) => {
        const { currentIndex } = state;
        if (isTransitioningRef.current) {
            return;
        }
        let slideTo = currentIndex;
        if ((sufficientSwipe() || isLeftRightFlick) && !isTransitioningRef.current) {
            slideTo += swipeDirection;
        }
        if ((swipeDirection === -1 && !canSlideLeft) || (swipeDirection === 1 && !canSlideRight)) {
            slideTo = currentIndex;
        }
        unthrottledSlideToIndex(slideTo, '');
    }, [unthrottledSlideToIndex, state.currentIndex, sufficientSwipe]);
    const handleOnSwiped = React.useCallback(({ event, dir, velocity }) => {
        if (disableSwipe || isTransitioningRef.current)
            return;
        if (stopPropagation)
            event.stopPropagation();
        resetSwipingDirection();
        const swipeDirection = dir === reactSwipeable.LEFT ? 1 : -1;
        const isSwipeUpOrDown = dir === reactSwipeable.UP || dir === reactSwipeable.DOWN;
        const isLeftRightFlick = velocity > flickThreshold && !isSwipeUpOrDown;
        handleOnSwipedTo(swipeDirection, isLeftRightFlick);
    }, [flickThreshold, disableSwipe, handleOnSwipedTo, resetSwipingDirection]);
    const handleKeyDown = React.useCallback((event) => {
        const { isFullscreen } = state;
        if (disableKeyDown)
            return;
        const LEFT_ARROW = 37;
        const RIGHT_ARROW = 39;
        const ESC_KEY = 27;
        const key = parseInt(event.keyCode || event.which || 0, 10);
        switch (key) {
            case LEFT_ARROW:
                if (canSlideLeft) {
                    slideLeft(event);
                }
                break;
            case RIGHT_ARROW:
                if (canSlideRight) {
                    slideRight(event);
                }
                break;
            case ESC_KEY:
                if (isFullscreen && !useBrowserFullscreen) {
                    exitFullScreen();
                }
                break;
        }
    }, [disableKeyDown, state.isFullscreen, canSlideLeft, canSlideRight, slideLeft, slideRight, exitFullScreen]);
    const handleTouchMove = React.useCallback((event) => {
        const { swipingLeftRight } = state;
        if (swipingLeftRight) {
            event.preventDefault();
        }
    }, [state.swipingLeftRight]);
    const getThumbsTranslate = React.useCallback((indexDifference) => {
        const { thumbnailsWrapperWidth } = state;
        let hiddenScroll;
        const thumbsElement = thumbnailsRef.current;
        if (disableThumbnailScroll)
            return 0;
        if (thumbsElement) {
            if (thumbsElement.scrollWidth <= thumbnailsWrapperWidth || thumbnailsWrapperWidth <= 0) {
                return 0;
            }
            hiddenScroll = thumbsElement.scrollWidth - thumbnailsWrapperWidth;
            const perIndexScroll = hiddenScroll / (images.length - 1);
            return indexDifference * perIndexScroll;
        }
        return 0;
    }, [disableThumbnailScroll, state.thumbnailsWrapperWidth]);
    const handleResize = React.useCallback(() => {
        const { currentIndex } = state;
        if (!imageGalleryRef.current) {
            return;
        }
        if (imageGalleryRef.current) {
            dispatch({
                type: 'SetState',
                payload: {
                    galleryWidth: imageGalleryRef.current.offsetWidth
                }
            });
        }
        if (imageGallerySlideWrapperRef.current) {
            dispatch({
                type: 'SetState',
                payload: {
                    gallerySlideWrapperHeight: imageGallerySlideWrapperRef.current.offsetHeight
                }
            });
        }
        setThumbsTranslate(-getThumbsTranslate(currentIndex));
    }, [state.currentIndex, getThumbsTranslate, setThumbsTranslate]);
    const initSlideWrapperResizeObserver = React.useCallback((element) => {
        if (element && !element.current)
            return;
        resizeSlideWrapperObserverRef.current = new ResizeObserver(debounce(entries => {
            if (!entries)
                return;
            entries.forEach((entry) => {
                dispatch({
                    type: 'SetState',
                    payload: {
                        thumbnailsWrapperWidth: entry.contentRect.width
                    }
                });
            });
        }, 50));
        resizeSlideWrapperObserverRef.current.observe(element.current);
    }, []);
    const removeThumbnailsResizeObserver = React.useCallback(() => {
        if (resizeThumbnailWrapperObserverRef.current && thumbnailsWrapperRef && thumbnailsWrapperRef.current) {
            resizeThumbnailWrapperObserverRef.current.unobserve(thumbnailsWrapperRef.current);
            resizeThumbnailWrapperObserverRef.current = null;
        }
    }, []);
    const removeResizeObserver = React.useCallback(() => {
        if (resizeSlideWrapperObserverRef.current && imageGallerySlideWrapperRef && imageGallerySlideWrapperRef.current) {
            resizeSlideWrapperObserverRef.current.unobserve(imageGallerySlideWrapperRef.current);
            resizeSlideWrapperObserverRef.current = null;
        }
        removeThumbnailsResizeObserver();
    }, [removeThumbnailsResizeObserver]);
    const initThumbnailWrapperResizeObserver = React.useCallback((element) => {
        if (element && !element.current)
            return;
        resizeThumbnailWrapperObserverRef.current = new ResizeObserver(debounce(entries => {
            if (!entries)
                return;
            entries.forEach((entry) => {
                dispatch({
                    type: 'SetState',
                    payload: {
                        thumbnailsWrapperHeight: entry.contentRect.height
                    }
                });
            });
        }, 50));
        resizeThumbnailWrapperObserverRef.current.observe(element.current);
    }, []);
    React.useEffect(() => {
        if (state.thumbnailsWrapperWidth > 0 || state.thumbnailsWrapperHeight > 0) {
            handleResize();
        }
    }, [state.thumbnailsWrapperWidth, state.thumbnailsWrapperHeight, handleResize]);
    React.useEffect(() => {
        if (state.resetStyleIndex > -9999) {
            slideToIndex(state.resetStyleIndex, '');
        }
    }, [state.resetStyleIndex]);
    React.useEffect(() => {
        if (useWindowKeyDown) {
            window.addEventListener('keydown', handleKeyDown);
        }
        else if (imageGalleryRef.current) {
            imageGalleryRef.current.addEventListener('keydown', handleKeyDown);
        }
        window.addEventListener('touchmove', handleTouchMove, { passive: false });
        initSlideWrapperResizeObserver(imageGallerySlideWrapperRef);
        initThumbnailWrapperResizeObserver(thumbnailsWrapperRef);
        addScreenChangeEvent();
        return () => {
            window.removeEventListener('touchmove', handleTouchMove);
            removeScreenChangeEvent();
            removeResizeObserver();
            if (useWindowKeyDown) {
                window.removeEventListener('keydown', handleKeyDown);
            }
            else if (imageGalleryRef.current) {
                imageGalleryRef.current.removeEventListener('keydown', handleKeyDown);
            }
        };
    }, [useWindowKeyDown, handleKeyDown, addScreenChangeEvent, handleTouchMove]);
    const getThumbnailPositionClassName = () => {
        return 'image-gallery-thumbnails-bottom';
    };
    const getAlignmentClassName = (index) => {
        const { currentIndex } = state;
        let alignment = '';
        const leftClassName = 'image-gallery-left';
        const centerClassName = 'image-gallery-center relative';
        const rightClassName = 'image-gallery-right';
        switch (index) {
            case currentIndex - 1:
                alignment = ` ${leftClassName}`;
                break;
            case currentIndex:
                alignment = ` ${centerClassName}`;
                break;
            case currentIndex + 1:
                alignment = ` ${rightClassName}`;
                break;
        }
        if (images.length >= 3 && infinite) {
            if (index === 0 && currentIndex === images.length - 1) {
                alignment = ` ${rightClassName}`;
            }
            else if (index === images.length - 1 && currentIndex === 0) {
                alignment = ` ${leftClassName}`;
            }
        }
        return alignment;
    };
    const getTranslateXForTwoSlide = (index) => {
        const { currentIndex, currentSlideOffset, previousIndex } = state;
        const indexChanged = currentIndex !== previousIndex;
        const firstSlideWasPrevSlide = index === 0 && previousIndex === 0;
        const secondSlideWasPrevSlide = index === 1 && previousIndex === 1;
        const firstSlideIsNextSlide = index === 0 && currentIndex === 1;
        const secondSlideIsNextSlide = index === 1 && currentIndex === 0;
        const swipingEnded = currentSlideOffset === 0;
        const baseTranslateX = -100 * currentIndex;
        let translateX = baseTranslateX + index * 100 + currentSlideOffset;
        if (currentSlideOffset > 0) {
            directionRef.current = 'left';
        }
        else if (currentSlideOffset < 0) {
            directionRef.current = 'right';
        }
        if (secondSlideIsNextSlide && currentSlideOffset > 0) {
            translateX = -100 + currentSlideOffset;
        }
        if (firstSlideIsNextSlide && currentSlideOffset < 0) {
            translateX = 100 + currentSlideOffset;
        }
        if (indexChanged) {
            if (firstSlideWasPrevSlide && swipingEnded && directionRef.current === 'left') {
                translateX = 100;
            }
            else if (secondSlideWasPrevSlide && swipingEnded && directionRef.current === 'right') {
                translateX = -100;
            }
        }
        else {
            if (secondSlideIsNextSlide && swipingEnded && directionRef.current === 'left') {
                translateX = -100;
            }
            if (firstSlideIsNextSlide && swipingEnded && directionRef.current === 'right') {
                translateX = 100;
            }
        }
        return translateX;
    };
    const getThumbnailBarHeight = () => {
        return {};
    };
    const getThumbnailStyle = () => {
        let translate;
        const { thumbsTranslate, thumbsStyle } = state;
        translate = `translate(${thumbsTranslate}px, 0)`;
        if (useTranslate3D) {
            translate = `translate3d(${thumbsTranslate}px, 0, 0)`;
        }
        return Object.assign({ WebkitTransform: translate, MozTransform: translate, msTransform: translate, OTransform: translate, transform: translate }, thumbsStyle);
    };
    const getSlideStyle = (index) => {
        const { currentIndex, currentSlideOffset, slideStyle } = state;
        const baseTranslateX = -100 * currentIndex;
        const totalSlides = images.length - 1;
        let translateX = baseTranslateX + index * 100 + currentSlideOffset;
        if (infinite && images.length > 2) {
            if (currentIndex === 0 && index === totalSlides) {
                translateX = -100 + currentSlideOffset;
            }
            else if (currentIndex === totalSlides && index === 0) {
                translateX = 100 + currentSlideOffset;
            }
        }
        if (infinite && images.length === 2) {
            translateX = getTranslateXForTwoSlide(index);
        }
        let translate = `translate(${translateX}%, 0)`;
        if (useTranslate3D) {
            translate = `translate3d(${translateX}%, 0, 0)`;
        }
        const isVisible = isSlideVisible(index);
        return Object.assign({ display: isVisible ? 'inherit' : 'none', WebkitTransform: translate, MozTransform: translate, msTransform: translate, OTransform: translate, transform: translate }, slideStyle);
    };
    const renderItem = (item) => {
        const { isFullscreen } = state;
        const { onImageError } = restProps;
        const handleImgError = onImageError || handleImageError;
        if (!Array.isArray(item)) {
            return (jsxRuntime.jsx(Item, { fullscreen: item.fullscreen, handleImageLoaded: handleImageLoaded, isFullscreen: isFullscreen, onImageError: handleImgError, original: item.original, originalAlt: item.originalAlt, originalHeight: String(item.originalHeight), originalWidth: String(item.originalWidth), sizes: item.sizes, loading: item.loading, srcSet: item.srcSet }));
        }
    };
    const renderThumbInner = (item) => {
        const handleThumbnailError = restProps.onThumbnailError || handleImageError;
        return (jsxRuntime.jsx("div", { className: "image-gallery-thumbnail-inner block relative w-full h-full", children: jsxRuntime.jsx("img", { className: "image-gallery-thumbnail-image align-middle leading-0 w-full h-full", src: item.thumbnail, height: item.thumbnailHeight, width: item.thumbnailWidth, alt: item.thumbnailAlt, loading: item.thumbnailLoading, onError: handleThumbnailError }) }));
    };
    const getSlideItems = () => {
        const { currentIndex } = state;
        const slides = [];
        const thumbnails = [];
        const bullets = [];
        images.forEach((item, index) => {
            const alignment = getAlignmentClassName(index);
            const isArr = Array.isArray(item);
            const originalClass = !isArr && item.originalClass ? ` ${item.originalClass}` : '';
            const thumbnailClass = !isArr && item.thumbnailClass ? ` ${item.thumbnailClass}` : '';
            const handleRenderItem = ((!isArr && item.renderItem) || restProps.renderItem || renderItem);
            const handleRenderThumbInner = ((!isArr && item.renderThumbInner) ||
                restProps.renderThumbInner ||
                renderThumbInner);
            const showItem = !restProps.lazyLoad || alignment || lazyLoadedRef.current[index];
            if (showItem && restProps.lazyLoad && !lazyLoadedRef.current[index]) {
                lazyLoadedRef.current[index] = true;
            }
            const slideStyle = getSlideStyle(index);
            const slide = (jsxRuntime.jsx("div", { "aria-label": `Go to Slide ${index + 1}`, tabIndex: -1, className: `image-gallery-slide absolute left-0 top-0 w-full ${alignment} ${originalClass}`, style: slideStyle, onClick: restProps.onClick, onTouchMove: restProps.onTouchMove, onTouchEnd: restProps.onTouchEnd, onTouchStart: restProps.onTouchStart, role: "button", children: showItem ? handleRenderItem(item) || null : jsxRuntime.jsx("div", { style: { height: '100%' } }) }, `slide-${index}`));
            slides.push(slide);
            if (restProps.showThumbnails && !isArr && item.thumbnail) {
                const igThumbnailClass = clsx__default.default('image-gallery-thumbnail inline-block transition-all w-10 h-10 bg-transparent p-0 rounded-[6px] overflow-hidden', thumbnailClass, { 'opacity-20': currentIndex !== index });
                thumbnails.push(jsxRuntime.jsx("button", { type: "button", tabIndex: 0, "aria-pressed": currentIndex === index ? 'true' : 'false', "aria-label": `Go to Slide ${index + 1}`, className: igThumbnailClass, onClick: event => onThumbnailClick(event, index), children: handleRenderThumbInner(item) }, `thumbnail-${index}`));
            }
            if (restProps.showBullets) {
                const igBulletClass = clsx__default.default('appearance-none bg-[#DBDDDF] rounded-full cursor-pointer inline-block  w-2 h-2 outline-none transition-all', !isArr ? item.bulletClass : '', {
                    'bg-surface-primary-default': currentIndex === index
                });
                bullets.push(jsxRuntime.jsx("button", { type: "button", className: igBulletClass, onClick: event => onBulletClick(event, index), "aria-pressed": currentIndex === index ? 'true' : 'false', "aria-label": `Go to Slide ${index + 1}` }, `bullet-${index}`));
            }
        });
        return {
            slides,
            thumbnails,
            bullets
        };
    };
    const { currentIndex, isFullscreen, isModalFullscreen } = state;
    const thumbnailStyle = getThumbnailStyle();
    const slideContext = getSlideItems();
    const slideWrapperClass = clsx__default.default('image-gallery-slide-wrapper relative overflow-hidden w-full flex-1 flex justify-center group', restProps.slideWrapperClass, getThumbnailPositionClassName());
    const handleClick = () => {
        onContainerClick();
    };
    const slideWrapper = (jsxRuntime.jsxs("div", { ref: imageGallerySlideWrapperRef, className: slideWrapperClass, children: [restProps.renderCustomControls && restProps.renderCustomControls(), canSlide ? (jsxRuntime.jsx("div", { className: "relative overflow-hidden w-fit flex items-center justify-center", children: jsxRuntime.jsx(SwipeWrapper, { className: "image-gallery-swipe", delta: 0, onSwiping: handleSwiping, onSwiped: handleOnSwiped, children: jsxRuntime.jsx("div", { className: "image-gallery-slides leading-[0] w-full overflow-hidden relative whitespace-nowrap text-center", children: slideContext.slides }) }) })) : (jsxRuntime.jsx("div", { className: "image-gallery-slides leading-[0] overflow-hidden w-full relative whitespace-nowrap text-center flex items-center justify-center", children: slideContext.slides })), restProps.showBullets && restProps.bulltetPosition === 'inside' && (jsxRuntime.jsx("div", { className: clsx__default.default('absolute left-0 right-0 w-[80%] z-[4] mx-auto'), children: jsxRuntime.jsx("div", { className: "m-0 p-0 text-center space-x-2", role: "navigation", "aria-label": "Bullet Navigation", children: slideContext.bullets }) })), canSlide && restProps.showNav && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [restProps.renderLeftNav(slideLeft, !canSlideLeft), restProps.renderRightNav(slideRight, !canSlideRight)] })), restProps.showFullscreenButton && restProps.renderFullscreenButton(setModalFullscreen, isFullscreen)] }));
    const igClass = clsx__default.default('image-gallery relative select-none tap-higtlight h-full', restProps.additionalClass);
    const igContentClass = clsx__default.default('relative top-0 leading-[0] h-full flex justify-center items-center flex-col', {
        'bg-surface-container-default': isFullscreen
    });
    const thumbnailWrapperClass = clsx__default.default('relative ', getThumbnailPositionClassName(), {
        'thumbnails-swipe-horizontal touch-pan-y': !restProps.disableThumbnailSwipe
    });
    return (jsxRuntime.jsx("div", { ref: imageGalleryRef, className: igClass, "aria-live": "polite", onClick: handleClick, children: jsxRuntime.jsxs("div", { className: igContentClass, children: [slideWrapper, restProps.showBullets && restProps.bulltetPosition !== 'inside' && (jsxRuntime.jsx("div", { className: clsx__default.default('w-[80%] z-[4] mx-auto mt-3'), children: jsxRuntime.jsx("div", { className: "m-0 p-0 text-center space-x-2", role: "navigation", "aria-label": "Bullet Navigation", children: slideContext.bullets }) })), restProps.showThumbnails && slideContext.thumbnails.length > 1 ? (jsxRuntime.jsx(SwipeWrapper, { className: thumbnailWrapperClass, delta: 0, onSwiping: handleThumbnailSwiping, onSwiped: handleOnThumbnailSwiped, children: jsxRuntime.jsx("div", { className: "image-gallery-thumbnails overflow-y-hidden overflow-x-scroll py-1 md:py-3", ref: thumbnailsWrapperRef, style: getThumbnailBarHeight(), children: jsxRuntime.jsx("nav", { ref: thumbnailsRef, className: "image-gallery-thumbnails-container w-full cursor-pointer whitespace-nowrap text-center space-x-2", style: thumbnailStyle, "aria-label": "Thumbnail Navigation", children: slideContext.thumbnails }) }) })) : null, restProps.renderBottom && restProps.renderBottom(state.currentIndex)] }) }));
};

function ImageGenDisplay({ message, showAudio, showText }) {
    const { editorMode, publish } = React.useContext(MessageContext);
    const { entityInfo, imgGenerator } = React.useContext(StaticContext);
    const { selectedImg, everPublished, addImg, removeImg, reachedLimitation } = publish || {};
    const { status } = entityInfo;
    const { imageGenMessageResponse } = message;
    const { imgBatch, metadata, genStatus } = imageGenMessageResponse || {};
    const hasImages = Array.isArray(imgBatch) && imgBatch.length > 0;
    const t = nextIntl.useTranslations();
    const [preview, setPreview] = React.useState({
        isPreview: false,
        startIndex: 0
    });
    const aspectRatio = divideToFraction(Number((metadata === null || metadata === void 0 ? void 0 : metadata.width) || 1), Number((metadata === null || metadata === void 0 ? void 0 : metadata.height) || 1)).text;
    const aspectRatioStyle = hasImages
        ? {
            aspectRatio
        }
        : {};
    const handleImagePublishChecked = React.useCallback((img) => {
        if (selectedImg === null || selectedImg === void 0 ? void 0 : selectedImg.has(img.original)) {
            removeImg === null || removeImg === void 0 ? void 0 : removeImg(img.original);
        }
        else {
            if (reachedLimitation)
                return;
            addImg === null || addImg === void 0 ? void 0 : addImg(img.original, {
                messageId: message.id,
                imageLink: img.original,
                naturalHeight: img.originalHeight,
                naturalWidth: img.originalWidth
            });
        }
    }, [addImg, message.id, reachedLimitation, removeImg, selectedImg]);
    const images = React.useMemo(() => {
        return (hasImages ? imgBatch : []).map((batch, batchIndex) => {
            return batch.img.map((url, index) => {
                var _a, _b;
                return {
                    original: url,
                    thumbnail: url,
                    batchIndex,
                    index,
                    originalHeight: String((_a = metadata === null || metadata === void 0 ? void 0 : metadata.height) !== null && _a !== void 0 ? _a : ''),
                    originalWidth: String((_b = metadata === null || metadata === void 0 ? void 0 : metadata.width) !== null && _b !== void 0 ? _b : '')
                };
            });
        });
    }, [hasImages, imgBatch, metadata]);
    const modalImages = React.useMemo(() => {
        return images.flat();
    }, [images]);
    const { publishing, publishGalleryList } = usePublishGallery();
    const [popupConfirmObj, setPopupConfirmObj] = React.useState(null);
    const [publishState, setPublishState] = React.useState('info');
    const [tipImageLoad, setTipImageLoad] = React.useState(false);
    const imageLoadCallback = (index) => {
        if (index === 0) {
            setTipImageLoad(true);
        }
    };
    const handleClick = React.useCallback((event, img) => {
        if (editorMode === 'PUBLISH') {
            if (selectedImg === null || selectedImg === void 0 ? void 0 : selectedImg.has(img.original)) {
                removeImg === null || removeImg === void 0 ? void 0 : removeImg(img.original);
            }
            else {
                if (reachedLimitation)
                    return;
                addImg === null || addImg === void 0 ? void 0 : addImg(img.original, {
                    messageId: message.id,
                    imageLink: img.original,
                    naturalHeight: img.originalHeight,
                    naturalWidth: img.originalWidth
                });
            }
        }
        else {
            setPreview({
                isPreview: true,
                startIndex: img.batchIndex * 4 + img.index
            });
        }
    }, [editorMode, selectedImg, removeImg, reachedLimitation, addImg, message.id]);
    const handlePreviewClose = React.useCallback(() => {
        setPreview({
            isPreview: false,
            startIndex: 0
        });
    }, []);
    const { success } = useNotification();
    const publishSuccessCb = React.useCallback(() => {
        if (publishState === 'info' && !everPublished) {
            setPublishState('success');
        }
        else {
            success({
                content: t('chat.suc_send')
            });
            setPopupConfirmObj(null);
            setPublishState('info');
            handlePreviewClose();
        }
    }, [setPopupConfirmObj]);
    const confirmHandler = React.useCallback(() => {
        if (publishState === 'success') {
            setPopupConfirmObj(null);
            setPublishState('info');
            handlePreviewClose();
        }
        else {
            popupConfirmObj && publishGalleryList(publishSuccessCb, [popupConfirmObj]);
        }
    }, [publishState, publishGalleryList, publishSuccessCb]);
    const renderItem = React.useCallback((item) => {
        if (!Array.isArray(item)) {
            return null;
        }
        const imgLen = item.length;
        let cl = '';
        switch (imgLen) {
            case 1:
                cl = 'grid-cols-1 grid-rows-1';
                break;
            case 2:
                cl = 'grid-cols-2 grid-rows-1';
                break;
            case 4:
            default:
                cl = 'grid-cols-2 grid-rows-2';
                break;
        }
        return (jsxRuntime.jsx("div", { className: clsx__default.default('grid gap-x-px gap-y-px', cl), children: item.map((img, index) => {
                const publishChecked = selectedImg === null || selectedImg === void 0 ? void 0 : selectedImg.has(img.original);
                return (jsxRuntime.jsxs("div", { className: clsx__default.default('relative', `group/item`), style: aspectRatioStyle, children: [jsxRuntime.jsx(Image$1, { "x-image-source": "gallery", style: aspectRatioStyle, alt: "", src: img.original, index: index, status: genStatus, aspectRatio: aspectRatio, onClick: (e) => handleClick(e, img), imageLoadCallback: () => {
                                imageLoadCallback(index);
                            } }), editorMode === 'PUBLISH' &&
                            img.original &&
                            (!reachedLimitation || (reachedLimitation && publishChecked)) && (jsxRuntime.jsx("div", { className: "w-6 h-6 ml-0 flex justify-center items-center absolute right-3 top-3 z-[1]", children: jsxRuntime.jsx(Checkbox, { variant: "circle-static", checked: publishChecked, onCheckedChange: () => {
                                    handleImagePublishChecked(img);
                                } }) })), !everPublished &&
                            index === 0 &&
                            imgGenerator &&
                            tipImageLoad &&
                            editorMode !== 'PUBLISH' &&
                            status === BotStatusEnum.Public && jsxRuntime.jsx(RightClickPublishTip, { className: "absolute -right-10 -bottom-2" })] }, index));
            }) }));
    }, [genStatus, aspectRatio, aspectRatioStyle]);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(DefaultDisplay, { message: message, showAudio: showAudio, showText: showText }), jsxRuntime.jsx("div", { className: "mx-3", style: aspectRatioStyle, children: jsxRuntime.jsx(ImageGallery, { images: images, renderItem: renderItem, showBullets: images.length > 1, showNav: images.length > 1, bulltetPosition: "outside", slideWrapperClass: "overflow-hidden rounded-xl", showFullscreenButton: false }) }), jsxRuntime.jsx(Modal, { open: preview.isPreview, onClose: handlePreviewClose, contentClassName: "w-full h-full max-h-full rounded-none z-[100] bg-beta-black-10", iconClassName: "text-static bg-beta-black-20 hover:bg-beta-black-40 active:bg-beta-black-40", fullScreen: true, children: jsxRuntime.jsx("div", { className: "relative bg-beta-black-10 xxxx overflow-hidden w-full h-full px-4 md:px-0", children: jsxRuntime.jsx("div", { className: "w-full h-full relative overflow-hidden", children: jsxRuntime.jsx(ImageGallery, { images: modalImages, startIndex: preview.startIndex, showThumbnails: true, showBullets: false, showNav: modalImages.length > 1, showFullscreenButton: false, onContainerClick: handlePreviewClose }) }) }) }), jsxRuntime.jsx(GalleryPublishTipModal, { publishing: publishing, publishState: publishState, open: !!(popupConfirmObj === null || popupConfirmObj === void 0 ? void 0 : popupConfirmObj.botId), onClose: () => {
                    setPopupConfirmObj(null);
                    setPublishState('info');
                    publishState === 'success' && handlePreviewClose();
                }, onConfirm: confirmHandler })] }));
}

const getErrorMsgByType = (requestErrorTranslations, type) => {
    switch (type) {
        case RunningErrorEnum.ENGINE_ERROR:
            return requestErrorTranslations('chat_error_tip');
        case RunningErrorEnum.INNER_COMPONENT_ERROR:
            return requestErrorTranslations('inner_component_error_tip');
        case RunningErrorEnum.LLM_TOKEN_TOO_LONG:
            return requestErrorTranslations('exceeded_token_error_tip');
        default:
            return '';
    }
};
const RunningError = ({ message }) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const { partialUpdateMessage } = React.useContext(MessageContext);
    const { onMarked } = useButtonActions(message, undefined, partialUpdateMessage);
    const t = nextIntl.useTranslations('chat');
    const errorT = nextIntl.useTranslations('request.error');
    const [isOpen, setIsOpen] = React.useState(false);
    const { onCopy } = useCopyClipboard(((_a = message === null || message === void 0 ? void 0 : message.runningError) === null || _a === void 0 ? void 0 : _a.errorDetail) || '');
    const isVisitor = useUserStore(user => user.isVisitor);
    const level = useUserStore(state => { var _a; return (_a = state.user) === null || _a === void 0 ? void 0 : _a.level; });
    const energy = useUserStore(state => state.energy);
    const onConfirm = () => {
        onCopy();
        setIsOpen(false);
    };
    const onShowDetail = () => {
        setIsOpen(true);
    };
    const onClose = () => {
        setIsOpen(false);
    };
    const onIgnore = () => {
        onMarked();
    };
    const errorMessage = React.useMemo(() => { var _a; return getErrorMsgByType(errorT, (_a = message === null || message === void 0 ? void 0 : message.runningError) === null || _a === void 0 ? void 0 : _a.errorType); }, [(_b = message === null || message === void 0 ? void 0 : message.runningError) === null || _b === void 0 ? void 0 : _b.errorType]);
    if (((_c = message === null || message === void 0 ? void 0 : message.runningError) === null || _c === void 0 ? void 0 : _c.errorType) === RunningErrorEnum.ENERGY_INSUFFICIANT) {
        if (energy > (((_d = message === null || message === void 0 ? void 0 : message.runningError) === null || _d === void 0 ? void 0 : _d.requireEnergyToUse) || 0)) {
            return null;
        }
        if (isVisitor === 2 && level === 1) {
            return (jsxRuntime.jsx("li", { className: "last:animate-slideIn list-none", children: jsxRuntime.jsx(ClaimPasscard, { type: "action", onClose: onIgnore }) }));
        }
        return (jsxRuntime.jsx("li", { className: "last:animate-slideIn list-none", children: jsxRuntime.jsx(EnergyPackUseTip, { type: "action", onClose: onIgnore }) }));
    }
    const hiddenDetail = ((_e = message.runningError) === null || _e === void 0 ? void 0 : _e.errorType) === RunningErrorEnum.LLM_TOKEN_TOO_LONG;
    if (message.handled) {
        return null;
    }
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(Alert, { variant: "error", className: "flex-col md:flex-col lg:flex-row", children: [jsxRuntime.jsx(AlertDescription, { children: jsxRuntime.jsxs("div", { className: "flex gap-[6px]", children: [jsxRuntime.jsx(ForwardRef$D, { className: "hidden md:block shrink-0 size-6 text-icon-critical" }), jsxRuntime.jsx(Text, { children: errorMessage })] }) }), jsxRuntime.jsxs("div", { className: "w-full gap-x-2 md:w-auto flex justify-center self-end lg:self-auto", children: [hiddenDetail ? null : (jsxRuntime.jsx(Button$1, { className: "flex-1 md:flex-none", color: "error", size: "md", onClick: onShowDetail, children: t('view_details') })), jsxRuntime.jsx(Button$1, { className: "flex-1 md:flex-none", color: "error", size: "md", variant: hiddenDetail ? undefined : 'outline', onClick: onIgnore, children: t('ignore') })] })] }), jsxRuntime.jsx(Dialog, { open: isOpen, children: jsxRuntime.jsxs(DialogContent, { className: "w-310px md:w-[380px]", onClose: onClose, maskClosable: false, children: [jsxRuntime.jsx(DialogHeader, { className: "px-5 h-[68px] flex justify-center", children: jsxRuntime.jsx(DialogTitle, { children: jsxRuntime.jsx(Heading, { size: "h2", children: t('error_detail') }) }) }), jsxRuntime.jsx(DialogDescription, { className: "px-5 pt-1 pb-3 grid gap-y-1.5 overflow-y-auto", children: jsxRuntime.jsx(Text, { className: "break-all max-h-[400px]", dangerous: true, children: ((_g = (_f = message.runningError) === null || _f === void 0 ? void 0 : _f.errorDetail) === null || _g === void 0 ? void 0 : _g.replaceAll('\n', '<br />')) || '' }) }), jsxRuntime.jsx(DialogFooter, { className: "gap-x-5 min-h-[76px]", children: jsxRuntime.jsxs(Button$1, { className: "w-full", onClick: onConfirm, color: "error", children: [jsxRuntime.jsx(lucideReact.Copy, { className: "w-[20px] h-[20px] mr-1.5 mt-0.5" }), t('copy_error_message')] }) })] }) })] }));
};
function RunningWidgetInfo({ list }) {
    const widgetInfoStatusIcon = {
        PROCESSING: jsxRuntime.jsx(Spinner, { size: "sm", className: "text-brand" }),
        ERROR: jsxRuntime.jsx(ForwardRef$V, { width: "20px", color: "var(--red-40)" }),
        DONE: jsxRuntime.jsx(ForwardRef$W, { width: "20px", color: "var(--green-30)" })
    };
    return (jsxRuntime.jsx("div", { className: "w-auto flex flex-col gap-2", children: list.map(info => {
            return (jsxRuntime.jsxs("div", { className: "flex items-center", children: [widgetInfoStatusIcon[info.status], jsxRuntime.jsx("p", { className: "text-subtle text-sm ml-2", children: generateWidgetRunningText(info) })] }, info.widgetName));
        }) }));
}

const MdViewer = dynamic__default.default(() => Promise.resolve().then(function () { return MdViewer$4; }), {
    loading: () => jsxRuntime.jsx("div", { children: "loading..." }),
    ssr: false
});
function AsyncJobDisplay({ message, showText, showAudio }) {
    var _a, _b, _c, _d, _e, _f;
    const { getJobInfo } = React.useContext(MessageContext);
    const intervalId = React.useRef(null);
    const pollingInterval = 2000;
    const polling = () => {
        var _a, _b, _c;
        const fn = async () => {
            var _a;
            if (((_a = message.asyncJobInfo) === null || _a === void 0 ? void 0 : _a.jobId) && message.status !== 'CANCELING' && message.status !== 'CANCELED') {
                const res = await (getJobInfo === null || getJobInfo === void 0 ? void 0 : getJobInfo(message.asyncJobInfo.jobId, message.id));
                return res;
            }
            return false;
        };
        if ((((_a = message.asyncJobInfo) === null || _a === void 0 ? void 0 : _a.status) === EmbedObjStatus$1.PENDING ||
            ((_b = message.asyncJobInfo) === null || _b === void 0 ? void 0 : _b.status) === EmbedObjStatus$1.PROCESSING ||
            ((_c = message.asyncJobInfo) === null || _c === void 0 ? void 0 : _c.status) === EmbedObjStatus$1.QUEUEING) &&
            (message === null || message === void 0 ? void 0 : message.status) !== 'CANCELING' &&
            (message === null || message === void 0 ? void 0 : message.status) !== 'CANCELED') {
            if (intervalId.current) {
                clearInterval(intervalId.current);
                intervalId.current = null;
            }
            intervalId.current = setInterval(async () => {
                const keepPolling = await fn();
                if (!keepPolling) {
                    if (intervalId.current) {
                        clearInterval(intervalId.current);
                        intervalId.current = null;
                    }
                }
            }, pollingInterval);
        }
        else if (intervalId.current) {
            clearInterval(intervalId.current);
            intervalId.current = null;
        }
    };
    reactUse.useEffectOnce(() => {
        polling();
    });
    const chatLocale = nextIntl.useTranslations('chat');
    if (message.status === 'CANCELED') {
        return jsxRuntime.jsx("p", { children: chatLocale('job_terminated') });
    }
    if ((_a = message.imageGenMessageResponse) === null || _a === void 0 ? void 0 : _a.jobId) {
        return jsxRuntime.jsx(ImageGenDisplay, { message: message, showText: showText, showAudio: showAudio });
    }
    if (((_b = message.asyncJobInfo) === null || _b === void 0 ? void 0 : _b.status) === EmbedObjStatus$1.DONE || ((_c = message.asyncJobInfo) === null || _c === void 0 ? void 0 : _c.status) === EmbedObjStatus$1.UNKNOWN) {
        if (message.runningError) {
            return jsxRuntime.jsx(RunningError, { message: message });
        }
        return jsxRuntime.jsx(DefaultDisplay, { message: message, showText: showText, showAudio: showAudio });
    }
    if (((_d = message.asyncJobInfo) === null || _d === void 0 ? void 0 : _d.status) === EmbedObjStatus$1.ERROR) {
        return (jsxRuntime.jsx(MdViewer, { className: "text-critical text-[14px]", content: (_e = message.text) !== null && _e !== void 0 ? _e : '', notParseHTML: message.isLlmBot }));
    }
    if ((_f = message.runningWidgetInfo) === null || _f === void 0 ? void 0 : _f.length) {
        return jsxRuntime.jsx(RunningWidgetInfo, { list: message.runningWidgetInfo });
    }
    return (jsxRuntime.jsxs("div", { className: "flex items-center", children: [jsxRuntime.jsx(Spinner, { size: "xs", className: "text-brand" }), jsxRuntime.jsx(Text, { size: "sm", color: "subtle", className: "ml-2", children: message.text })] }));
}

function Content({ message, showText = true, showAudio = false, latest, source }) {
    var _a;
    const Display = React.useMemo(() => {
        var _a;
        switch (message.type) {
            case 'PENDING_FOR_RESPONSE':
                return LoadingIcon;
            default:
                if (message.type !== 'GREETING' &&
                    ((message.asyncJobInfo &&
                        message.asyncJobInfo.jobId &&
                        message.asyncJobInfo.status !== EmbedObjStatus$1.UNKNOWN) ||
                        ((_a = message.imageGenMessageResponse) === null || _a === void 0 ? void 0 : _a.jobId))) {
                    return AsyncJobDisplay;
                }
                return DefaultDisplay;
        }
    }, [message.asyncJobInfo, (_a = message.imageGenMessageResponse) === null || _a === void 0 ? void 0 : _a.jobId, message.type]);
    return (jsxRuntime.jsx(ContextMenuProvider, { source: source, children: jsxRuntime.jsx("div", { className: "flex gap-3 flex-col", children: jsxRuntime.jsx(Display, { message: message, showText: showText, showAudio: showAudio, latest: latest }) }) }));
}

function EllipsisVerticalIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M10.5 6a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Zm0 6a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Zm0 6a1.5 1.5 0 1 1 3 0 1.5 1.5 0 0 1-3 0Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$4 = /*#__PURE__*/ React__namespace.forwardRef(EllipsisVerticalIcon);

function useDeleteMessage(type, id, getList, deleteSpecifiedMessageId) {
    const t = nextIntl.useTranslations('workshop');
    const [deleting, setDeleting] = reactUse.useToggle(false);
    const { success, error } = useNotification();
    const deleteMessage = async (msgId) => {
        try {
            setDeleting(true);
            const { success: apiSuccess } = await deleteHistory(type, msgId);
            if (apiSuccess) {
                success({
                    content: t('delete_widget_success')
                });
                getList();
                deleteSpecifiedMessageId === null || deleteSpecifiedMessageId === void 0 ? void 0 : deleteSpecifiedMessageId(msgId);
            }
            else {
                error({
                    content: t('delete_widget_error')
                });
            }
        }
        catch (e) {
            console.error(e);
            error({
                content: t('delete_widget_error')
            });
        }
        finally {
            setDeleting(false);
        }
    };
    return {
        deleting,
        deleteMessage
    };
}

function SelectTextModal({ visible, onClose }) {
    const commonLocale = nextIntl.useTranslations('common');
    return (jsxRuntime.jsx(Modal, { contentClassName: "min-h-[85vh]", title: commonLocale('select_text'), modalOnly: false, open: visible, onClose: onClose, children: jsxRuntime.jsx("div", { className: "p-3", children: jsxRuntime.jsx(TextDisplay, { hideMedia: true }) }) }));
}

function Menubar(props) {
    const commonLocale = nextIntl.useTranslations();
    const chatLocale = nextIntl.useTranslations('chat');
    const { type, entityInfo, getList } = React.useContext(StaticContext);
    const { id } = entityInfo;
    const { deleteSpecifiedMessageId } = React.useContext(MessageContext);
    const { actions, message, latest, deleteConfirming, setDeleteConfirming, selectTextVisible, setSelectTextVisible } = useDisplayContext();
    const { className } = props;
    const boundaryEle = isClient() ? document.getElementById('renderer-container') : null;
    const { deleting, deleteMessage } = useDeleteMessage(type, id, getList, deleteSpecifiedMessageId);
    const feedbackGroup = actions.filter(a => a === MenuActionType.Feedback);
    const shareItem = actions.filter(a => a === MenuActionType.Share);
    const copyItem = actions.filter(a => a === MenuActionType.Copy_Message);
    const regenItem = actions.filter(a => a === MenuActionType.Regenerate);
    const editItem = actions.filter(a => a === MenuActionType.Edit);
    const middleSizeExposeItems = React.useMemo(() => {
        if ((message === null || message === void 0 ? void 0 : message.source) === 'OTHER') {
            if (feedbackGroup.length) {
                return feedbackGroup;
            }
            return copyItem;
        }
        return [...shareItem, ...copyItem];
    }, [copyItem, feedbackGroup, message === null || message === void 0 ? void 0 : message.source, shareItem]);
    const largeSizeExposeItems = React.useMemo(() => {
        if ((message === null || message === void 0 ? void 0 : message.source) === 'OTHER') {
            return [...feedbackGroup, ...regenItem, ...editItem, ...copyItem];
        }
        return [...shareItem, ...copyItem];
    }, [copyItem, editItem, feedbackGroup, message === null || message === void 0 ? void 0 : message.source, regenItem, shareItem]);
    const confirmHandler = async () => {
        try {
            await deleteMessage(message.id);
        }
        catch (e) {
            console.error(e);
        }
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("div", { className: cn('mt-2.5 mx-0.5 h-fit', className), children: [jsxRuntime.jsx("div", { className: "lg:hidden", children: jsxRuntime.jsxs(DropdownMenu, { children: [jsxRuntime.jsx(DropdownMenuTrigger, { asChild: true, children: jsxRuntime.jsx(IconButton, { size: "sm", variant: "primary", color: "gray", icon: ForwardRef$4, hoverText: commonLocale('more'), className: "rounded-lg text-default" }) }), jsxRuntime.jsx(DropdownMenuContent, { collisionBoundary: [boundaryEle], children: jsxRuntime.jsx(Actions, { source: "menubar", asMenuItem: true }) })] }) }), jsxRuntime.jsx("div", { className: "hidden lg:flex large:hidden gap-1", children: (message === null || message === void 0 ? void 0 : message.source) === 'USER' ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(DropdownMenu, { children: [jsxRuntime.jsx(DropdownMenuTrigger, { asChild: true, children: jsxRuntime.jsx(IconButton, { size: "sm", variant: "primary", color: "gray", icon: ForwardRef$4, hoverText: commonLocale('more'), className: "rounded-lg text-default" }) }), jsxRuntime.jsx(DropdownMenuContent, { collisionBoundary: [boundaryEle], children: jsxRuntime.jsx(Actions, { specifiedActions: actions, source: "menubar", asMenuItem: true }) })] }), jsxRuntime.jsx(Actions, { specifiedActions: middleSizeExposeItems, source: "menubar" })] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Actions, { specifiedActions: middleSizeExposeItems, source: "menubar" }), jsxRuntime.jsxs(DropdownMenu, { children: [jsxRuntime.jsx(DropdownMenuTrigger, { asChild: true, children: jsxRuntime.jsx(IconButton, { size: "sm", variant: "primary", color: "gray", icon: ForwardRef$4, hoverText: commonLocale('more'), className: "rounded-lg text-default" }) }), jsxRuntime.jsx(DropdownMenuContent, { collisionBoundary: [boundaryEle], children: jsxRuntime.jsx(Actions, { specifiedActions: actions, source: "menubar", asMenuItem: true }) })] })] })) }), jsxRuntime.jsx("div", { className: "hidden large:flex gap-1", children: (message === null || message === void 0 ? void 0 : message.source) === 'USER' ? (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs(DropdownMenu, { children: [jsxRuntime.jsx(DropdownMenuTrigger, { asChild: true, children: jsxRuntime.jsx(IconButton, { size: "sm", variant: "primary", color: "gray", icon: ForwardRef$4, hoverText: commonLocale('more'), className: "rounded-lg text-default" }) }), jsxRuntime.jsx(DropdownMenuContent, { collisionBoundary: [boundaryEle], children: jsxRuntime.jsx(Actions, { specifiedActions: actions, source: "menubar", asMenuItem: true }) })] }), jsxRuntime.jsx(Actions, { specifiedActions: largeSizeExposeItems, source: "menubar" })] })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Actions, { specifiedActions: largeSizeExposeItems, source: "menubar" }), jsxRuntime.jsxs(DropdownMenu, { children: [jsxRuntime.jsx(DropdownMenuTrigger, { asChild: true, children: jsxRuntime.jsx(IconButton, { size: "sm", variant: "primary", color: "gray", icon: ForwardRef$4, hoverText: commonLocale('more'), className: "rounded-lg text-default" }) }), jsxRuntime.jsx(DropdownMenuContent, { collisionBoundary: [boundaryEle], children: jsxRuntime.jsx(Actions, { specifiedActions: actions, source: "menubar", asMenuItem: true }) })] })] })) })] }), deleteConfirming && (jsxRuntime.jsx(Modal, { state: "warning", isNotification: true, open: deleteConfirming, onClose: () => setDeleteConfirming === null || setDeleteConfirming === void 0 ? void 0 : setDeleteConfirming(false), onConfirm: confirmHandler, title: chatLocale('delete_confirmation.header'), description: chatLocale('delete_confirmation.delete_part_content', {
                    num: 1,
                    entity: type
                }), confirmLoading: deleting })), selectTextVisible && (jsxRuntime.jsx(SelectTextModal, { visible: selectTextVisible, onClose: () => {
                    setSelectTextVisible === null || setSelectTextVisible === void 0 ? void 0 : setSelectTextVisible(false);
                } }))] }));
}

function MineMessage() {
    const t = nextIntl.useTranslations('chat');
    const errorT = nextIntl.useTranslations('request.error');
    const { editorMode, share, errorMessageRetry } = React.useContext(MessageContext);
    const { idSet, add, remove } = share || {};
    const { message, contextMenuDisabled } = useDisplayContext();
    const handleIdChecked = (checked) => {
        if (checked) {
            add === null || add === void 0 ? void 0 : add(message.id);
        }
        else {
            remove === null || remove === void 0 ? void 0 : remove(message.id);
        }
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("div", { className: "w-[calc(100%-38px)] ml-[38px] flex gap-1.5", children: [jsxRuntime.jsxs("div", { className: "grow group/menu gap-1.5 flex justify-end", children: [!contextMenuDisabled && (jsxRuntime.jsx(Menubar, { className: clsx__default.default('hidden md:flex md:invisible md:group-hover/menu:visible md:group-focus-within/menu:visible') })), jsxRuntime.jsx("div", { className: "max-w-[303px] md:max-w-[420px] lg:max-w-[476px] large:max-w-[480px] overflow-hidden rounded-2xl rounded-tr-sm min-h-11 py-3 px-4 bg-surface-primary-subtle-hovered", children: jsxRuntime.jsx(Content, { message: message, source: "USER" }) })] }), editorMode === 'SHARE' && (jsxRuntime.jsx("div", { className: "shrink-0 size-8 flex justify-center items-center", children: jsxRuntime.jsx(Checkbox, { variant: "circle", checked: idSet === null || idSet === void 0 ? void 0 : idSet.has(message.id), onCheckedChange: handleIdChecked }) }))] }), ((message === null || message === void 0 ? void 0 : message.status) === 'LOCAL_ERROR' || (message === null || message === void 0 ? void 0 : message.status) === 'NETWORK_ERROR') && (jsxRuntime.jsxs(Alert, { variant: "error", className: "w-full mt-4 md:mt-5 flex-col md:flex-col lg:flex-row", children: [jsxRuntime.jsx(AlertDescription, { children: jsxRuntime.jsxs("div", { className: "flex gap-[6px]", children: [jsxRuntime.jsx(ForwardRef$D, { className: "hidden md:block shrink-0 size-6 text-icon-critical" }), jsxRuntime.jsx(Text, { children: (message === null || message === void 0 ? void 0 : message.status) === 'LOCAL_ERROR' ? errorT('common') : errorT('network') })] }) }), jsxRuntime.jsx(Button$1, { size: "md", color: "error", className: "shrink-0 w-full md:w-fit self-end lg:self-auto", onClick: () => {
                            errorMessageRetry === null || errorMessageRetry === void 0 ? void 0 : errorMessageRetry(message);
                        }, children: t('retry') })] }))] }));
}

function usePromptWidgetAction() {
    const { sendCustomRequest } = React.useContext(MessageContext);
    const promptAction = React.useCallback((callback) => {
        const reqBody = {
            messageType: 'BUTTON_INTERACTION',
            button_id: 'unlock_prompt_widget'
        };
        sendCustomRequest === null || sendCustomRequest === void 0 ? void 0 : sendCustomRequest(reqBody, callback);
    }, [sendCustomRequest]);
    return { promptAction };
}

function useShellCoin() {
    const shellCoins = useUserStore(state => state.shellCoins);
    const exchangePoints = useTaskStore(state => state.exchangePoints);
    const setShellCoins = useUserStore(state => state.setShellCoins);
    const setFrozenShellCoins = useUserStore(state => state.setFrozenShellCoins);
    const setHoldBadges = useTaskStore(state => state.setHoldBadges);
    const setExchangePoints = useTaskStore(state => state.setExchangePoints);
    const [exchanging, setExchanging] = React.useState(false);
    const [badgeToCoinExchanging, setBadgeToCoinExchanging] = React.useState(false);
    const [querying, setQuerying] = React.useState(false);
    const queryShellCoins = async () => {
        try {
            const { success, data } = await getShellCoins();
            if (success) {
                setShellCoins(Number(data.balance));
                setFrozenShellCoins(Number(data.frozenBalance));
            }
        }
        catch (e) {
        }
        finally {
        }
    };
    const queryExchange = async () => {
        try {
            const { success, data } = await getShellCoinExchange();
            if (success) {
                setExchangePoints(data);
            }
        }
        catch (e) {
        }
    };
    const exchange = async () => {
        try {
            setExchanging(true);
            return await exchangeShellCoin();
        }
        catch (e) {
            return {
                success: false
            };
        }
        finally {
            setExchanging(false);
        }
    };
    const getHoldBadges = async () => {
        try {
            setQuerying(true);
            const { data } = await getUserHoldBadge();
            setHoldBadges(data);
        }
        catch (e) {
        }
        finally {
            setQuerying(false);
        }
    };
    const badgeToCoin = async (badges, onClose) => {
        try {
            setBadgeToCoinExchanging(true);
            const { data } = await badgeToShellCoin(badges.map(badge => ({
                badgeType: badge.userBackpackItem.item.subType,
                badgeCount: badge.userBackpackItem.count
            })));
            onClose && onClose(numberArraySum(data.map(d => Number(d.amount))));
        }
        catch (e) {
        }
        finally {
            setBadgeToCoinExchanging(false);
        }
    };
    return {
        shellCoins,
        exchangePoints,
        queryShellCoins,
        queryExchange,
        exchanging,
        exchange,
        badgeToCoinExchanging,
        badgeToCoin,
        querying,
        getHoldBadges,
        getCoinRecords
    };
}

function PromptWidgetUnlockAction() {
    const { entityInfo, partialUpdateDetail } = React.useContext(StaticContext);
    const { sellPrice } = entityInfo;
    const shellCoins = useUserStore(state => state.shellCoins);
    const setShellCoins = useUserStore(state => state.setShellCoins);
    const t = nextIntl.useTranslations('workshop');
    const toggleLoginModal = useGlobalStore(state => state.toggleLoginModal);
    const visitor = useUserStore(state => state.isVisitor);
    const isVisitor = visitor === VisitorEnum.YES;
    const { queryShellCoins } = useShellCoin();
    React.useEffect(() => {
        if (isNullOrUndefined(shellCoins)) {
            queryShellCoins();
        }
    }, [shellCoins]);
    const { promptAction } = usePromptWidgetAction();
    const handleUnlock = React.useCallback(() => {
        if (isVisitor) {
            toggleLoginModal(true);
            return;
        }
        promptAction(() => {
            partialUpdateDetail === null || partialUpdateDetail === void 0 ? void 0 : partialUpdateDetail({ hasUnlocked: true });
            if (Number(sellPrice) !== 0) {
                setShellCoins(shellCoins !== null && shellCoins !== void 0 ? shellCoins : 0 - Number(sellPrice));
            }
        });
    }, [isVisitor, partialUpdateDetail, promptAction, sellPrice, setShellCoins, shellCoins, toggleLoginModal]);
    return (jsxRuntime.jsx(Button$1, { variant: "primary", color: "chat", size: "md", className: "w-fit", onClick: handleUnlock, children: t('unlock_prompt') }));
}

function PromptWidgetViewAction() {
    const { promptAction } = usePromptWidgetAction();
    const t = nextIntl.useTranslations('workshop');
    const handleView = () => {
        promptAction();
    };
    return (jsxRuntime.jsx(Button$1, { variant: "primary", color: "chat", size: "md", className: "w-fit", onClick: handleView, children: t('view_prompt') }));
}

function useButtonClick(actions, btnId, msgId, setFormModalVisible, clickHandler, selectedBot, widgetInfo, buttonContent) {
    const sensors = useSensors();
    const isVisitor = useUserStore(state => state.isVisitor);
    const user = useUserStore(state => state.user);
    const { value: loading, setTrue, setFalse } = usehooksTs.useBoolean(false);
    const [formInteracting, setFormInteracting] = reactUse.useToggle(false);
    const [formSubmitError, setFormSubmitError] = reactUse.useToggle(false);
    const { onCopy } = useCopyClipboard('');
    const router = navigation.useRouter();
    const handleRouteRedirect = React.useCallback((route) => {
        return async () => {
            try {
                router.push(route);
                return await Promise.resolve();
            }
            catch (e) {
                return Promise.reject(e);
            }
        };
    }, [router]);
    const handleCopy = React.useCallback((text) => {
        return async () => {
            onCopy(text);
        };
    }, [router]);
    const onSendSensors = React.useCallback(() => {
        var _a;
        const tagnames = ((_a = selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.tagList) === null || _a === void 0 ? void 0 : _a.map((e) => `${e.label}`)) || [];
        sensors === null || sensors === void 0 ? void 0 : sensors.track('UserSendMessage', Object.assign(Object.assign(Object.assign(Object.assign({ message_type: 'buttonclick', button_name: buttonContent === null || buttonContent === void 0 ? void 0 : buttonContent.text }, ((widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id)
            ? {
                widget_id: widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id,
                widget_name: widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.name
            }
            : {
                bot_id: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.id,
                bot_name: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.name
            })), { chat_platform: 'web2' }), ((tagnames === null || tagnames === void 0 ? void 0 : tagnames.length) > 0 && { tag_name: tagnames })), { bot_battery_cost: parseInt((buttonContent === null || buttonContent === void 0 ? void 0 : buttonContent.iconLabel) || '') || 0, user_membership_type: isVisitor ? '0' : (user === null || user === void 0 ? void 0 : user.isGenesisPasscard) || (user === null || user === void 0 ? void 0 : user.isPasscard) ? '3' : `${user === null || user === void 0 ? void 0 : user.level}` }));
    }, [
        buttonContent === null || buttonContent === void 0 ? void 0 : buttonContent.iconLabel,
        buttonContent === null || buttonContent === void 0 ? void 0 : buttonContent.text,
        isVisitor,
        selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.id,
        selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.name,
        selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.tagList,
        sensors,
        user === null || user === void 0 ? void 0 : user.isGenesisPasscard,
        user === null || user === void 0 ? void 0 : user.isPasscard,
        user === null || user === void 0 ? void 0 : user.level,
        widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id,
        widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.name
    ]);
    const handleSendMessage = React.useCallback((action, successCb) => {
        return async () => {
            var _a, _b, _c, _d, _e, _f;
            try {
                if (((_a = action.interactionInput) === null || _a === void 0 ? void 0 : _a.displayType) ===
                    MessageComponentsButtonActionInteractionInputDisplayTypeEnum.NOTHING) {
                    setTrue();
                }
                onSendSensors();
                clickHandler === null || clickHandler === void 0 ? void 0 : clickHandler({
                    actionType: action.action,
                    buttonId: btnId,
                    msgId,
                    text: ((_b = action.interactionInput) === null || _b === void 0 ? void 0 : _b.displayType) ===
                        MessageComponentsButtonActionInteractionInputDisplayTypeEnum.NOTHING
                        ? undefined
                        : (_d = (_c = action.interactionInput) === null || _c === void 0 ? void 0 : _c.content) !== null && _d !== void 0 ? _d : (_e = action.interactionInput) === null || _e === void 0 ? void 0 : _e.slashCommandInput.name,
                    imSlashCommandInput: (_f = action.interactionInput) === null || _f === void 0 ? void 0 : _f.slashCommandInput
                });
                return await Promise.resolve();
            }
            catch (e) {
                setFalse();
                return Promise.reject(e);
            }
        };
    }, [onSendSensors, clickHandler, btnId, msgId, setFalse, setTrue]);
    const handlePopupForm = React.useCallback((action) => {
        return async () => {
            try {
                setFormModalVisible(action);
                return await Promise.resolve();
            }
            catch (e) {
                return Promise.reject(e);
            }
        };
    }, [setFormModalVisible]);
    React.useCallback(() => {
        setFalse();
        setFormInteracting(false);
    }, [setFalse, setFormInteracting]);
    React.useCallback(() => {
        setFalse();
        setFormInteracting(false);
        setFormSubmitError(true);
    }, [setFalse, setFormInteracting, setFormSubmitError]);
    const handleFormSubmit = React.useCallback((action, params, successCb) => {
        var _a;
        try {
            setTrue();
            setFormInteracting(true);
            onSendSensors();
            clickHandler === null || clickHandler === void 0 ? void 0 : clickHandler({
                actionType: action.action,
                buttonId: btnId,
                msgId,
                text: (_a = action.componentInput) === null || _a === void 0 ? void 0 : _a.name,
                componentInputMessage: JSON.stringify(params !== null && params !== void 0 ? params : {})
            }, successCb);
            return Promise.resolve();
        }
        catch (e) {
            setFalse();
            setFormInteracting(false);
            return Promise.reject(e);
        }
        finally {
            setFalse();
        }
    }, [btnId, clickHandler, msgId, onSendSensors, setFalse, setFormInteracting, setTrue]);
    const clickFn = React.useCallback((action) => {
        switch (action.action) {
            case MessageComponentsButtonActionTypeEnum.JUMP_LINK:
                return handleRouteRedirect(action.actionLink);
            case MessageComponentsButtonActionTypeEnum.INTERACTION:
                return handleSendMessage(action);
            case MessageComponentsButtonActionTypeEnum.CLIPBOARD:
                return handleCopy(action.clipboardContent);
            case MessageComponentsButtonActionTypeEnum.POP_UP_FORM:
                sensors === null || sensors === void 0 ? void 0 : sensors.track('Close_Button_PopUp', Object.assign({ button_name: buttonContent === null || buttonContent === void 0 ? void 0 : buttonContent.text }, ((widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id)
                    ? {
                        widget_id: widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id,
                        widget_name: widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.name
                    }
                    : {
                        bot_id: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.id,
                        bot_name: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.name
                    })));
                return handlePopupForm(action);
            default:
                return async () => {
                    return Promise.reject('no matched branch');
                };
        }
    }, [
        handleRouteRedirect,
        handleSendMessage,
        handleCopy,
        sensors,
        buttonContent === null || buttonContent === void 0 ? void 0 : buttonContent.text,
        widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id,
        widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.name,
        selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.id,
        selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.name,
        handlePopupForm
    ]);
    const executeActions = React.useCallback(async (actionsQueue) => {
        if (actionsQueue.length === 0)
            return;
        const action = actionsQueue.shift();
        try {
            const actionFn = clickFn(action);
            await actionFn();
            executeActions(actionsQueue);
        }
        catch (error) {
            console.error('Error executing action: ', error);
        }
    }, [clickFn]);
    const handleClick = React.useCallback(async () => {
        await executeActions([...actions]);
    }, [actions, executeActions]);
    return { loading, handleClick, handleFormSubmit, formInteracting, formSubmitError, setFormSubmitError };
}

const DEFAULT_STATE = {
    luiButtonGuideClicked: false
};
const createFlagSlice = (set, get) => {
    return Object.assign(Object.assign({}, DEFAULT_STATE), { setLuiButtonGuideClicked(value) {
            set(state => {
                state.luiButtonGuideClicked = value;
            });
        } });
};
const persistConfig = {
    name: 'flag-storage',
    storage: createJSONStorage(() => localStorage),
    partialize: state => ({
        luiButtonGuideClicked: state.luiButtonGuideClicked
    }),
    merge: (persistedState, currentState) => (Object.assign(Object.assign({}, currentState), { luiButtonGuideClicked: persistedState.luiButtonGuideClicked }))
};
const useFlagStore = zustand.create()(immer(devtools(persist(createFlagSlice, persistConfig), { store: 'flag' })));

const LUIButtonInteractionContext = React.createContext({
    clickFn: async () => { },
    msgId: ''
});

function ButtonNeedDoubleConfirmation({ children, title, description, onConfirm, clicked }) {
    const [visible, setVisible] = reactUse.useToggle(false);
    const [loading, setLoading] = reactUse.useToggle(false);
    const cancelRef = React.useRef(null);
    const t = nextIntl.useTranslations('common');
    const handleConfirm = async () => {
        try {
            setLoading(true);
            await onConfirm();
            setVisible(false);
        }
        catch (e) {
            console.error(e);
        }
        finally {
            setLoading(false);
        }
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { onClick: () => {
                    setVisible(true);
                    clicked();
                }, children: children }), jsxRuntime.jsx(react.AlertDialog, { isOpen: visible, leastDestructiveRef: cancelRef, onClose: () => setVisible(false), isCentered: true, children: jsxRuntime.jsx(react.AlertDialogOverlay, { className: "shadow-modal-default", children: jsxRuntime.jsxs(react.AlertDialogContent, { className: "bg-surface-container-default text-default", children: [jsxRuntime.jsx(react.AlertDialogHeader, { fontSize: "2xl", fontWeight: "bold", padding: "20px", children: title }), jsxRuntime.jsx(react.Divider, { className: "border-default" }), jsxRuntime.jsx(react.AlertDialogBody, { px: "20px", py: "16px", fontSize: "16px", lineHeight: "24px", children: description }), jsxRuntime.jsx(react.Divider, { className: "border-default" }), jsxRuntime.jsxs(react.AlertDialogFooter, { p: "16px", display: "flex", gap: "16px", children: [jsxRuntime.jsx(react.Button, { ref: cancelRef, onClick: () => setVisible(false), width: "100%", h: "36px", px: "12px", py: "8px", borderRadius: "full", color: "var(--text-brand)", border: "1px solid var(--text-brand)", _hover: {
                                            backgroundColor: 'transparent'
                                        }, children: t('cancel') }), jsxRuntime.jsx(react.Button, { onClick: handleConfirm, width: "100%", h: "36px", px: "12px", py: "8px", borderRadius: "full", backgroundColor: "var(--text-brand)", className: "bg-surface-primary-default", color: "white", _hover: {
                                            backgroundColor: 'var(--text-brand)'
                                        }, isLoading: loading, children: t('confirm') })] })] }) }) })] }));
}
var ButtonNeedDoubleConfirmation$1 = React.memo(ButtonNeedDoubleConfirmation);

function LuiButtonDisplay({ content, style, disabled, loading = false, onClick, energy: restEnergy }) {
    var _a, _b;
    const { resolvedTheme } = nextThemes.useTheme();
    nextIntl.useTranslations('common');
    useNotification();
    const isDark = resolvedTheme === 'dark';
    Number(((_a = content.iconLabel) === null || _a === void 0 ? void 0 : _a.replace('+', '')) || 0);
    const handleClick = () => {
        if (!onClick) {
            return;
        }
        onClick();
    };
    return (jsxRuntime.jsx("button", { type: "button", disabled: disabled || loading, className: "min-w-9 shadow-button_shadow rounded-3xl px-4 py-2 flex space-x-1.5 justify-center items-center disabled:cursor-not-allowed disabled:opacity-70", style: {
            background: isDark ? style.darkModeBackgroundColorHex : style.backgroundColorHex,
            color: isDark ? style.darkModeFontColorHex : style.fontColorHex,
            borderWidth: style.borderColorHex ? '1px' : 'none',
            borderStyle: 'solid',
            borderColor: isDark ? style.darkModeBorderColorHex : style.borderColorHex
        }, onClick: handleClick, children: loading ? (jsxRuntime.jsx(LoadingIcon, {})) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [content.direction && content.direction === MessageComponentsButtonContentDirectionEnum.LEFT && (jsxRuntime.jsx(ForwardRef$R, { className: "w-5 h-5 shrink-0" })), jsxRuntime.jsx("span", { className: "text-sm text-left", children: content.text }), content.iconUrl && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { className: "h-3 border-r-[0.5px] shrink-0 pl-0.5", style: {
                                borderColor: isDark ? style.darkModeIconLineColorHex : style.iconLineColorHex
                            } }), jsxRuntime.jsxs("div", { className: "flex space-x-0.5 items-center shrink-0 text-xs font-medium", children: [jsxRuntime.jsx(Image__default.default, { alt: "button icon", src: content.iconUrl, width: 16, height: 16, className: "w-4 h-4 rounded-[4px]" }), jsxRuntime.jsx("span", { className: "tracking-widest", children: (_b = content.iconLabel) !== null && _b !== void 0 ? _b : '' })] })] })), content.direction && content.direction === MessageComponentsButtonContentDirectionEnum.RIGHT && (jsxRuntime.jsx(ForwardRef$P, { className: "w-5 h-5 shrink-0" }))] })) }));
}
function Display(props) {
    const { content } = props;
    return content.description ? (jsxRuntime.jsx(Tooltip, { showArrow: false, description: content.description, children: jsxRuntime.jsx(LuiButtonDisplay, Object.assign({}, props)) })) : (jsxRuntime.jsx(LuiButtonDisplay, Object.assign({}, props)));
}

function SaveTipModal({ isOpen, onClose, onConfirmed }) {
    const t = nextIntl.useTranslations('chat.replicate');
    return (jsxRuntime.jsx(Modal, { overlayClassName: "z-[100]", contentClassName: "z-[110]", state: "warning", isNotification: true, open: isOpen, onClose: onClose, title: t('save_tip_title'), description: t('save_tip_content'), onConfirm: () => {
            onConfirmed(() => { });
        } }));
}

function FormListSkeleton({ column = 2 }) {
    return (jsxRuntime.jsx("div", { className: "w-full overflow-hidden", children: jsxRuntime.jsxs("div", { className: "w-full flex flex-col h-full", children: [jsxRuntime.jsx(Skeleton, { className: "w-1/3 h-5 mt-4 rounded-lg" }), jsxRuntime.jsx(Skeleton, { className: "w-wull h-[46px] mt-1.5 rounded-lg" }), jsxRuntime.jsx(Skeleton, { className: "w-1/3 h-5 mt-4 rounded-lg" }), jsxRuntime.jsx(Skeleton, { className: "w-wull h-[96px] mt-1.5 rounded-lg" })] }) }));
}

const RenderForm$1 = dynamic__default.default(() => Promise.resolve().then(function () { return LUIRenderForm; }), {
    loading: () => jsxRuntime.jsx(FormListSkeleton, {}),
    ssr: false
});
function LUIFormModal({ params, isOpen, setOpen, isMobile, onSubmit: handleSubmition, loading, formSubmitError, setFormSubmitError }) {
    const p = React.useMemo(() => {
        var _a;
        return (Object.assign(Object.assign({}, params), { componentsInput: (_a = params.componentsInput) === null || _a === void 0 ? void 0 : _a.map((item) => {
                var _a, _b;
                let inputType = '';
                let defaultValue = '';
                let options = [];
                const props = {};
                let supportedFileTypes = [];
                switch (item.type) {
                    case 'BOT_IM_COMPONENT_INPUT_TYPE_FILE_UPLOAD':
                        inputType = 'upload';
                        supportedFileTypes = item.supportedFileTypes;
                        break;
                    case 'BOT_IM_COMPONENT_INPUT_TYPE_AUDIO_UPLOAD':
                        inputType = 'upload';
                        supportedFileTypes = ['MESSAGE_METADATA_TYPE_AUDIO_FILE'];
                        break;
                    case 'BOT_IM_COMPONENT_INPUT_TYPE_VIDEO_UPLOAD':
                        inputType = 'upload';
                        supportedFileTypes = ['MESSAGE_METADATA_TYPE_VIDEO_FILE'];
                        break;
                    case 'BOT_IM_COMPONENT_INPUT_TYPE_IMAGE_UPLOAD':
                        inputType = 'upload';
                        supportedFileTypes = ['MESSAGE_METADATA_TYPE_IMAGE_FILE'];
                        break;
                    case 'BOT_IM_COMPONENT_INPUT_TYPE_TEXT_UPLOAD':
                        inputType = 'upload';
                        supportedFileTypes = ['MESSAGE_METADATA_TYPE_TEXT_FILE'];
                        break;
                    case 'BOT_IM_COMPONENT_INPUT_TYPE_TEXT_INPUT':
                        inputType = 'textarea';
                        defaultValue = item.stringDefault;
                        props.maxLength = item.stringCharLengthLimitation || 1500;
                        break;
                    case 'BOT_IM_COMPONENT_INPUT_TYPE_TEXT_SELECTOR':
                        inputType = 'select';
                        defaultValue = item.textSelectorDefault;
                        options = (_a = item.textSelectorAllOf) === null || _a === void 0 ? void 0 : _a.map((e) => {
                            return {
                                label: e.label || e.value,
                                value: e.value,
                                iconUrl: e.iconUrl
                            };
                        });
                        break;
                    case 'BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_INPUT':
                        inputType = item.hasNumberLimitation ? 'numberSlider' : 'numberInput';
                        defaultValue = item.numberDefault;
                        props.maxLength = item.numberMax;
                        props.minLength = item.numberMin;
                        break;
                    case 'BOT_IM_COMPONENT_INPUT_TYPE_INTEGER_INPUT':
                        inputType = item.hasIntegerLimitation ? 'interSlider' : 'interInput';
                        defaultValue = item.integerDefault;
                        props.maxLength = item.integerMax;
                        props.minLength = item.integerMin;
                        break;
                    case 'BOT_IM_COMPONENT_INPUT_TYPE_CHECKBOX':
                        inputType = 'checkbox';
                        defaultValue = item.booleanDefault;
                        break;
                    case 'BOT_IM_COMPONENT_INPUT_TYPE_NUMBER_SELECTOR':
                        inputType = 'numberSelect';
                        defaultValue = item.numberSelectorDefault;
                        options = (_b = item.numberSelectorAllOf) === null || _b === void 0 ? void 0 : _b.map((e) => {
                            return {
                                label: e.label || e.value,
                                value: e.value,
                                iconUrl: e.iconUrl
                            };
                        });
                        break;
                    case 'BOT_IM_COMPONENT_INPUT_TYPE_CODE_EDITOR':
                        inputType = 'codeEditor';
                        defaultValue = item.stringDefault;
                        break;
                }
                return Object.assign(Object.assign({}, item), { id: item.fieldName, serverType: item.type, props, rules: props, type: inputType, defaultValue,
                    options,
                    supportedFileTypes });
            }) }));
    }, [params]);
    const energy = useUserStore(state => state.energy);
    const isVisitor = useUserStore(state => state.isVisitor);
    const batteryCost = params.energyConsumePerUse;
    const noEnoughEnergy = isVisitor === 2 && energy < batteryCost;
    const chatT = nextIntl.useTranslations('chat');
    const [isSaveTipOpen, setSaveTipOpen] = React.useState(false);
    const isEditedRef = React.useRef(false);
    const [isCanSave, setIsCanSave] = React.useState(true);
    const [isModalOpen, setModaOpen] = React.useState(false);
    const [submitting, setSubmitting] = reactUse.useToggle(false);
    const componentsFunction = p.componentsFunction || [];
    const componentsInput = React.useMemo(() => p.componentsInput || [], [p.componentsInput]);
    const defaultValues = React.useMemo(() => {
        const values = {};
        componentsInput === null || componentsInput === void 0 ? void 0 : componentsInput.forEach((item) => {
            var _a, _b;
            values[item.fieldName] = (_a = item.defaultValue) !== null && _a !== void 0 ? _a : '';
            if (item.type === 'upload') {
                values[item.fieldName] = (_b = item.fileDefaultParam) !== null && _b !== void 0 ? _b : '';
                values[`x_ms_name_${item.fieldName}`] = '';
                values[`x_ms_size_${item.fieldName}`] = '';
            }
        });
        return values;
    }, [componentsInput]);
    const { control, setValue, watch, reset, register, getValues, clearErrors, setError, handleSubmit, formState: { errors, isSubmitting } } = reactHookForm.useForm({
        defaultValues
    });
    const setCanSaveHandle = () => {
        let canSave = true;
        componentsInput === null || componentsInput === void 0 ? void 0 : componentsInput.forEach((item) => {
            if (canSave && item.isRequired) {
                if (!item.defaultValue) {
                    canSave = false;
                }
            }
        });
        setIsCanSave(canSave);
    };
    React.useEffect(() => {
        const subscription = watch((value, { name, type }) => {
            const isEdit = !isEqual__default.default(defaultValues, value);
            isEditedRef.current = isEdit;
            let canSave = true;
            componentsInput === null || componentsInput === void 0 ? void 0 : componentsInput.forEach((item) => {
                if (canSave && item.isRequired && !value[item.id]) {
                    canSave = false;
                }
            });
            setIsCanSave(canSave);
        });
        return () => subscription.unsubscribe();
    }, [watch]);
    const timerRef = React.useRef(null);
    reactUse.useEffectOnce(() => {
        setCanSaveHandle();
        if (timerRef.current) {
            clearTimeout(timerRef.current);
        }
        return () => {
            if (timerRef.current) {
                clearTimeout(timerRef.current);
            }
        };
    });
    const onSubmit = async (values) => {
        const params = {};
        componentsInput === null || componentsInput === void 0 ? void 0 : componentsInput.map((item) => {
            params[item.fieldName] = item.type === 'checkbox' ? values[item.fieldName] !== false : values[item.fieldName];
            if (item.type === 'upload') {
                if (!values[item.fieldName]) {
                    delete params[item.fieldName];
                }
                else {
                    params[`x_ms_name_${item.fieldName}`] = values[`x_ms_name_${item.fieldName}`];
                    params[`x_ms_size_${item.fieldName}`] = values[`x_ms_size_${item.fieldName}`];
                }
            }
        });
        setOpen(false);
        setSubmitting(true);
        try {
            await handleSubmition(params);
        }
        catch (e) {
            setFormSubmitError(true);
        }
        finally {
            setSubmitting(false);
        }
    };
    const onSaveTipClose = () => {
        setSaveTipOpen(false);
    };
    const onSaveTipConfirm = () => {
        setSaveTipOpen(false);
        setOpen(false);
    };
    const handleDrawerClose = () => {
        if (isEditedRef.current && isCanSave) {
            setSaveTipOpen(true);
        }
        else {
            setOpen(false);
        }
        setFormSubmitError(false);
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(react.Modal, { isOpen: isOpen, isCentered: true, onClose: handleDrawerClose, size: isMobile ? 'full' : '', children: jsxRuntime.jsx(react.ModalOverlay, { className: "bg-alpha-mask-desktop z-[49]", children: jsxRuntime.jsxs(react.ModalContent, { className: clsx__default.default('max-w-[768px] max-h-[620px] m-0 bg-surface-default rounded-[24px] flex items-center z-[49]', isMobile ? 'rounded-none' : ''), style: {
                            boxShadow: '0px 0px 40px 0px rgba(0, 0, 0, 0.10)'
                        }, children: [!isMobile && (jsxRuntime.jsx(IconButton, { icon: ForwardRef$j, size: "md", variant: "ghost", color: "default", className: "absolute top-4 right-4 text-subtle", onClick: handleDrawerClose })), jsxRuntime.jsxs("div", { className: clsx__default.default('py-4 px-6 border-b border-default text-default w-full', isMobile ? 'flex flex-row justify-between items-center' : ''), children: [jsxRuntime.jsx("h1", { className: clsx__default.default('text-2xl line-clamp-1', isMobile ? 'max-w-[80%]' : ''), children: params.name }), isMobile &&
                                        (componentsFunction === null || componentsFunction === void 0 ? void 0 : componentsFunction.map((item) => {
                                            if (item.functionName === 'getImageInfo') {
                                                return (jsxRuntime.jsxs(Button$1, { variant: "outline", color: "brand", className: "ml-1 grow shrink-0 flex justify-end self-end flex-row flex-nowrap", onClick: () => setModaOpen(true), children: [jsxRuntime.jsx(ForwardRef$N, { className: "w-5 h-5 text-brand mr-1.5" }), " ", chatT('panel.get_imginfo')] }, `mob_btn_${item.functionName}`));
                                            }
                                        })), !isMobile && jsxRuntime.jsx("p", { className: "text-sm", children: params.description })] }), jsxRuntime.jsx("div", { className: "w-full px-6 py-3 overflow-y-auto text-default flex-grow", children: jsxRuntime.jsx("form", { onSubmit: handleSubmit(onSubmit), id: "hook-form", className: "space-y-4", children: componentsInput.map((formEle, index) => {
                                        const anyErrors = errors;
                                        if (formEle.isRequired && formEle.value == '') {
                                            setError(formEle.id, { type: 'required' });
                                        }
                                        return (jsxRuntime.jsx(RenderForm$1, { defaultValues: defaultValues, formEle: formEle, control: control, errors: anyErrors[formEle.id], setFormValue: setValue, register: register, clearErrors: clearErrors }, formEle.id));
                                    }) }) }), jsxRuntime.jsxs(react.ModalFooter, { className: "border-t border-default flex  items-center py-4 px-6 w-full justify-between", children: [jsxRuntime.jsxs("div", { className: "flex", children: [!isMobile &&
                                                (componentsFunction === null || componentsFunction === void 0 ? void 0 : componentsFunction.map((item) => {
                                                    if (item.functionName === 'getImageInfo') {
                                                        return (jsxRuntime.jsxs(Button$1, { variant: "outline", color: "brand", onClick: () => setModaOpen(true), children: [jsxRuntime.jsx(ForwardRef$N, { className: "w-5 h-5 text-brand mr-1.5" }), " ", chatT('panel.get_imginfo')] }, `btn_${item.functionName}`));
                                                    }
                                                })), isMobile && (jsxRuntime.jsx(react.Button, { variant: "outline", className: "border-default rounded-full text-default font-normal px-6", onClick: handleDrawerClose, children: chatT('cancel') }))] }), jsxRuntime.jsxs(Button$1, { variant: "primary", className: clsx__default.default('min-w-[158px]', isMobile ? 'grow shrink-0 ml-3' : '', !isCanSave ? 'opacity-70' : ''), type: "submit", form: "hook-form", disabled: noEnoughEnergy, children: [params.saveButtonContent, !!params.energyConsumePerUse && (jsxRuntime.jsxs("div", { className: "ml-1.5 flex flex-row justify-center items-center", children: [jsxRuntime.jsx(Image__default.default, { src: getAssetsUrl('image/website/icon/20240826/energy.png'), alt: "energy", width: 16, height: 16, className: "size-4 shrink-0" }), jsxRuntime.jsx("span", { className: "text-xs font-semibold text-white ml-[2px]", children: params.energyConsumePerUse })] }))] })] })] }) }) }), isSaveTipOpen && jsxRuntime.jsx(SaveTipModal, { isOpen: isSaveTipOpen, onClose: onSaveTipClose, onConfirmed: onSaveTipConfirm })] }));
}
var LUIFormModal$1 = React.memo(LUIFormModal);

function Button({ buttonProps, index, rowIndex, latest, disabled }) {
    const { buttonId, actions, doubleCheck } = buttonProps;
    const { isMobile } = usePathLocale();
    const { value: formModalVisible, setTrue, setValue } = usehooksTs.useBoolean(false);
    const [params, setParams] = React.useState();
    const [formAction, setFormAction] = React.useState();
    const toggleLoginModal = useGlobalStore(state => state.toggleLoginModal);
    const isVisitor = useUserStore(state => state.isVisitor);
    const luiButtonGuideClicked = useFlagStore(state => state.luiButtonGuideClicked);
    const setLuiButtonGuideClicked = useFlagStore(state => state.setLuiButtonGuideClicked);
    const visitor = useUserStore(state => state.isVisitor);
    const [clickLoading, setClickLoading] = React.useState(false);
    const energy = useUserStore(state => state.energy);
    const chatLocale = nextIntl.useTranslations('chat');
    const containerEle = isClient() ? document.getElementById('message-box') : null;
    const boundaryEle = isClient() ? document.getElementById('renderer-container') : null;
    const { clickFn, msgId, selectedBot, widgetInfo } = React.useContext(LUIButtonInteractionContext);
    const handleOpenFormModal = (action) => {
        setFormAction(action);
        setParams(action.componentInput);
        setTrue();
    };
    const { loading, handleClick, handleFormSubmit, formInteracting, formSubmitError, setFormSubmitError } = useButtonClick(actions, buttonId, msgId, handleOpenFormModal, clickFn, selectedBot, widgetInfo, buttonProps.content);
    const formSubmitionHandler = React.useCallback(async (params, successCb) => {
        return handleFormSubmit(formAction, params, successCb);
    }, [formAction, handleFormSubmit]);
    const onClickWithAuth = async () => {
        setClickLoading(true);
        if (visitor === VisitorEnum.NO) {
            await handleClick();
        }
        else {
            toggleLoginModal(true);
        }
        setClickLoading(false);
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(Popover, { variant: "message", content: jsxRuntime.jsxs("div", { className: "flex flex-col gap-1 relative", children: [jsxRuntime.jsx(ForwardRef$j, { onClick: () => setLuiButtonGuideClicked(true), className: "absolute top-0 right-0 size-[18px] text-[var(--white-70)] cursor-pointer" }), jsxRuntime.jsx("p", { className: "text-base", children: chatLocale('guidance.title') }), jsxRuntime.jsx("p", { className: "text-sm", children: chatLocale('guidance.content') })] }), open: !luiButtonGuideClicked, showArrow: true, side: "bottom", align: "start", className: "mx-0 w-[320px]", container: containerEle, collisionBoundary: [boundaryEle], disabled: !(!luiButtonGuideClicked && latest && index === 0 && rowIndex === 0 && isVisitor === VisitorEnum.NO), children: doubleCheck.isNeedDoubleCheck ? (jsxRuntime.jsx(ButtonNeedDoubleConfirmation$1, { onConfirm: onClickWithAuth, title: doubleCheck.title, description: doubleCheck.description, clicked: () => setLuiButtonGuideClicked(true), children: jsxRuntime.jsx(Display, { content: buttonProps.content, style: buttonProps.style, disabled: disabled || buttonProps.disabled, loading: loading || clickLoading, energy: energy }) })) : (jsxRuntime.jsx(Display, { content: buttonProps.content, style: buttonProps.style, disabled: disabled || buttonProps.disabled, onClick: () => {
                        setLuiButtonGuideClicked(true);
                        onClickWithAuth();
                    }, loading: loading || clickLoading, energy: energy })) }), formModalVisible && params && (jsxRuntime.jsx(LUIFormModal$1, { isOpen: formModalVisible, setOpen: setValue, params: params, isMobile: isMobile, onSubmit: formSubmitionHandler, loading: formInteracting, formSubmitError: formSubmitError, setFormSubmitError: setFormSubmitError }))] }));
}

function Row({ row, rowIndex, latest, disabled }) {
    return (jsxRuntime.jsx("div", { className: "w-full flex flex-wrap gap-3", children: row.components.map((button, index) => button.button && (jsxRuntime.jsx(Button, { rowIndex: rowIndex, buttonProps: button.button, index: index, latest: latest, disabled: disabled }, index))) }));
}

function Rows({ rows, latest, disabled }) {
    return (jsxRuntime.jsx("div", { className: "space-y-3", children: rows.map((row, index) => (jsxRuntime.jsx(Row, { row: row, rowIndex: index, latest: latest, disabled: disabled }, index))) }));
}

function Container({ latest, component, disabled = false }) {
    if (!component)
        return null;
    return jsxRuntime.jsx(Rows, { rows: component.components, latest: latest, disabled: disabled });
}

function useEditMessage(messageId) {
    const { partialUpdateMessage } = React.useContext(MessageContext);
    const [updating, setUpdating] = reactUse.useBoolean(false);
    const { error } = useNotification();
    const onEditMessage = async (content, successCb) => {
        try {
            setUpdating(true);
            const { success, msg } = await editMessage(messageId, content);
            if (success) {
                partialUpdateMessage === null || partialUpdateMessage === void 0 ? void 0 : partialUpdateMessage(messageId, {
                    text: content,
                    audioUrl: ''
                });
                successCb();
            }
            else {
                error({
                    content: msg !== null && msg !== void 0 ? msg : ''
                });
            }
        }
        catch (e) {
        }
        finally {
            setUpdating(false);
        }
    };
    return {
        updating,
        onEditMessage
    };
}

function MessageEditor({ message, virtuosoRef }) {
    var _a;
    const textareaRef = React.useRef(null);
    const { entityInfo, chatSetting } = React.useContext(StaticContext);
    const { maxTokens } = entityInfo;
    const { scrollToBottom } = React.useContext(MessageContext);
    const isMobile = !useGlobalStore(state => state.isMobile);
    const initSendTimestamp = React.useRef(scrollToBottom);
    const commonLocale = nextIntl.useTranslations('common');
    const { setDisplayMode, isTextDisplayException } = useDisplayContext();
    const [text, setText] = React.useState((_a = message.text) !== null && _a !== void 0 ? _a : '');
    const { updating, onEditMessage } = useEditMessage(message.id);
    const [tokens, setTokens] = React.useState(0);
    const tokenExceeded = React.useMemo(() => {
        return tokens > (maxTokens || 1500);
    }, [maxTokens, tokens]);
    const noChanges = React.useMemo(() => {
        return text === (message === null || message === void 0 ? void 0 : message.text);
    }, [message === null || message === void 0 ? void 0 : message.text, text]);
    const onExitEditMode = () => {
        setDisplayMode('NORMAL');
    };
    const onConfirm = () => {
        onEditMessage(text, onExitEditMode);
    };
    const updateTokenLen = async (value) => {
        getTokenCount(value).then(res => setTokens(res));
    };
    const checkIfScrollNeeded = (smooth = true) => {
        var _a, _b;
        const location = (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.getScrollLocation();
        if (location) {
            const { bottomOffset, listOffset, scrollHeight, visibleListHeight } = location;
            const bottomDistance = scrollHeight - visibleListHeight + bottomOffset + listOffset;
            if (bottomDistance > 0) {
                (_b = virtuosoRef.current) === null || _b === void 0 ? void 0 : _b.scrollIntoView({
                    index: 'LAST',
                    align: 'end',
                    behavior: smooth ? 'smooth' : 'auto'
                });
            }
        }
    };
    React.useEffect(() => {
        if (initSendTimestamp.current !== scrollToBottom) {
            onExitEditMode();
        }
    }, [scrollToBottom]);
    React.useEffect(() => {
        if ((chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn) === false && !isTextDisplayException) {
            onExitEditMode();
        }
    }, [chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn]);
    React.useEffect(() => {
        updateTokenLen(text);
    }, [text]);
    reactUse.useEffectOnce(() => {
        var _a;
        (_a = textareaRef.current) === null || _a === void 0 ? void 0 : _a.setSelectionRange(text.length, text.length);
        setTimeout(() => {
            checkIfScrollNeeded(false);
        }, 100);
    });
    return (jsxRuntime.jsxs("div", { className: "min-w-12 w-[560px] max-w-full md:max-w-[460px] lg:max-w-[476px] large:max-w-[560px] overflow-hidden flex flex-col gap-3 p-1", children: [jsxRuntime.jsxs("div", { className: "w-full relative", children: [jsxRuntime.jsx(TextareaAutosize__default.default, { ref: textareaRef, rows: 1, value: text, onChange: e => setText(e.target.value), autoFocus: true, className: clsx__default.default('min-h-[69px] max-h-[226px] resize-none w-full p-3 pb-10 rounded-lg rounded-tl-sm border border-default bg-surface-search-field shadow-background-default text-sm text-default', 'ring-offset-surface-default hover:border-hovered hover:bg-surface-subtle', 'aria-[invalid=true]:border-critical aria-[invalid=true]:hover:border-surface-critical-hovered aria-[invalid=true]:hover:bg-surface-accent-red-subtlest aria-[invalid=true]:focus-visible:ring-error', 'file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-subtler focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-brand focus-visible:ring-offset-1 disabled:cursor-not-allowed disabled:opacity-30', tokenExceeded &&
                            'border-critical hover:border-critical hover:bg-surface-accent-red-subtlest focus-visible:ring-error'), onHeightChange: () => checkIfScrollNeeded() }), jsxRuntime.jsx("div", { className: "absolute right-3 bottom-3", children: jsxRuntime.jsxs(Text, { size: "xs", color: "subtlest", className: "bg-surface-default px-2 py-1 rounded-xl", children: [tokens, "/", maxTokens || 1500, " Tokens"] }) })] }), jsxRuntime.jsxs("div", { className: "w-full flex justify-end gap-3", children: [jsxRuntime.jsx(Button$1, { variant: "outline", color: "default", size: isMobile ? 'sm' : 'md', disabled: updating, onClick: onExitEditMode, children: commonLocale('cancel') }), jsxRuntime.jsx(Button$1, { variant: "primary", color: "brand", size: isMobile ? 'sm' : 'md', onClick: onConfirm, disabled: !text || tokenExceeded || noChanges, loading: updating, children: commonLocale('confirm') })] })] }));
}

function ChevronLeftIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M11.78 5.22a.75.75 0 0 1 0 1.06L8.06 10l3.72 3.72a.75.75 0 1 1-1.06 1.06l-4.25-4.25a.75.75 0 0 1 0-1.06l4.25-4.25a.75.75 0 0 1 1.06 0Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$3 = /*#__PURE__*/ React__namespace.forwardRef(ChevronLeftIcon);

function ChevronRightIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    fillRule: "evenodd",
    d: "M8.22 5.22a.75.75 0 0 1 1.06 0l4.25 4.25a.75.75 0 0 1 0 1.06l-4.25 4.25a.75.75 0 0 1-1.06-1.06L11.94 10 8.22 6.28a.75.75 0 0 1 0-1.06Z",
    clipRule: "evenodd"
  }));
}
const ForwardRef$2 = /*#__PURE__*/ React__namespace.forwardRef(ChevronRightIcon);

function MessageSwitcher({ width, customClass }) {
    var _a, _b;
    const { message, totalMessages, currentMessageIndex, setCurrentMessageIndex, displayMode } = useDisplayContext();
    const messageLen = ((_b = (_a = message === null || message === void 0 ? void 0 : message.regeneratedMessages) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + 1;
    const prevDisabled = currentMessageIndex === 1;
    const nextDisabled = currentMessageIndex === messageLen;
    const showPrevMessage = () => {
        if (prevDisabled)
            return;
        setCurrentMessageIndex === null || setCurrentMessageIndex === void 0 ? void 0 : setCurrentMessageIndex(currentMessageIndex - 1);
    };
    const showNextMessage = () => {
        if (nextDisabled)
            return;
        setCurrentMessageIndex === null || setCurrentMessageIndex === void 0 ? void 0 : setCurrentMessageIndex(currentMessageIndex + 1);
    };
    if (totalMessages === 1 ||
        (message === null || message === void 0 ? void 0 : message.status) === 'REGENERATING' ||
        (message === null || message === void 0 ? void 0 : message.status) === 'REGENERATE_ERROR' ||
        displayMode === 'EDIT') {
        return null;
    }
    return (jsxRuntime.jsxs("div", { style: {
            maxWidth: width + 32 + 6
        }, className: cn('w-full flex justify-end items-center gap-1', customClass), children: [jsxRuntime.jsx(IconButton, { icon: ForwardRef$3, variant: "ghost", color: "default", size: "sm", disabled: prevDisabled, onClick: showPrevMessage }), jsxRuntime.jsxs(Text, { size: "sm", color: "subtle", children: [currentMessageIndex, "/", messageLen] }), jsxRuntime.jsx(IconButton, { icon: ForwardRef$2, variant: "ghost", color: "default", size: "sm", disabled: nextDisabled, onClick: showNextMessage })] }));
}

function ReplyMessage({ virtuosoRef }) {
    var _a, _b, _c, _d, _e;
    const containerRef = React.useRef(null);
    const { type, chatSetting, entityInfo, entitySetting, showReplyName } = React.useContext(StaticContext);
    const { id, hasUnlocked, chatCallerType, needShowUnlock } = entityInfo;
    const { outputVoice = false } = entitySetting !== null && entitySetting !== void 0 ? entitySetting : {};
    const { exceptionsForTextDisplay, sendButtonInteractionMessage, share, editorMode } = React.useContext(MessageContext);
    const { idSet, add, remove } = share || {};
    const { message, displayMode, latest, contextMenuDisabled } = useDisplayContext();
    const t = nextIntl.useTranslations('chat');
    const useElementWidth = (ref) => {
        const [width, setWidth] = React.useState(0);
        React.useEffect(() => {
            const observer = new ResizeObserver(entries => {
                for (const entry of entries) {
                    setWidth(entry.contentRect.width);
                }
            });
            const element = ref.current;
            if (element) {
                observer.observe(element);
            }
            return () => {
                if (element) {
                    observer.unobserve(element);
                }
            };
        }, [ref, displayMode]);
        return width;
    };
    const width = useElementWidth(containerRef);
    const showText = React.useMemo(() => {
        var _a, _b;
        const mapKey = `${type}-${id}`;
        const exceptions = (_a = (exceptionsForTextDisplay !== null && exceptionsForTextDisplay !== void 0 ? exceptionsForTextDisplay : {})[mapKey]) !== null && _a !== void 0 ? _a : [];
        return (((_b = chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn) !== null && _b !== void 0 ? _b : true) || (!(chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn) && exceptions.includes(message === null || message === void 0 ? void 0 : message.id)));
    }, [chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn, exceptionsForTextDisplay, id, message === null || message === void 0 ? void 0 : message.id, type]);
    const showAudio = React.useMemo(() => {
        var _a;
        return (_a = (outputVoice && (chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isAudioOn))) !== null && _a !== void 0 ? _a : false;
    }, [chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isAudioOn, outputVoice]);
    const handleIdChecked = (checked) => {
        if (checked) {
            add === null || add === void 0 ? void 0 : add(message.id);
        }
        else {
            remove === null || remove === void 0 ? void 0 : remove(message.id);
        }
    };
    const luiContextParams = React.useMemo(() => {
        var _a;
        return {
            clickFn: sendButtonInteractionMessage,
            msgId: (_a = message === null || message === void 0 ? void 0 : message.id) !== null && _a !== void 0 ? _a : ''
        };
    }, [message === null || message === void 0 ? void 0 : message.id, sendButtonInteractionMessage]);
    return (((_a = message === null || message === void 0 ? void 0 : message.asyncJobInfo) === null || _a === void 0 ? void 0 : _a.status) === EmbedObjStatus$1.DONE ||
        ((_b = message === null || message === void 0 ? void 0 : message.asyncJobInfo) === null || _b === void 0 ? void 0 : _b.status) === EmbedObjStatus$1.UNKNOWN) &&
        (message === null || message === void 0 ? void 0 : message.runningError) ? (jsxRuntime.jsx("div", { className: "w-full px-0 md:pl-[38px]", children: jsxRuntime.jsx(RunningError, { message: message }) })) : (jsxRuntime.jsxs("div", { className: "flex flex-col w-full", children: [jsxRuntime.jsx(MessageSwitcher, { width: width, customClass: "hidden md:flex mb-1" }), jsxRuntime.jsxs("div", { className: "w-full flex gap-1.5", children: [jsxRuntime.jsxs("div", { className: "grow overflow-hidden self-start flex items-start gap-1.5 group/menu", children: [jsxRuntime.jsx(Avatar, { size: "md", variant: (message === null || message === void 0 ? void 0 : message.source) === 'USER' ? 'user' : 'bot', src: (message === null || message === void 0 ? void 0 : message.avatar) ||
                                    'https://www.myshellstatic.com/cdn-cgi/image/quality=40,format=webp/image/bot/logo/20240106/default.png' }), jsxRuntime.jsxs("div", { className: "flex flex-col gap-[2px] max-w-full overflow-hidden", children: [showText && showReplyName && (message === null || message === void 0 ? void 0 : message.name) && (jsxRuntime.jsx(Text, { size: "sm", color: "subtler", children: message === null || message === void 0 ? void 0 : message.name })), jsxRuntime.jsx("div", { className: "w-full flex gap-1.5", children: jsxRuntime.jsx("div", { className: "w-full flex flex-col gap-3", children: displayMode === 'EDIT' ? (jsxRuntime.jsx(MessageEditor, { message: message, virtuosoRef: virtuosoRef })) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("div", { className: "flex gap-1.5", children: [jsxRuntime.jsx("div", { ref: containerRef, className: "min-w-12 md:max-w-[460px] lg:max-w-[476px] large:max-w-[560px] overflow-hidden flex flex-col gap-3", children: jsxRuntime.jsx("div", { className: "min-h-11 w-fit py-3 px-4 bg-surface-special rounded-2xl rounded-tl-sm gap-3 max-w-full", children: (message === null || message === void 0 ? void 0 : message.status) === 'REGENERATING' ? (jsxRuntime.jsx(LoadingIcon, {})) : (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [showText && (message === null || message === void 0 ? void 0 : message.replyTo) && (jsxRuntime.jsx(Text, { size: "xs", color: "subtler", children: t('reply_to', {
                                                                                    name: ((_c = message === null || message === void 0 ? void 0 : message.replyTo) === null || _c === void 0 ? void 0 : _c.isVisitor)
                                                                                        ? `${t('visitor')}${(_d = message === null || message === void 0 ? void 0 : message.replyTo) === null || _d === void 0 ? void 0 : _d.nameTag}`
                                                                                        : (_e = message === null || message === void 0 ? void 0 : message.replyTo) === null || _e === void 0 ? void 0 : _e.name
                                                                                }) })), jsxRuntime.jsx(Content, { message: message, showText: showText, showAudio: showAudio, latest: latest })] })) }) }), !contextMenuDisabled && (jsxRuntime.jsx(Menubar, { className: clsx__default.default('hidden md:flex md:invisible md:group-hover/menu:visible md:group-focus-within/menu:visible') }))] }), (message === null || message === void 0 ? void 0 : message.status) !== 'REGENERATING' &&
                                                        ((message === null || message === void 0 ? void 0 : message.componentContainer) ||
                                                            !lodashEs.isEmpty(message === null || message === void 0 ? void 0 : message.buttons) ||
                                                            (type === 'widget' &&
                                                                chatCallerType === WidgetChatCallerTypeEnum.WIDGET_CHAT_CALLER_TYPE_PROMPT &&
                                                                latest &&
                                                                !hasUnlocked &&
                                                                needShowUnlock) ||
                                                            (type === 'widget' &&
                                                                chatCallerType === WidgetChatCallerTypeEnum.WIDGET_CHAT_CALLER_TYPE_PROMPT &&
                                                                (message === null || message === void 0 ? void 0 : message.type) === 'GREETING' &&
                                                                hasUnlocked)) && (jsxRuntime.jsxs("div", { className: "min-w-12 md:max-w-[460px] lg:max-w-[476px] large:max-w-[560px] flex flex-col gap-3", children: [jsxRuntime.jsx(LUIButtonInteractionContext.Provider, { value: luiContextParams, children: jsxRuntime.jsx(Container, { component: message === null || message === void 0 ? void 0 : message.componentContainer, latest: latest }) }), !lodashEs.isEmpty(message === null || message === void 0 ? void 0 : message.buttons) ? message === null || message === void 0 ? void 0 : message.buttons : null, type === 'widget' &&
                                                                chatCallerType === WidgetChatCallerTypeEnum.WIDGET_CHAT_CALLER_TYPE_PROMPT &&
                                                                latest &&
                                                                !hasUnlocked &&
                                                                needShowUnlock && jsxRuntime.jsx(PromptWidgetUnlockAction, {}), type === 'widget' &&
                                                                chatCallerType === WidgetChatCallerTypeEnum.WIDGET_CHAT_CALLER_TYPE_PROMPT &&
                                                                (message === null || message === void 0 ? void 0 : message.type) === 'GREETING' &&
                                                                hasUnlocked && jsxRuntime.jsx(PromptWidgetViewAction, {})] }))] })) }) })] })] }), editorMode === 'SHARE' && (jsxRuntime.jsx("div", { className: clsx__default.default('shrink-0 size-8 flex justify-center items-center'), children: jsxRuntime.jsx(Checkbox, { variant: "circle", checked: idSet === null || idSet === void 0 ? void 0 : idSet.has(message.id), onCheckedChange: handleIdChecked }) }))] })] }));
}

function MessageItem({ msgDisplayType, source, virtuosoRef }) {
    return React.useMemo(() => {
        switch (msgDisplayType) {
            case 'NORMAL':
                if (source === 'USER') {
                    return jsxRuntime.jsx(MineMessage, {});
                }
                return jsxRuntime.jsx(ReplyMessage, { virtuosoRef: virtuosoRef });
            case 'INFO':
            case 'NOTIFICATION':
            default:
                return jsxRuntime.jsx(AlertMessage, {});
        }
    }, [msgDisplayType, source]);
}

const Footer = ({ loading }) => {
    if (loading) {
        return (jsxRuntime.jsx("div", { className: "w-full flex justify-center absolute bottom-1 md:bottom-6 left-1/2 -translate-x-1/2", children: jsxRuntime.jsx(Spinner, { color: "brand" }) }));
    }
    return null;
};

const ListHeader = ({ context }) => (jsxRuntime.jsx(Header, { loading: context.gettingHistory && !context.initializingHistory }));
const ListFooter = ({ context }) => (jsxRuntime.jsx(Footer, { loading: context.initializingHistory }));
const StickyFooter = () => {
    const location = messageList.useVirtuosoLocation();
    const virtuosoMethods = messageList.useVirtuosoMethods();
    return (jsxRuntime.jsx("div", { className: "relative hidden md:block", children: jsxRuntime.jsx("div", { className: "absolute w-fit right-4 md:right-6 bottom-3 md:bottom-6 mx-auto flex justify-end transition-transform duration-1000 ease-in-out", children: !location.isAtBottom && (jsxRuntime.jsx(IconButton, { size: "md", variant: "outline", color: "default", className: "bg-surface-default text-icon-brand", icon: ForwardRef$S, onClick: () => {
                    virtuosoMethods.scrollIntoView({
                        index: 'LAST',
                        align: 'end',
                        behavior: 'auto'
                    });
                } })) }) }));
};
const MessageItemRenderer = ({ data, index, context }) => {
    const { virtuosoRef } = context;
    const { messageList, messageToDisplay } = React.useContext(MessageContext);
    const parsedMessage = messageToDisplay(data);
    if (data === null || data === void 0 ? void 0 : data.handled) {
        return null;
    }
    return (jsxRuntime.jsx("div", { className: clsx__default.default('flex flex-col items-center pb-4 md:pb-5 mx-4 md:mx-6', index === 0 && 'md:pt-[80px]'), children: jsxRuntime.jsx(DisplayProvider, { message: parsedMessage, latest: index === messageList.length - 1, children: jsxRuntime.jsx(MessageItem, { source: parsedMessage.source, msgDisplayType: parsedMessage.msgDisplayType, virtuosoRef: virtuosoRef }) }) }));
};
function MessageList({ virtuosoRef }) {
    const { setAtBottom, chatSetting } = React.useContext(StaticContext);
    const prevChatSetting = reactUse.usePrevious(chatSetting);
    const { messageList: messageList$1, hasMore, gettingHistory, initializingHistory, getHistoryMessage, markAsRead, scrollToBottom, interacting, scrolled, setScrolled, lastUserInteractionMsgId } = React.useContext(MessageContext);
    const onScroll = React.useCallback((location) => {
        if (location.listOffset === 0) {
            if (hasMore) {
                getHistoryMessage();
            }
        }
        setAtBottom(location.isAtBottom);
    }, [getHistoryMessage, hasMore, setAtBottom]);
    reactUse.useEffectOnce(() => {
        markAsRead === null || markAsRead === void 0 ? void 0 : markAsRead();
    });
    React.useEffect(() => {
        if (!lodashEs.isEqual(chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isAudioOn, prevChatSetting === null || prevChatSetting === void 0 ? void 0 : prevChatSetting.isAudioOn) ||
            !lodashEs.isEqual(chatSetting === null || chatSetting === void 0 ? void 0 : chatSetting.isTranscriptionOn, prevChatSetting === null || prevChatSetting === void 0 ? void 0 : prevChatSetting.isTranscriptionOn)) {
            setTimeout(() => {
                var _a;
                (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.scrollIntoView({
                    index: 'LAST',
                    align: 'start-no-overflow',
                    behavior: 'auto'
                });
            });
        }
    }, [chatSetting]);
    useDetectKeyboardOpen({
        callback: (open) => {
            if (!open && !scrolled) {
                setTimeout(() => {
                    var _a, _b;
                    const currentLastUserInteractionMessageId = (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.findIndex(item => item.id === lastUserInteractionMsgId);
                    if (currentLastUserInteractionMessageId) {
                        (_b = virtuosoRef.current) === null || _b === void 0 ? void 0 : _b.data.append([], ({ scrollInProgress, atBottom: atB }) => {
                            return {
                                index: currentLastUserInteractionMessageId,
                                align: 'start',
                                behavior: atB || scrollInProgress ? 'smooth' : 'auto',
                                done: () => setScrolled === null || setScrolled === void 0 ? void 0 : setScrolled(true)
                            };
                        });
                    }
                }, 300);
            }
        }
    });
    return (jsxRuntime.jsx("div", { className: "h-full w-full relative", id: "message-box", children: jsxRuntime.jsx(messageList.VirtuosoMessageListLicense, { licenseKey: VIRTUOSO_MESSAGE_LIST_LICENSE !== null && VIRTUOSO_MESSAGE_LIST_LICENSE !== void 0 ? VIRTUOSO_MESSAGE_LIST_LICENSE : '', children: jsxRuntime.jsx(messageList.VirtuosoMessageList, { height: "100%", className: "h-full w-full overflow-x-hidden overscroll-contain", ref: virtuosoRef, initialData: messageList$1, computeItemKey: ({ data }) => `message-${data.id}`, context: { gettingHistory, initializingHistory, virtuosoRef }, onScroll: onScroll, Header: ListHeader, Footer: ListFooter, StickyFooter: StickyFooter, initialLocation: { index: 'LAST', align: 'end' }, ItemContent: MessageItemRenderer }) }) }));
}

function ChatPublish() {
    const t = nextIntl.useTranslations();
    const { editorMode, setEditorMode, publish } = React.useContext(MessageContext);
    const { everPublished, selectedImg, clearImg, publishing, batchPublishToGallery } = publish || {};
    const [publishState, setPublishState] = React.useState('info');
    const [popupConfirmVisible, setPopupConfirmVisible] = reactUse.useBoolean(false);
    const { isMobile } = usePathLocale();
    const { success } = useNotification();
    const publishSuccessCb = React.useCallback(() => {
        if (publishState === 'info' && !everPublished) {
            setPublishState === null || setPublishState === void 0 ? void 0 : setPublishState('success');
        }
        else {
            setPublishState === null || setPublishState === void 0 ? void 0 : setPublishState('info');
            setPopupConfirmVisible(false);
            setEditorMode === null || setEditorMode === void 0 ? void 0 : setEditorMode('NORMAL');
        }
    }, [publishState, everPublished, setPublishState, success, t, setEditorMode]);
    const confirmHandler = React.useCallback(() => {
        var _a;
        if (publishState === 'success') {
            setPublishState === null || setPublishState === void 0 ? void 0 : setPublishState('info');
            setPopupConfirmVisible(false);
        }
        else {
            batchPublishToGallery === null || batchPublishToGallery === void 0 ? void 0 : batchPublishToGallery([...((_a = selectedImg === null || selectedImg === void 0 ? void 0 : selectedImg.values()) !== null && _a !== void 0 ? _a : [])], publishSuccessCb);
        }
    }, [publishState, setPublishState, batchPublishToGallery, selectedImg, publishSuccessCb]);
    const handlePublish = () => {
        var _a;
        if (!(selectedImg === null || selectedImg === void 0 ? void 0 : selectedImg.size)) {
            return;
        }
        if (everPublished) {
            batchPublishToGallery === null || batchPublishToGallery === void 0 ? void 0 : batchPublishToGallery([...((_a = selectedImg === null || selectedImg === void 0 ? void 0 : selectedImg.values()) !== null && _a !== void 0 ? _a : [])], publishSuccessCb);
        }
        else {
            setPopupConfirmVisible(true);
        }
    };
    const handleBackToPreviousInputType = () => {
        setEditorMode === null || setEditorMode === void 0 ? void 0 : setEditorMode('NORMAL');
        clearImg === null || clearImg === void 0 ? void 0 : clearImg();
    };
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [editorMode === 'PUBLISH' && (jsxRuntime.jsx("div", { className: "w-full z-10 border-t border-default", children: jsxRuntime.jsxs("div", { className: "relative w-full", children: [jsxRuntime.jsxs("div", { className: clsx__default.default('relative chat-share bg-surface-default w-full flex justify-center items-center flex-col', isMobile ? ' h-[116px]' : 'h-[108px] px-24'), children: [jsxRuntime.jsx(IconButton, { variant: "primary", icon: PhotoStackIcon, size: isMobile ? 'sm' : 'lg', onClick: handlePublish, color: "default", className: "rounded-xl", loading: publishing, disabled: !(selectedImg === null || selectedImg === void 0 ? void 0 : selectedImg.size) }), jsxRuntime.jsx("span", { className: "text-default mt-1.5", children: t('chat.publish_to_gallery') })] }), !isMobile && (jsxRuntime.jsx(IconButton, { variant: "ghost", icon: ForwardRef$j, size: "md", onClick: () => handleBackToPreviousInputType(), color: "default", className: "absolute top-4 right-6" }))] }) })), jsxRuntime.jsx(GalleryPublishTipModal, { publishing: publishing !== null && publishing !== void 0 ? publishing : false, publishState: publishState !== null && publishState !== void 0 ? publishState : 'info', open: popupConfirmVisible, onClose: () => {
                    setPopupConfirmVisible(false);
                    if (publishState === 'success') {
                        setEditorMode === null || setEditorMode === void 0 ? void 0 : setEditorMode('NORMAL');
                        setPublishState === null || setPublishState === void 0 ? void 0 : setPublishState('info');
                    }
                }, onConfirm: confirmHandler })] }));
}

function createMessageSharedCode(messageIds) {
    return APIFetch.post('/v1/bot/shared/generate_message_shared_code', {
        body: {
            messageIds
        },
        isGoLang: true
    });
}

async function share2Twitter(url) {
    const link = document.createElement('a');
    link.href = `https://twitter.com/intent/tweet?url=${encodeURIComponent(url + '?utm_channel=referral&utm_source=x')}&text=@myshell_ai`;
    link.target = '_blank';
    link.rel = 'noopener noreferrer';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}
let shareCode = '';
let sortedSharedChatIDListCopied = [];
function ChatShare() {
    React.useContext(StaticContext);
    const { setEditorMode, share } = React.useContext(MessageContext);
    const { idSet, clear } = share || {};
    const commonT = nextIntl.useTranslations('common');
    const { isMobile } = usePathLocale();
    const { success, warning } = useNotification();
    const [loading, setLoading] = React.useState(false);
    const [loadingTarget, setLoadingTarget] = React.useState('');
    const t = nextIntl.useTranslations('chat');
    async function copyTextToClipboard(text) {
        if ('clipboard' in navigator) {
            await navigator.clipboard.writeText(text);
        }
        else {
            document.execCommand('copy', true, text);
        }
        success({
            content: commonT('copied')
        });
    }
    async function share2CopyLink(url) {
        copyTextToClipboard(url + '?utm_channel=referral&utm_source=share');
    }
    const generateConversation = React.useCallback(async (cb, host, options) => {
        var _a;
        if ((idSet === null || idSet === void 0 ? void 0 : idSet.size) === 0) {
            warning({ content: commonT('select_chat') });
            return;
        }
        setLoading(true);
        try {
            const sortedSharedChatIDList = [...(idSet !== null && idSet !== void 0 ? idSet : [])].sort();
            if (sortedSharedChatIDListCopied.toString() !== sortedSharedChatIDList.toString()) {
                const res = (await createMessageSharedCode(sortedSharedChatIDList));
                shareCode = (_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.code;
                sortedSharedChatIDListCopied = sortedSharedChatIDList;
            }
            const link = `${window.location.origin}/share/${shareCode}`;
            const downlink = `${host}/api/image?url=${encodeURIComponent(`${link}?from=download`)}&ratio=1.5&type=png`;
            const isDownload = typeof options === 'object' && options.isDownload;
            await cb(isDownload ? downlink : link, isDownload ? options.botName : '');
        }
        finally {
            setLoading(false);
            setLoadingTarget('');
        }
    }, [commonT, idSet, warning]);
    async function onCopyLinkBtnClicked() {
        setLoadingTarget('link');
        await generateConversation(share2CopyLink);
    }
    async function onTwitterBtnClicked() {
        setLoadingTarget('twitter');
        await generateConversation(share2Twitter);
    }
    const cancelShareMode = () => {
        setEditorMode === null || setEditorMode === void 0 ? void 0 : setEditorMode('NORMAL');
        clear === null || clear === void 0 ? void 0 : clear();
    };
    return (jsxRuntime.jsxs("div", { className: clsx__default.default('flex justify-center w-full relative bg-surface-default', isMobile ? 'py-4' : 'py-4 px-[92ox]'), children: [jsxRuntime.jsxs("ul", { className: clsx__default.default('flex items-center justify-around', isMobile ? 'w-full' : 'gap-20'), children: [jsxRuntime.jsx("li", { children: jsxRuntime.jsxs(react.Button, { variant: "unstyled", display: "flex", flexDirection: "column", alignItems: "center", gap: 2, minW: "66px", h: "fit-content", className: "group", onClick: onCopyLinkBtnClicked, isDisabled: loading && loadingTarget === 'link', _disabled: {
                                opacity: 0.3,
                                cursor: 'not-allowed'
                            }, children: [jsxRuntime.jsx("div", { className: "flex justify-center items-center w-[40px] h-[40px] border border-default rounded-xl", children: loading && loadingTarget === 'link' ? (jsxRuntime.jsx(react.Spinner, { color: "var(--text-brand)" })) : (jsxRuntime.jsx(ForwardRef$y, { className: "text-icon-brand w-6 h-6" })) }), jsxRuntime.jsx("span", { className: "text-sm font-normal", children: t('copy_link') })] }) }), jsxRuntime.jsx("li", { children: jsxRuntime.jsxs(react.Button, { variant: "unstyled", display: "flex", flexDirection: "column", alignItems: "center", gap: 2, minW: "66px", h: "fit-content", className: "group", onClick: onTwitterBtnClicked, isDisabled: loading && loadingTarget === 'link', _disabled: {
                                opacity: 0.3,
                                cursor: 'not-allowed'
                            }, children: [jsxRuntime.jsx("div", { className: "flex justify-center items-center w-[40px] h-[40px] border border-default rounded-xl", children: loading && loadingTarget === 'twitter' ? (jsxRuntime.jsx(react.Spinner, { color: "var(--text-brand)" })) : (jsxRuntime.jsx(lucideReact.TwitterIcon, { className: "text-icon-brand stroke-[1.5px] w-6 h-6" })) }), jsxRuntime.jsx("span", { className: "text-sm font-normal", children: t('twitter') })] }) })] }), !isMobile && (jsxRuntime.jsx(IconButton, { icon: ForwardRef$j, size: "md", variant: "ghost", color: "gray", className: "absolute top-1/2 -translate-y-1/2 right-[92px] z-10 cursor-pointer", onClick: cancelShareMode }))] }));
}

const LoginDialog$2 = dynamic__default.default(() => Promise.resolve().then(function () { return LoginDialog$1; }), {
    ssr: false
});
const bottomOpaqueBg = 'linear-gradient(179.98deg, rgba(255, 255, 255, 0) 0.81%, #FFFFFF 99.99%)';
const bottomOpaqueBgDark = 'linear-gradient(179.98deg, rgba(28, 30, 38, 0) 0.81%, #1C1E26 99.99%)';
function ChatModule({ bgUrl, editorAnchorRef, editorContainerRef, textareaRef, virtuosoRef, topActionsSlot, scrollLayoutToTop, showMobileDetail }) {
    const [bgImgLoaded, setBgImgLoaded] = reactUse.useToggle(false);
    const handleBgImgLoaded = () => {
        setBgImgLoaded(true);
    };
    const { forceToLogin } = React.useContext(StaticContext);
    const { getDragRootProps, editorMode } = React.useContext(MessageContext);
    const { resolvedTheme } = nextThemes.useTheme();
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("section", Object.assign({ className: clsx__default.default('w-full h-full flex flex-col bg-cover bg-center bg-no-repeat bg-origin-border relative', !(bgUrl && bgImgLoaded) && 'bg-surface-default'), style: {
                    backgroundImage: bgUrl && bgImgLoaded ? `url('${bgUrl}')` : 'none'
                } }, getDragRootProps === null || getDragRootProps === void 0 ? void 0 : getDragRootProps(), { children: [editorMode === 'SHARE' ? jsxRuntime.jsx(ShareSelectAll, {}) : topActionsSlot, jsxRuntime.jsxs("div", { id: "renderer-container", className: "grow h-full overflow-y-auto no-scrollbar scroll-smooth py-0 relative z-10", children: [jsxRuntime.jsx("div", { className: "absolute w-full hidden md:block md:rounded-t-3xl top-0 z-20 h-[20px]", style: {
                                    backgroundImage: 'linear-gradient(to bottom, var(--surface-default) 0, transparent 20px)'
                                } }), jsxRuntime.jsx(MessageList, { virtuosoRef: virtuosoRef }), bgImgLoaded && (jsxRuntime.jsx("div", { style: {
                                    backgroundImage: resolvedTheme === 'dark' ? bottomOpaqueBgDark : bottomOpaqueBg
                                }, className: "absolute w-full bottom-0 -z-[1] h-[348px] pointer-events-none" }))] }), editorMode === 'SHARE' ? (jsxRuntime.jsx("div", { className: "w-full z-10 border-t border-default", children: jsxRuntime.jsx(ChatShare, {}) })) : null, editorMode === 'NORMAL' ? (jsxRuntime.jsx(Editor, { editorContainerRef: editorContainerRef, editorAnchorRef: editorAnchorRef, textareaRef: textareaRef, scrollLayoutToTop: scrollLayoutToTop, showMobileDetail: showMobileDetail })) : null, jsxRuntime.jsx(ChatPublish, {})] })), bgUrl && (jsxRuntime.jsx("img", { src: bgUrl, width: 1, height: 1, className: "hidden", alt: "Background Image", onLoad: handleBgImgLoaded, fetchPriority: "high" })), forceToLogin && jsxRuntime.jsx(LoginDialog$2, { open: forceToLogin })] }));
}

function useAudioQueue() {
    const [autoPlayIdQueue, setAutoPlayIdQueue] = React.useState([]);
    const playingAudio = React.useMemo(() => {
        return autoPlayIdQueue[0];
    }, [autoPlayIdQueue]);
    const enQueue = (id) => {
        if (autoPlayIdQueue.includes(id)) {
            return;
        }
        setAutoPlayIdQueue(prevQueue => [...prevQueue, id]);
    };
    const deQueue = () => {
        setAutoPlayIdQueue(prevQueue => prevQueue.slice(1));
    };
    const clearQueue = () => {
        setAutoPlayIdQueue([]);
    };
    const playNext = () => {
        if (playingAudio) {
            deQueue();
        }
    };
    return {
        playingAudio,
        autoPlayIdQueue,
        enQueue,
        deQueue,
        clearQueue,
        playNext
    };
}

function useMessageParams(params) {
    var _a, _b, _c, _d, _e;
    const { type, id, entityId, showMockReply = false, initMessages, virtuosoMessageApi } = params;
    const { onSendMessage, onAppendMessages, onUpdateMessage, onPartialUpdateMessage, onTextStream, onAudioStream, onTranslationStream, onPrependMessages, onDeleteMessage, onRemoveDraftReplyIfExist, onVirtuosoRegen, onPartialUpdateRegenMessage, onMixMessages } = virtuosoMessageApi;
    const mapKey = `${type}-${id}`;
    const [localErrorInited, setLocalErrorInited] = reactUse.useBoolean(false);
    const scrollToBottomRef = React.useRef(0);
    const userId = useUserStore(state => state.userId);
    const messageListMap = useNewChatStore(state => state.messageListMap);
    const localDraftMessageMap = useNewChatStore(state => state.localDraftMessageMap);
    const localFiles = useNewChatStore(state => state.localFiles);
    const lastMsgIdMap = useNewChatStore(state => state.lastMsgIdMap);
    const lastUserInteractionMsgIdMap = useNewChatStore(state => state.lastUserInteractionMsgIdMap);
    const exceptionsForTextDisplay = useNewChatStore(state => state.exceptionsForTextDisplay);
    const localErrorMessageMap = useNewChatStore(state => state.localErrorMessageMap);
    const addTextDisplayException = useNewChatStore(state => state.addTextDisplayException);
    const setLocalDraftMessage = useNewChatStore(state => state.setLocalDraftMessage);
    const sendDraftMessage = useNewChatStore(state => state.sendDraftMessage);
    const replaceDraftMessage = useNewChatStore(state => state.replaceDraftMessage);
    const replaceMessage = useNewChatStore(state => state.replaceMessage);
    const updateReply = useNewChatStore(state => state.updateReply);
    const appendMessages = useNewChatStore(state => state.appendMessages);
    const prependMessages = useNewChatStore(state => state.prependMessages);
    const updateMessage = useNewChatStore(state => state.updateMessage);
    const addTextStream = useNewChatStore(state => state.addTextStream);
    const addAudioStream = useNewChatStore(state => state.addAudioStream);
    const addTranslationStream = useNewChatStore(state => state.addTranslationStream);
    const deleteSpecifiedMessage = useNewChatStore(state => state.deleteSpecifiedMessage);
    const partialUpdateMessage = useNewChatStore(state => state.partialUpdateMessage);
    const partialUpdateRegenMessage = useNewChatStore(state => state.partialUpdateRegenMessage);
    const handleInteractionError = useNewChatStore(state => state.handleInteractionError);
    const removeLocalErrorMessage = useNewChatStore(state => state.removeLocalErrorMessage);
    const clearDraftMessage = useNewChatStore(state => state.clearDraftMessage);
    const mixMessages = useNewChatStore(state => state.mixMessages);
    const storeMessageList = messageListMap[mapKey];
    const messageList = (_a = (storeMessageList || initMessages)) !== null && _a !== void 0 ? _a : [];
    const getLatestMessageList = () => {
        var _a;
        return (_a = useNewChatStore.getState().messageListMap[mapKey]) !== null && _a !== void 0 ? _a : [];
    };
    React.useEffect(() => {
        if (!(storeMessageList === null || storeMessageList === void 0 ? void 0 : storeMessageList.length) && (initMessages === null || initMessages === void 0 ? void 0 : initMessages.length)) {
            appendMessages(type, id, initMessages);
        }
    }, [storeMessageList, initMessages]);
    const localDraftMessage = localDraftMessageMap[mapKey];
    const localDraftFiles = localFiles[mapKey];
    const lastMsgId = (_b = lastMsgIdMap[mapKey]) !== null && _b !== void 0 ? _b : '';
    const lastUserInteractionMsgId = lastUserInteractionMsgIdMap[mapKey];
    const getLatestLastUserInteractionMsgId = () => {
        return useNewChatStore.getState().lastUserInteractionMsgIdMap[mapKey];
    };
    const getLatestDraftReplyMessageId = () => {
        return useNewChatStore.getState().draftReplyMessageMap[mapKey];
    };
    const lastMessageInfo = messageList.find(msg => msg.id === lastMsgId);
    const getLatestLastMessageInfo = () => {
        return useNewChatStore.getState().messageListMap[mapKey].find(msg => msg.id === lastMsgId);
    };
    const lastValidReplyMessage = messageList.reduceRight((lastDone, message) => {
        if (lastDone)
            return lastDone;
        if ((message.type === 'REPLY' || message.type === 'GREETING') && message.status === 'DONE') {
            return message;
        }
        return null;
    }, null);
    const questions = (_c = lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.recommendatioQuestions) === null || _c === void 0 ? void 0 : _c.question;
    const sending = (lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.status) === 'DRAFT' ||
        (lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.status) === 'PENDING' ||
        ((lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.type) === 'PENDING_FOR_RESPONSE' && (lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.status) !== 'CANCELED');
    const interacting = React.useMemo(() => {
        var _a, _b, _c;
        return (sending ||
            (((lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.status) === 'PENDING' ||
                (lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.status) === 'PROCESSING' ||
                ((_a = lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.asyncJobInfo) === null || _a === void 0 ? void 0 : _a.status) === EmbedObjStatus$1.PENDING ||
                ((_b = lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.asyncJobInfo) === null || _b === void 0 ? void 0 : _b.status) === EmbedObjStatus$1.PROCESSING ||
                ((_c = lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.asyncJobInfo) === null || _c === void 0 ? void 0 : _c.status) === EmbedObjStatus$1.QUEUEING) &&
                (lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.type) === 'REPLY' &&
                (lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.status) !== 'CANCELED'));
    }, [(_d = lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.asyncJobInfo) === null || _d === void 0 ? void 0 : _d.status, lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.status, lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.type, sending]);
    const showTerminate = React.useMemo(() => {
        var _a, _b, _c;
        return (((lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.status) === 'PENDING' ||
            (lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.status) === 'PROCESSING' ||
            ((_a = lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.asyncJobInfo) === null || _a === void 0 ? void 0 : _a.status) === EmbedObjStatus$1.PENDING ||
            ((_b = lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.asyncJobInfo) === null || _b === void 0 ? void 0 : _b.status) === EmbedObjStatus$1.PROCESSING ||
            ((_c = lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.asyncJobInfo) === null || _c === void 0 ? void 0 : _c.status) === EmbedObjStatus$1.QUEUEING) &&
            (lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.type) === 'REPLY' &&
            (lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.status) !== 'CANCELED');
    }, [(_e = lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.asyncJobInfo) === null || _e === void 0 ? void 0 : _e.status, lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.status, lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.type]);
    const terminating = (lastMessageInfo === null || lastMessageInfo === void 0 ? void 0 : lastMessageInfo.status) === 'CANCELING';
    const { playingAudio, autoPlayIdQueue, enQueue, clearQueue, playNext } = useAudioQueue();
    const setDraft = (draftText) => {
        setLocalDraftMessage(type, id, draftText);
    };
    const partialUpdateMsg = (messageId, partialDetail) => {
        onPartialUpdateMessage(messageId, partialDetail);
        partialUpdateMessage(type, id, messageId, partialDetail);
    };
    const partialUpdateRegenMsg = (messageId, regenMessageId, partialDetail) => {
        onPartialUpdateRegenMessage(messageId, regenMessageId, partialDetail);
        partialUpdateRegenMessage(type, id, messageId, regenMessageId, partialDetail);
    };
    const sendMessage = (draft, isButtonInteraction = false) => {
        const message = anyTypeMessageParser(draft, type);
        onSendMessage(message, isButtonInteraction);
        sendDraftMessage(type, id, message);
        if (showMockReply) {
            const localReplyId = `draft-reply-${Date.now()}`;
            const draftReplyMessage = {
                id: localReplyId,
                userId: userId !== null && userId !== void 0 ? userId : '',
                entityId: entityId || id,
                type: 'PENDING_FOR_RESPONSE',
                status: 'PENDING',
                createdDateUnix: Date.now().toString(),
                updatedDateUnix: Date.now().toString()
            };
            onAppendMessages(draftReplyMessage);
            appendMessages(type, id, draftReplyMessage);
        }
        scrollToBottomRef.current = Date.now();
    };
    const sendTextMessage = (text, files, requestParams) => {
        const draftMessageId = `draft-send-${Date.now()}`;
        const draftMessage = {
            id: draftMessageId,
            entityId: entityId || id,
            text,
            embedObjs: files
                ? files.map(f => ({
                    url: f.url,
                    type: f.uiData.serverType,
                    title: f.uiData.name,
                    mediaFileMetadata: f.mediaFileMetadata,
                    iconUrl: f.uiData.iconUrl
                }))
                : undefined,
            userId: userId !== null && userId !== void 0 ? userId : '',
            type: 'TEXT',
            status: 'DRAFT',
            createdDateUnix: Date.now().toString(),
            updatedDateUnix: Date.now().toString(),
            requestParams
        };
        sendMessage(draftMessage);
    };
    const sendAudioMessage = (audio, requestParams) => {
        const localSendId = `draft-send-${Date.now()}`;
        const draftMessage = {
            id: localSendId,
            entityId: entityId || id,
            audioUrl: audio,
            userId: userId !== null && userId !== void 0 ? userId : '',
            type: 'VOICE',
            status: 'DRAFT',
            createdDateUnix: Date.now().toString(),
            updatedDateUnix: Date.now().toString(),
            requestParams
        };
        sendMessage(draftMessage);
    };
    const sendButtonInteractionMessage = (buttonInteractionParams, requestParams) => {
        const { imSlashCommandInput, text, componentInputMessage } = buttonInteractionParams;
        const draftSendId = `draft-send-${Date.now()}`;
        const draftMessage = {
            id: draftSendId,
            entityId: entityId || id,
            userId: userId !== null && userId !== void 0 ? userId : '',
            type: 'BUTTON_INTERACTION',
            status: 'DRAFT',
            createdDateUnix: Date.now().toString(),
            updatedDateUnix: Date.now().toString(),
            slashCommandInput: imSlashCommandInput || {
                name: text !== null && text !== void 0 ? text : '',
                paramMap: componentInputMessage ? JSON.parse(componentInputMessage) : {}
            },
            text,
            requestParams
        };
        sendMessage(draftMessage, true);
    };
    const onRegen = (messageId, originMessageId) => {
        onVirtuosoRegen(originMessageId);
        partialUpdateMsg(messageId, {
            status: 'REGENERATING'
        });
    };
    const replaceDraft = (message) => {
        let parsedMessage;
        if (message.status === 'DRAFT' || message.status === 'LOCAL_ERROR' || message.status === 'NETWORK_ERROR') {
            parsedMessage = anyTypeMessageParser(message, type);
        }
        else {
            parsedMessage = message;
        }
        const currentLastUserInteractionMsgId = getLatestLastUserInteractionMsgId();
        if (!currentLastUserInteractionMsgId) {
            onAppendMessages(parsedMessage);
        }
        else {
            onUpdateMessage(currentLastUserInteractionMsgId, parsedMessage);
        }
        replaceDraftMessage(type, id, parsedMessage);
    };
    const replaceMsg = (oldMessageId, newMessage) => {
        onUpdateMessage(oldMessageId, newMessage);
        replaceMessage(type, id, oldMessageId, newMessage);
    };
    const deleteSpecifiedMessageId = (msgId) => {
        onDeleteMessage(msgId);
        deleteSpecifiedMessage(type, id, msgId);
    };
    const onMessageReply = (message) => {
        const draftReplyMessageId = getLatestDraftReplyMessageId();
        onUpdateMessage(draftReplyMessageId || message.id, message);
        updateReply(type, id, message);
    };
    const prependMsgs = (messages) => {
        onPrependMessages(messages);
        prependMessages(type, id, messages);
    };
    const appendMsgs = (messages, needScrollToBottom = false) => {
        onAppendMessages(messages, needScrollToBottom);
        appendMessages(type, id, messages);
    };
    const updateMsg = (message) => {
        let parsedMessage;
        if (message.status === 'DRAFT' || message.status === 'LOCAL_ERROR' || message.status === 'NETWORK_ERROR') {
            parsedMessage = anyTypeMessageParser(message, type);
        }
        else {
            parsedMessage = message;
        }
        const latestMessageList = getLatestMessageList();
        const originMessage = latestMessageList.find(item => item.id === message.id);
        if (originMessage) {
            if (!((originMessage.status === 'CANCELING' && message.status !== 'CANCELED') ||
                originMessage.status === 'CANCELED')) {
                onUpdateMessage(parsedMessage.id, parsedMessage);
            }
        }
        updateMessage(type, id, parsedMessage);
    };
    const mixMsgs = (messages, needScrollToBottom = false) => {
        onMixMessages(messages, needScrollToBottom);
        mixMessages(type, id, messages);
    };
    const textStreamHandler = (messageId, content, isLlmBot) => {
        onTextStream(messageId, content);
        addTextStream(type, id, messageId, content, isLlmBot);
    };
    const audioStreamHandler = (messageId, audioChunk) => {
        onAudioStream(messageId, audioChunk);
        addAudioStream(type, id, messageId, audioChunk);
    };
    const translationStreamHandler = (messageId, translation) => {
        onTranslationStream(messageId, translation);
        addTranslationStream(type, id, messageId, translation);
    };
    const addException = (msgId) => {
        addTextDisplayException(type, id, msgId);
    };
    const onInteractionError = (error) => {
        const currentLastUserInteractionMsgId = getLatestLastUserInteractionMsgId();
        const currentDraftReplyMessageId = getLatestDraftReplyMessageId();
        if (currentLastUserInteractionMsgId) {
            onPartialUpdateMessage(currentLastUserInteractionMsgId, {
                status: error
            });
        }
        if (currentDraftReplyMessageId) {
            onRemoveDraftReplyIfExist(currentDraftReplyMessageId);
        }
        handleInteractionError(type, id, error);
    };
    const onRetry = (message) => {
        const localSendId = `draft-send-${Date.now()}`;
        let draftMessage;
        if (message.type === 'TEXT') {
            draftMessage = {
                id: localSendId,
                entityId: entityId || id,
                text: message.text,
                embedObjs: message.embedObjs,
                userId: userId !== null && userId !== void 0 ? userId : '',
                type: message.type,
                status: 'DRAFT',
                createdDateUnix: Date.now().toString(),
                updatedDateUnix: Date.now().toString(),
                requestParams: message.requestParams
            };
        }
        else if (message.type === 'VOICE') {
            draftMessage = {
                id: localSendId,
                entityId: entityId || id,
                audioUrl: message.audioUrl,
                userId: userId !== null && userId !== void 0 ? userId : '',
                type: 'VOICE',
                status: 'DRAFT',
                createdDateUnix: Date.now().toString(),
                updatedDateUnix: Date.now().toString(),
                requestParams: message.requestParams
            };
        }
        else {
            draftMessage = {
                id: localSendId,
                entityId: entityId || id,
                userId: userId !== null && userId !== void 0 ? userId : '',
                type: 'TEXT',
                status: 'DRAFT',
                createdDateUnix: Date.now().toString(),
                updatedDateUnix: Date.now().toString(),
                slashCommandInput: message.slashCommandInput,
                text: message.text,
                requestParams: message.requestParams
            };
        }
        onDeleteMessage(message.id);
        removeLocalErrorMessage(type, id, message.id);
        sendMessage(draftMessage);
    };
    const clearDraft = () => {
        const currentLastUserInteractionMsgId = getLatestLastUserInteractionMsgId();
        if (currentLastUserInteractionMsgId) {
            onDeleteMessage(currentLastUserInteractionMsgId);
        }
        const currentDraftReplyMessageId = getLatestDraftReplyMessageId();
        if (currentDraftReplyMessageId) {
            onDeleteMessage(currentDraftReplyMessageId);
        }
        clearDraftMessage(type, id);
    };
    reactUse.useEffectOnce(() => {
        return clearQueue();
    });
    React.useEffect(() => {
        var _a;
        const validLocalErrorMessages = ((_a = localErrorMessageMap[mapKey]) !== null && _a !== void 0 ? _a : []).filter(msg => msg.userId === userId);
        if (!localErrorInited) {
            mixMsgs(validLocalErrorMessages, true);
            setLocalErrorInited(true);
        }
    }, [id, localErrorInited, localErrorMessageMap, mapKey, type, userId]);
    return {
        messageList,
        lastMessageInfo,
        lastValidReplyMessage,
        questions,
        lastUserInteractionMsgId,
        draftMessage: localDraftMessage,
        sending,
        interacting,
        scrollToBottom: scrollToBottomRef.current,
        exceptionsForTextDisplay,
        getLatestLastMessageInfo,
        addTextDisplayException: addException,
        setDraftMessage: setDraft,
        sendTextMessage,
        sendAudioMessage,
        sendButtonInteractionMessage,
        onRetry,
        onRegen,
        replaceDraftMessage: replaceDraft,
        prependMessages: prependMsgs,
        appendMessages: appendMsgs,
        updateMessage: updateMsg,
        replaceMessage: replaceMsg,
        onMessageReply,
        mixMessages: mixMsgs,
        addTextStream: textStreamHandler,
        addAudioStream: audioStreamHandler,
        addTranslationStream: translationStreamHandler,
        deleteSpecifiedMessageId,
        partialUpdateMsg,
        partialUpdateRegenMsg,
        onInteractionError,
        clearDraft,
        audioQueue: {
            playingAudio,
            queue: autoPlayIdQueue,
            enQueue,
            clearQueue,
            playNext
        },
        file: {
            uploadedFiles: localDraftFiles
        },
        showTerminate,
        terminating
    };
}

function useChatLayout() {
    const scrollContainerRef = React.useRef(null);
    const editorContainerRef = React.useRef(null);
    const editorAnchorRef = React.useRef(null);
    const textareaRef = React.useRef(null);
    const chatContainerRef = React.useRef(null);
    const detailContainerRef = React.useRef(null);
    const detailScrollRef = React.useRef(null);
    const { y: detailScrollY } = reactUse.useScroll(detailScrollRef);
    const [isEditorSticky, setIsEditorSticky] = reactUse.useToggle(false);
    const [contentActive, setContentActive] = reactUse.useToggle(true);
    const scrollLayoutToTop = React.useCallback(() => {
        if (!scrollContainerRef.current)
            return;
        scrollContainerRef.current.scrollTop = 0;
    }, []);
    const manuallyScrollDetailToTop = React.useCallback(() => {
        if (!editorContainerRef.current || !scrollContainerRef.current)
            return;
        const editorRect = editorContainerRef.current.getBoundingClientRect();
        const scrollContainerRect = scrollContainerRef.current.getBoundingClientRect();
        const relativeTop = editorRect.top - scrollContainerRect.top;
        scrollContainerRef.current.scrollTop = Math.ceil(scrollContainerRef.current.scrollTop + relativeTop);
    }, [editorContainerRef, scrollContainerRef]);
    const showMobileDetail = React.useCallback(() => {
        setContentActive(false);
    }, [setContentActive]);
    React.useEffect(() => {
        let animationFrameId;
        const scrollContainerEle = scrollContainerRef.current;
        const handleScroll = () => {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = requestAnimationFrame(() => {
                var _a;
                if (scrollContainerEle && editorContainerRef.current && editorAnchorRef.current) {
                    const scrollContainerRect = scrollContainerEle.getBoundingClientRect();
                    const anchorRect = editorAnchorRef.current.getBoundingClientRect();
                    const topDistance = anchorRect.top - scrollContainerRect.top;
                    const shouldSticky = topDistance <= 0;
                    if (shouldSticky !== isEditorSticky) {
                        setIsEditorSticky(shouldSticky);
                        if (shouldSticky) {
                            const editorHeight = editorContainerRef.current.offsetHeight;
                            editorAnchorRef.current.style.height = `${editorHeight}px`;
                            editorContainerRef.current.style.position = 'fixed';
                            editorContainerRef.current.style.borderTop = '1px solid var(--border)';
                            editorContainerRef.current.style.borderBottom = '1px solid var(--border)';
                            editorContainerRef.current.style.boxShadow = '0px 20px 20px -10px var(--shadow-modal-bolder)';
                            (_a = textareaRef.current) === null || _a === void 0 ? void 0 : _a.blur();
                        }
                        else {
                            editorAnchorRef.current.style.height = 'auto';
                            editorContainerRef.current.style.position = 'static';
                            editorContainerRef.current.style.borderTop = 'none';
                            editorContainerRef.current.style.borderBottom = 'none';
                            editorContainerRef.current.style.boxShadow = 'none';
                        }
                    }
                }
            });
        };
        if (scrollContainerEle) {
            scrollContainerEle.addEventListener('scroll', handleScroll);
        }
        return () => {
            if (scrollContainerEle) {
                scrollContainerEle.removeEventListener('scroll', handleScroll);
            }
            cancelAnimationFrame(animationFrameId);
        };
    }, [isEditorSticky]);
    return {
        scrollContainerRef,
        editorContainerRef,
        editorAnchorRef,
        textareaRef,
        chatContainerRef,
        detailContainerRef,
        detailScrollRef,
        scrollLayoutToTop,
        manuallyScrollDetailToTop,
        isEditorSticky,
        contentActive,
        setContentActive,
        detailScrollY,
        showMobileDetail
    };
}

function useVirtuosoMessageListApi(showMockReply = true) {
    const [scrolled, setScrolled] = reactUse.useBoolean(true);
    const isMobile = useGlobalStore(state => state.isMobile);
    const virtuosoRef = React.useRef(null);
    const onSendMessage = (message, isButtonInteraction = false) => {
        var _a;
        (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.append([message], ({ scrollInProgress, atBottom }) => {
            if (!isMobile) {
                return {
                    index: showMockReply ? -1 : 'LAST',
                    align: 'start',
                    offset: -60,
                    behavior: atBottom || scrollInProgress ? 'smooth' : 'auto'
                };
            }
            if (isButtonInteraction) {
                return {
                    index: showMockReply ? -1 : 'LAST',
                    align: 'start',
                    behavior: atBottom || scrollInProgress ? 'smooth' : 'auto'
                };
            }
            setScrolled(false);
            return false;
        });
    };
    const onPrependMessages = (messages) => {
        var _a;
        (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.prepend(messages);
    };
    const onAppendMessages = (messages, needScrollToBottom) => {
        var _a, _b;
        (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.append(Array.isArray(messages) ? messages : [messages]);
        if (needScrollToBottom) {
            (_b = virtuosoRef.current) === null || _b === void 0 ? void 0 : _b.data.append([], ({ scrollInProgress, atBottom }) => {
                return {
                    index: 'LAST',
                    align: 'start',
                    offset: isMobile ? 0 : -60,
                    behavior: atBottom || scrollInProgress ? 'smooth' : 'auto'
                };
            });
        }
    };
    const onUpdateMessage = (messageId, newMessage) => {
        var _a;
        (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.map(item => (item.id === messageId ? newMessage : item));
    };
    const onTextStream = (messageId, content) => {
        var _a;
        (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.map(item => item.id === messageId
            ? Object.assign(Object.assign({}, item), { text: (item.text || '') + content }) : item);
    };
    const onAudioStream = (messageId, audioChunk) => {
        var _a;
        (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.map(item => item.id === messageId
            ? Object.assign(Object.assign({}, item), { audioBuffer: [...(item.audioBuffer || []), audioChunk] }) : item);
    };
    const onTranslationStream = (messageId, translation) => {
        var _a;
        (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.map(item => item.id === messageId
            ? Object.assign(Object.assign({}, item), { translation: (item.translation || '') + translation }) : item);
    };
    const onPartialUpdateMessage = (messageId, partialDetail) => {
        var _a;
        (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.map(item => item.id === messageId
            ? Object.assign(Object.assign({}, item), partialDetail) : item);
    };
    const onPartialUpdateRegenMessage = (messageId, regenMessageId, partialDetail) => {
        var _a;
        (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.map(item => item.id === messageId
            ? Object.assign(Object.assign({}, item), { regeneratedMessages: (item.regeneratedMessages || []).map(regenMsg => regenMsg.id === regenMessageId ? Object.assign(Object.assign({}, regenMsg), partialDetail) : regenMsg) }) : item);
    };
    const onDeleteMessage = (messageId) => {
        var _a, _b;
        if (messageId) {
            (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.findAndDelete(item => item.id === messageId);
        }
        else {
            (_b = virtuosoRef.current) === null || _b === void 0 ? void 0 : _b.data.replace([]);
        }
    };
    const onRemoveDraftReplyIfExist = (messageId) => {
        var _a, _b;
        const messageData = (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.find(item => item.id === messageId);
        if (messageData && messageData.type === 'PENDING_FOR_RESPONSE') {
            (_b = virtuosoRef.current) === null || _b === void 0 ? void 0 : _b.data.findAndDelete(item => item.id === messageId);
        }
    };
    const onMixMessages = (msgs, needScrollToBottom = false) => {
        var _a, _b, _c, _d, _e;
        const messages = Array.isArray(msgs) ? msgs : [msgs];
        const currentData = (_b = (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.get()) !== null && _b !== void 0 ? _b : [];
        if (currentData.length === 0) {
            (_c = virtuosoRef.current) === null || _c === void 0 ? void 0 : _c.data.append(messages, ({ scrollInProgress, atBottom }) => {
                if (needScrollToBottom) {
                    return {
                        index: 'LAST',
                        align: 'end',
                        offset: 0,
                        behavior: 'auto'
                    };
                }
                return false;
            });
            return;
        }
        const currentDataMaxTimestamp = Math.max(...currentData.map(m => Number(m.createdDateUnix)));
        const currentDataMinTimestamp = Math.min(...currentData.map(m => Number(m.createdDateUnix)));
        const messagesMinTimestamp = Math.min(...messages.map(m => Number(m.createdDateUnix)));
        const messagesMaxTimestamp = Math.max(...messages.map(m => Number(m.createdDateUnix)));
        if (messagesMinTimestamp > currentDataMaxTimestamp) {
            (_d = virtuosoRef.current) === null || _d === void 0 ? void 0 : _d.data.append(messages, ({ scrollInProgress, atBottom }) => {
                if (needScrollToBottom) {
                    return {
                        index: 'LAST',
                        align: 'end',
                        offset: 0,
                        behavior: 'auto'
                    };
                }
                return false;
            });
            return;
        }
        if (currentDataMinTimestamp > messagesMaxTimestamp) {
            (_e = virtuosoRef.current) === null || _e === void 0 ? void 0 : _e.data.prepend(messages);
            return;
        }
        const rest = messages.filter(newMessage => {
            const existingMessage = currentData.find(m => m.id === newMessage.id);
            return !existingMessage || !lodashEs.isEqual(existingMessage, newMessage);
        });
        if (rest.length === 0)
            return;
        rest.forEach(newMessage => {
            var _a, _b, _c, _d, _e;
            const latestData = (_b = (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.get()) !== null && _b !== void 0 ? _b : [];
            const existingItem = latestData.find(m => m.id === newMessage.id);
            if (existingItem) {
                (_c = virtuosoRef.current) === null || _c === void 0 ? void 0 : _c.data.map(item => (item.id === newMessage.id ? newMessage : item));
            }
            else {
                const insertIndex = latestData.findIndex(m => Number(m.createdDateUnix) > Number(newMessage.createdDateUnix));
                if (insertIndex === -1) {
                    (_d = virtuosoRef.current) === null || _d === void 0 ? void 0 : _d.data.append([newMessage]);
                }
                else {
                    (_e = virtuosoRef.current) === null || _e === void 0 ? void 0 : _e.data.insert([newMessage], insertIndex);
                }
            }
        });
        if (needScrollToBottom) {
            setTimeout(() => {
                var _a;
                (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.scrollIntoView({
                    index: 'LAST',
                    align: 'end',
                    offset: 0,
                    behavior: 'auto'
                });
            });
        }
    };
    const onVirtuosoRegen = (originMessage) => {
        var _a, _b;
        const msgIndex = (_a = virtuosoRef.current) === null || _a === void 0 ? void 0 : _a.data.findIndex(item => item.id === originMessage);
        (_b = virtuosoRef.current) === null || _b === void 0 ? void 0 : _b.data.append([], ({ scrollInProgress, atBottom }) => {
            return {
                index: msgIndex !== null && msgIndex !== void 0 ? msgIndex : 'LAST',
                align: 'start',
                offset: isMobile ? 0 : -60,
                behavior: atBottom || scrollInProgress ? 'smooth' : 'auto'
            };
        });
    };
    return {
        scrolled,
        setScrolled,
        virtuosoRef,
        onSendMessage,
        onAppendMessages,
        onUpdateMessage,
        onPartialUpdateMessage,
        onPartialUpdateRegenMessage,
        onTextStream,
        onAudioStream,
        onTranslationStream,
        onPrependMessages,
        onDeleteMessage,
        onRemoveDraftReplyIfExist,
        onVirtuosoRegen,
        onMixMessages
    };
}

function useAtBottom() {
    const [atBottom, setAtBottom] = reactUse.useBoolean(true);
    return {
        atBottom,
        setAtBottom
    };
}

function useEditorMode() {
    const [inputMode, setInputMode] = React.useState('TEXT');
    const [editorMode, setEditorMode] = React.useState('NORMAL');
    return {
        inputMode,
        setInputMode,
        editorMode,
        setEditorMode
    };
}

const defaultMaxSize$1 = 50 * 1024 ** 2;
const enableMIME$1 = {
    AUDIO: {
        '.mp3': 'audio/mpeg',
        '.wav': 'audio/wav',
        '.ogg': 'audio/ogg',
        '.wma': 'audio/x-ms-wma',
        '.flac': 'audio/flac',
        '.ape': 'audio/ape'
    },
    VIDEO: {
        '.mp4': 'video/mp4',
        '.avi': 'video/x-msvideo',
        '.mov': 'video/quicktime',
        '.wmv': 'video/x-ms-wmv',
        '.flv': 'video/x-flv'
    },
    APPLICATION: {
        '.rtf': 'application/rtf',
        '.md': 'text/markdown',
        '.markdown': 'text/markdown',
        '.pdf': 'application/pdf',
        '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        '.doc': 'application/msword',
        '.txt': 'text/plain',
        '.csv': 'text/csv'
    },
    IMAGE: {
        '.apng': 'image/apng',
        '.png': 'image/png',
        '.jpeg': 'image/jpeg',
        '.jpg': 'image/jpg',
        '.gif': 'image/gif',
        '.bmp': 'image/bmp',
        '.tiff': 'image/tiff',
        '.tif': 'image/tiff',
        '.heic': 'image/heic'
    },
    ALL: {
        '*': '*/*'
    }
};
const ex2MIME$1 = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, enableMIME$1.AUDIO), enableMIME$1.VIDEO), enableMIME$1.APPLICATION), enableMIME$1.IMAGE), enableMIME$1.ALL);
const fileUIData$1 = {
    md: {
        icon: 'other',
        type: 'Markdown File',
        bg: '#6F8BB5',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/Other.svg'
    },
    markdown: {
        icon: 'other',
        type: 'Markdown File',
        bg: '#6F8BB5',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/Other.svg'
    },
    pdf: {
        icon: 'PDF',
        type: 'PDF',
        bg: '#EA3434',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/PDF.svg'
    },
    docx: {
        icon: 'W',
        type: 'Word File',
        bg: '#2684FF',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/Word.svg'
    },
    doc: {
        icon: 'W',
        type: 'Word File',
        bg: '#2684FF',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/Word.svg'
    },
    txt: {
        icon: 'T',
        type: 'TXT',
        bg: '#6F8BB5',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/TXT.svg'
    },
    csv: {
        icon: 'CSV',
        type: 'CSV',
        bg: '#079455',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2024053011/embed_icon/CSV.svg'
    },
    other: {
        icon: 'other',
        type: 'Rich Text File',
        bg: '#6F8BB5',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/Other.svg'
    }
};

const serverFileTypes2Local$1 = Object.fromEntries(Object.entries(ServerFileTypes).map(([key, value]) => [value, key]));
const getAcceptTypes$1 = (serverTypes) => {
    const res = {};
    serverTypes.forEach(type => {
        const localType = serverFileTypes2Local$1[type];
        if (localType) {
            const mimeMap = enableMIME$1[localType];
            const keys = Object.keys(mimeMap);
            keys.forEach(k => {
                if (!res[mimeMap[k]]) {
                    res[mimeMap[k]] = [k];
                }
                else {
                    res[mimeMap[k]] = [...res[mimeMap[k]], k];
                }
            });
        }
    });
    return res;
};
const getUIFileData$1 = (file) => {
    const arr = file.name.split('.');
    const ext = arr[arr.length - 1].toLowerCase();
    const e2MIME = `.${ext}`;
    const mimeType = file.type || ex2MIME$1[e2MIME];
    const mt = mimeType.split('/')[0].toUpperCase();
    const fileUI = fileUIData$1[ext] || fileUIData$1.other;
    const ct = ext.toUpperCase();
    return Object.assign({ mimeType: mt, orginalMIMEType: file.type, contentType: ContentTypeEnum[ct], name: file.name, ex: ext, serverType: mt === 'TEXT' ? ServerFileTypes.APPLICATION : ServerFileTypes[mt] }, fileUI);
};
const getObjectURL$1 = (file) => URL.createObjectURL(file);
const loadImageDimensions$1 = async (url) => {
    return new Promise((resolve, reject) => {
        const image = new Image();
        image.onload = () => {
            resolve({ width: image.width, height: image.height });
            URL.revokeObjectURL(url);
        };
        image.onerror = () => {
            reject(new Error('Failed to load image.'));
            URL.revokeObjectURL(url);
        };
        image.src = url;
    });
};
const loadVideoDimensions$1 = async (url) => {
    return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.onloadedmetadata = () => {
            resolve({ width: video.videoWidth, height: video.videoHeight });
            URL.revokeObjectURL(url);
        };
        video.onerror = () => {
            reject(new Error('Failed to load video.'));
            URL.revokeObjectURL(url);
        };
        video.src = url;
    });
};
const getMediaDimension$1 = async (data) => {
    const url = getObjectURL$1(data.file);
    if (data.uiData.mimeType === 'IMAGE') {
        return loadImageDimensions$1(url);
    }
    if (data.uiData.mimeType === 'VIDEO') {
        return loadVideoDimensions$1(url);
    }
    return null;
};
const processFiles = async (files) => {
    const fs = files.map(f => {
        const uiData = getUIFileData$1(f);
        return {
            file: f,
            id: generateUUID(),
            type: uiData === null || uiData === void 0 ? void 0 : uiData.serverType,
            uiData,
            status: 'PENDING'
        };
    });
    const fsPromises = fs.map(async (file) => {
        try {
            const dimension = await getMediaDimension$1(file);
            return Object.assign(Object.assign({}, file), { mediaFileMetadata: Object.assign(Object.assign({}, (dimension || {})), { thumbnail: '' }) });
        }
        catch (error) {
            console.error(error);
            return file;
        }
    });
    const res = await Promise.all(fsPromises);
    return res;
};
const processUploadFiles$1 = (files) => processFiles(files);
const getServerFileTypeByExt = (fileExtension) => {
    const fileType = Object.entries(enableMIME$1).find(([type, mimeMap]) => mimeMap[fileExtension.toLowerCase()]);
    if (fileType) {
        return ServerFileTypes[fileType[0]];
    }
    return ServerFileTypes.ALL;
};

function formatFileSize(bytes, decimals = 2) {
    if (bytes === 0)
        return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / k ** i).toFixed(dm))} ${sizes[i]}`;
}
function useUploadFiles({ panelSettings, uploadedFiles = [], messageSettings, type, id, name, disabled = false, dragDisabled, scrollLayoutToTop, textareaRef, overrideUploadFileToS3WithProgress, }) {
    var _a, _b, _c, _d;
    const sensors = useSensors();
    const [dragMaskVisible, setDragMaskVisible] = reactUse.useToggle(false);
    const isChoosingFile = React.useRef(false);
    const uploadFiles = useNewChatStore(state => state.uploadFiles);
    const deleteFile = useNewChatStore(state => state.deleteUploadFile);
    const setFileAlert = useNewChatStore(state => state.setFileAlert);
    const { warning } = useNotification();
    const chatT = nextIntl.useTranslations('chat');
    const noValidLimitations = ((_b = (_a = messageSettings === null || messageSettings === void 0 ? void 0 : messageSettings.supportedFileInfos) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = panelSettings === null || panelSettings === void 0 ? void 0 : panelSettings.supportedFileInfos) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) === 0;
    const computedSupportedFileInfos = React.useMemo(() => {
        var _a;
        return (_a = messageSettings === null || messageSettings === void 0 ? void 0 : messageSettings.supportedFileInfos) !== null && _a !== void 0 ? _a : panelSettings === null || panelSettings === void 0 ? void 0 : panelSettings.supportedFileInfos;
    }, [panelSettings, messageSettings]);
    const maxFiles = React.useMemo(() => {
        return (computedSupportedFileInfos !== null && computedSupportedFileInfos !== void 0 ? computedSupportedFileInfos : []).reduce((acc, cur) => {
            return acc + cur.maxUploadNum;
        }, 0);
    }, [computedSupportedFileInfos]);
    const supportTypes = React.useMemo(() => {
        return (computedSupportedFileInfos !== null && computedSupportedFileInfos !== void 0 ? computedSupportedFileInfos : []).reduce((acc, cur) => {
            return [...acc, cur.type];
        }, []);
    }, [computedSupportedFileInfos]);
    const acceptTypes = React.useMemo(() => getAcceptTypes$1(supportTypes), [supportTypes]);
    const supportedFileTypes = React.useMemo(() => {
        return supportTypes.flatMap((supportType) => {
            const localType = serverFileTypes2Local$1[supportType];
            return localType ? Object.keys(enableMIME$1[localType]) : [];
        });
    }, [supportTypes]);
    const handleUpload = React.useCallback((files, retry) => {
        uploadFiles(type, id, files, retry, overrideUploadFileToS3WithProgress);
    }, [id, type, uploadFiles, overrideUploadFileToS3WithProgress]);
    const onFileChange = React.useCallback(async (files) => {
        const res = await processUploadFiles$1(files);
        handleUpload(res);
    }, [handleUpload]);
    const onDrop = React.useCallback((acceptedFiles) => {
        isChoosingFile.current = false;
        setDragMaskVisible(false);
        if (!acceptedFiles.length)
            return;
        const fileGroups = {};
        const currentFileGroups = {};
        uploadedFiles.forEach(file => {
            var _a;
            const serverType = ((_a = file.uiData) === null || _a === void 0 ? void 0 : _a.serverType) || ServerFileTypes.ALL;
            if (!currentFileGroups[serverType]) {
                currentFileGroups[serverType] = [];
            }
            currentFileGroups[serverType].push(file);
        });
        acceptedFiles.forEach(file => {
            var _a;
            const ext = ((_a = file.name.split('.').pop()) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || '';
            const serverType = getServerFileTypeByExt(`.${ext}`);
            if (!fileGroups[serverType]) {
                fileGroups[serverType] = [];
            }
            fileGroups[serverType].push(file);
        });
        const errors = [];
        computedSupportedFileInfos === null || computedSupportedFileInfos === void 0 ? void 0 : computedSupportedFileInfos.forEach(info => {
            const currentFiles = currentFileGroups[info.type] || [];
            const newFiles = fileGroups[info.type] || [];
            const totalFiles = [...currentFiles.map(f => f.file), ...newFiles];
            if (totalFiles.length > info.maxUploadNum) {
                errors.push(chatT('panel.maxTypeFiles', {
                    type: info.type,
                    number: info.maxUploadNum
                }));
            }
            const totalSize = totalFiles.reduce((acc, file) => acc + file.size, 0);
            if (totalSize > info.maxTotalBytes) {
                errors.push(chatT('panel.maxTypeFileSize', {
                    type: info.type,
                    size: formatFileSize(info.maxTotalBytes)
                }));
            }
        });
        if (errors.length > 0) {
            warning({ content: errors.join('\n') });
        }
        else {
            onFileChange(acceptedFiles);
        }
        if (type === 'bot') {
            const fileName = acceptedFiles[0].name;
            const fileType = fileName.substring(fileName.lastIndexOf('.') + 1);
            sensors === null || sensors === void 0 ? void 0 : sensors.track('UploadFile', {
                item_type: 'bot',
                item_id: id,
                item_name: name,
                file_type: fileType,
                file_size: acceptedFiles[0].size.toString()
            });
        }
    }, [
        chatT,
        computedSupportedFileInfos,
        id,
        name,
        onFileChange,
        sensors,
        setDragMaskVisible,
        type,
        uploadedFiles,
        warning
    ]);
    const onDropRejected = React.useCallback((fileRejections) => {
        const unSupport = fileRejections
            .filter(file => file.errors[0].code === reactDropzone.ErrorCode.FileInvalidType)
            .map(file => ({
            code: file.errors[0].code,
            name: file.file.name
        }));
        const tooLarge = fileRejections
            .filter(file => file.errors[0].code === reactDropzone.ErrorCode.FileTooLarge)
            .map(file => ({
            code: file.errors[0].code,
            name: file.file.name
        }));
        setFileAlert({ visible: true, data: [unSupport, tooLarge] });
    }, [setFileAlert]);
    const fileValidator = React.useCallback((file) => {
        var _a, _b;
        const ext = file.name ? file.name.split('.')[1] : file.type ? file.type.split('/')[1] : '';
        const serverType = getServerFileTypeByExt(`.${ext}`);
        const info = computedSupportedFileInfos === null || computedSupportedFileInfos === void 0 ? void 0 : computedSupportedFileInfos.find(fileInfo => fileInfo.type === serverType);
        const maxSingleBytes = (_a = info === null || info === void 0 ? void 0 : info.maxSingleBytes) !== null && _a !== void 0 ? _a : defaultMaxSize$1;
        if (file.size > maxSingleBytes) {
            const mbSize = formatFileSize(maxSingleBytes);
            return {
                code: reactDropzone.ErrorCode.FileTooLarge,
                message: `Size is larger than ${mbSize} mb!`
            };
        }
        const computedSupportedFileTypes = ((_b = info === null || info === void 0 ? void 0 : info.fileExtensions) === null || _b === void 0 ? void 0 : _b.length) ? info === null || info === void 0 ? void 0 : info.fileExtensions : supportedFileTypes;
        if (!computedSupportedFileTypes.includes(`.${ext.toLowerCase()}`) && !supportedFileTypes.includes('*')) {
            return {
                code: reactDropzone.ErrorCode.FileInvalidType,
                message: `${ext} is not support yet!`
            };
        }
        return null;
    }, [computedSupportedFileInfos, supportedFileTypes]);
    const commonOptions = {
        accept: acceptTypes,
        maxFiles,
        noKeyboard: true,
        maxSize: defaultMaxSize$1,
        onDragOver: () => setDragMaskVisible(true),
        onDragLeave: () => setDragMaskVisible(false),
        validator: fileValidator,
        onDrop,
        onDropRejected,
        onFileDialogOpen: () => {
            isChoosingFile.current = true;
            scrollLayoutToTop === null || scrollLayoutToTop === void 0 ? void 0 : scrollLayoutToTop();
        },
        onFileDialogCancel: () => {
            var _a;
            isChoosingFile.current = false;
            (_a = textareaRef === null || textareaRef === void 0 ? void 0 : textareaRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }
    };
    const clickOptions = Object.assign(Object.assign({}, commonOptions), { noClick: false, noDrag: true, disabled: disabled || noValidLimitations });
    const dragOptions = Object.assign(Object.assign({}, commonOptions), { noClick: true, noDrag: false, disabled: disabled || noValidLimitations || dragDisabled });
    const handleDelete = React.useCallback((fileId) => {
        deleteFile(type, id, fileId);
    }, [deleteFile, id, type]);
    const handlePastedFiles = React.useCallback((files) => {
        const acceptedFiles = [];
        const rejectedFiles = [];
        files.forEach(file => {
            const error = fileValidator(file);
            if (error) {
                rejectedFiles.push({ file, errors: [error] });
            }
            else {
                acceptedFiles.push(file);
            }
        });
        if (acceptedFiles.length > 0) {
            onDrop(acceptedFiles);
        }
        if (rejectedFiles.length > 0) {
            onDropRejected(rejectedFiles);
        }
    }, [fileValidator, onDrop, onDropRejected]);
    const { getRootProps: getDragRootProps } = reactDropzone.useDropzone(dragOptions);
    const { getRootProps: getClickRootProps, getInputProps } = reactDropzone.useDropzone(clickOptions);
    return {
        dragMaskVisible,
        uploadedFiles,
        noValidLimitations,
        handleUpload,
        handleDelete,
        getDragRootProps,
        getClickRootProps,
        getInputProps,
        handlePastedFiles,
        isChoosingFile
    };
}

const MobilePreview$2 = dynamic__default.default(() => Promise.resolve().then(function () { return index$1; }), {
    ssr: false
});
const PcPreview = dynamic__default.default(() => Promise.resolve().then(function () { return index; }), {
    ssr: false
});
function ImgVideoPreview({ imgVideoList, activeIndex, open, isGreeting, onClose }) {
    const { isMobile } = useDevice();
    const [popupConfirmObj, setPopupConfirmObj] = React.useState(null);
    const [publishState, setPublishState] = React.useState('info');
    const { publishing, publishGalleryList } = usePublishGallery();
    const t = nextIntl.useTranslations();
    const { msgId, selectedBot } = React.useContext(LUIButtonInteractionContext$1);
    const flagUserFirstPublishGallery = useUserStore(state => state.flagUserFirstPublishGallery);
    const publishGalleryHandle = React.useCallback((index) => {
        var _a, _b;
        const imgItem = imgVideoList[index];
        const publishObj = {
            botId: `${selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.id}`,
            imageLink: imgItem.url,
            messageId: msgId,
            naturalHeight: ((_a = imgItem.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.height) || 0,
            naturalWidth: ((_b = imgItem.mediaFileMetadata) === null || _b === void 0 ? void 0 : _b.width) || 0
        };
        if (flagUserFirstPublishGallery) {
            publishGalleryList(publishSuccessCb, [publishObj]);
        }
        else {
            setPopupConfirmObj(publishObj);
        }
    }, [publishGalleryList, selectedBot, msgId, flagUserFirstPublishGallery]);
    const { success } = useNotification();
    const publishSuccessCb = React.useCallback(() => {
        if (publishState === 'info' && !flagUserFirstPublishGallery) {
            setPublishState('success');
        }
        else {
            success({
                content: t('chat.suc_send')
            });
            setPublishState('info');
            setPopupConfirmObj(null);
            onClose();
        }
    }, [setPopupConfirmObj, flagUserFirstPublishGallery, publishState]);
    const confirmHandler = React.useCallback(() => {
        if (publishState === 'success') {
            setPopupConfirmObj(null);
            onClose();
        }
        else {
            popupConfirmObj && publishGalleryList(publishSuccessCb, [popupConfirmObj]);
        }
    }, [publishState, publishGalleryList, publishSuccessCb]);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [imgVideoList.length > 0 && (jsxRuntime.jsx(Modal, { open: open, onClose: onClose, contentClassName: "w-full h-full max-h-none p-0 rounded-none bg-beta-black-10", hideClose: true, children: jsxRuntime.jsx("div", { className: "overflow-hidden p-0", children: isMobile ? (jsxRuntime.jsx(MobilePreview$2, { imgVideoList: imgVideoList, activeIndex: activeIndex, onClose: onClose, publishGalleryHandle: publishGalleryHandle, publishing: publishing, isGreeting: isGreeting })) : (jsxRuntime.jsx(PcPreview, { imgVideoList: imgVideoList, activeIndex: activeIndex, onClose: onClose, publishGalleryHandle: publishGalleryHandle, publishing: publishing, isGreeting: isGreeting })) }) })), jsxRuntime.jsx(GalleryPublishTipModal$1, { open: !!(popupConfirmObj === null || popupConfirmObj === void 0 ? void 0 : popupConfirmObj.botId), onClose: () => {
                    setPopupConfirmObj(null);
                    publishState === 'success' && onClose();
                }, onConfirm: confirmHandler, publishState: publishState, publishing: publishing })] }));
}

var ImgVideoPreview$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: ImgVideoPreview
});

function PinchZoomImage$1({ imgObj, onPinchStart, onPinchEnd }) {
    var _a, _b, _c, _d;
    const containerRef = React.useRef(null);
    const [scaleValue, setScaleValue] = React.useState(1);
    const prevScale = React.useRef(1);
    const imageRef = React.useRef(null);
    const [loaded, setLoaded] = React.useState(false);
    const handleLoaded = () => {
        setLoaded(true);
    };
    usehooksTs.useEffectOnce(() => {
        const image = imageRef.current;
        if (image) {
            image.addEventListener('load', handleLoaded, {
                once: true
            });
        }
    });
    React.useEffect(() => {
        if (containerRef.current) {
            const hammer = new Hammer__default.default(containerRef.current);
            hammer.get('pinch').set({ enable: true });
            hammer.on('pinchstart', () => {
                onPinchStart();
            });
            hammer.on('pinch', e => {
                e.srcEvent.stopPropagation();
                const newScale = Math.min(3, Math.max(0.5, prevScale.current * e.scale));
                setScaleValue(newScale);
            });
            hammer.on('pinchend', e => {
                onPinchEnd();
                prevScale.current *= e.scale;
            });
            return () => {
                hammer.destroy();
            };
        }
    }, []);
    return (jsxRuntime.jsxs("div", { style: {
            scale: scaleValue
        }, ref: containerRef, className: "w-full h-full relative flex justify-center items-center", children: [!loaded && (jsxRuntime.jsx("div", { className: "absolute top-0 left-0 w-full h-full flex justify-center items-center z-10 bg-[#00000033] backdrop-blur-2xl", children: jsxRuntime.jsx("div", { className: "w-10 h-10 p-[6px] flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "md", speed: "slow", className: "text-white" }) }) })), jsxRuntime.jsx("img", { ref: imageRef, alt: "image", src: imgObj.url, width: ((_a = imgObj.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.width) || 9999, height: ((_b = imgObj.mediaFileMetadata) === null || _b === void 0 ? void 0 : _b.height) || 9999, className: clsx__default.default('h-auto max-w-full max-h-full object-scale-down touch-none z-20', ((_c = imgObj.mediaFileMetadata) === null || _c === void 0 ? void 0 : _c.width) ? `w-[${imgObj.mediaFileMetadata.width}px]` : 'w-auto', ((_d = imgObj.mediaFileMetadata) === null || _d === void 0 ? void 0 : _d.height) ? `h-[${imgObj.mediaFileMetadata.height}px]` : 'h-auto') })] }));
}

function VideoPlayer$3({ src, triggerPlay }) {
    return (jsxRuntime.jsx("div", { className: "w-full h-full flex justify-center items-center", children: jsxRuntime.jsx("video", { src: src, className: "w-auto h-auto max-w-full max-h-full object-scale-down", disablePictureInPicture: true, controls: true, controlsList: "nodownload", autoPlay: triggerPlay }) }));
}
const MemorizedVideoPlayer$3 = React.memo(VideoPlayer$3);

function MobilePreview$1({ imgVideoList, activeIndex, publishing, onClose, publishGalleryHandle }) {
    const { type, entityInfo, imgGenerator } = React.useContext(StaticContext);
    const { id, name } = entityInfo;
    const { message } = useDisplayContext();
    const isGreeting = (message === null || message === void 0 ? void 0 : message.type) === 'GREETING';
    const [index, setIndex] = React.useState(activeIndex);
    const [zooming, setZooming] = React.useState(false);
    const { downloading, onDownload, onImageDownload } = useDownload();
    const [touchStartY, setTouchStartY] = React.useState(null);
    const [translateY, setTranslateY] = React.useState(0);
    const swiperRef = React.useRef(null);
    const sensors = useSensors();
    nextIntl.useTranslations('common');
    useNotification();
    const handleThumbnailClick = (idx) => {
        const swiper = swiperRef.current;
        if (swiper) {
            swiper.slideTo(idx);
        }
        setIndex(idx);
    };
    const handleDownload = () => {
        var _a, _b;
        console.log('aaaaaa1');
        if ((message === null || message === void 0 ? void 0 : message.type) === 'REPLY' || isGreeting) {
            onImageDownload(imgVideoList[index].url, imgVideoList[index].title || `Myshell_${name}_${dayjs__default.default().format('YYMMDD_HHmmss')}`);
        }
        else {
            onDownload(imgVideoList[index].url, imgVideoList[index].title || `Myshell_${name}_${dayjs__default.default().format('YYMMDD_HHmmss')}`);
        }
        if (sensors && sensors.track) {
            sensors === null || sensors === void 0 ? void 0 : sensors.track('MessageAction', Object.assign(Object.assign({ action_type: 'Save Image', message_id: message === null || message === void 0 ? void 0 : message.id }, (type === 'widget'
                ? {
                    widget_id: id,
                    widget_name: name
                }
                : {
                    bot_id: id,
                    bot_name: name
                })), { image_model: (_b = (_a = imgVideoList[index]) === null || _a === void 0 ? void 0 : _a.mediaFileMetadata) === null || _b === void 0 ? void 0 : _b.generateModel }));
        }
    };
    const handleIndexChange = (index) => {
        setIndex(index);
    };
    const onPinchStart = () => {
        setZooming(true);
    };
    const onPinchEnd = () => {
        setZooming(false);
    };
    const handleTouchStart = (event) => {
        event.stopPropagation();
        if (event.touches.length > 1)
            return;
        setTouchStartY(event.touches[0].clientY);
    };
    const handleTouchMove = (event) => {
        event.stopPropagation();
        if (touchStartY === null)
            return;
        const currentY = event.touches[0].clientY;
        const deltaY = currentY - touchStartY;
        setTranslateY(deltaY);
    };
    const handleTouchEnd = () => {
        if (translateY > 100) {
            onClose();
        }
        setTranslateY(0);
    };
    return (jsxRuntime.jsxs("div", { className: "flex flex-col w-full h-[100svh] bg-black overflow-hidden ease-in-out", style: {
            transform: `translateY(${translateY > 0 ? translateY : 0}px)`
        }, children: [jsxRuntime.jsxs("div", { className: "flex px-4 md:px-[6px] py-4 justify-between shrink-0", onTouchStart: handleTouchStart, onTouchMove: handleTouchMove, onTouchEnd: handleTouchEnd, children: [jsxRuntime.jsxs("div", { className: "flex justify-start", children: [jsxRuntime.jsx(IconButton, { icon: ForwardRef$T, variant: "ghost", color: "static", "aria-label": "download file", loading: downloading, onClick: handleDownload, size: "md", className: "min-w-fit w-9 h-9 rounded-full flex justify-center items-center data-[loading]:text-white", children: jsxRuntime.jsx(ForwardRef$T, { className: "w-6 h-6 text-white" }) }), imgGenerator && !isGreeting && (jsxRuntime.jsx(IconButton, { variant: "ghost", color: "static", "aria-label": "download file", loading: publishing, onClick: e => {
                                    e.stopPropagation();
                                    e.preventDefault();
                                    publishGalleryHandle === null || publishGalleryHandle === void 0 ? void 0 : publishGalleryHandle(index);
                                }, size: "md", className: "min-w-fit w-9 h-9 rounded-full flex justify-center items-center data-[loading]:text-white", children: jsxRuntime.jsx(PhotoStackIcon, { className: "size-6 text-white" }) }))] }), jsxRuntime.jsx(IconButton, { variant: "primary", size: "md", "aria-label": "close modal", icon: ForwardRef$j, onClick: onClose, className: "min-w-fit w-9 h-9 rounded-full flex justify-center items-center border-none text-static bg-beta-black-20 hover:bg-beta-black-40 active:bg-beta-black-40 shadow-none" })] }), jsxRuntime.jsx("div", { style: {
                    height: imgVideoList.length > 1 ? 'calc(100% - 120px)' : 'calc(100% - 56px)'
                }, children: jsxRuntime.jsx(Swiper, { spaceBetween: 100, slidesPerView: 1, initialSlide: activeIndex, onSwiper: swiper => {
                        swiperRef.current = swiper;
                    }, onSlideChange: swiper => {
                        handleIndexChange(swiper.realIndex);
                    }, className: "grow w-full h-full", enabled: !zooming, loop: imgVideoList.length > 1, children: imgVideoList.map((item, itemIndex) => (jsxRuntime.jsx(SwiperSlide, { children: jsxRuntime.jsx("div", { className: clsx__default.default('touch-none', item.type === EmbedObjType.VIDEO
                                ? 'w-full h-full overflow-hidden justify-center items-center relative z-10'
                                : 'absolute w-full h-full flex justify-center items-center z-10', itemIndex === index ? 'visible' : ' invisible w-0 h-0'), children: item.type === EmbedObjType.VIDEO ? (jsxRuntime.jsx(MemorizedVideoPlayer$3, { src: item.url, triggerPlay: itemIndex === index })) : (jsxRuntime.jsx(PinchZoomImage$1, { imgObj: item, onPinchStart: onPinchStart, onPinchEnd: onPinchEnd })) }) }, item.url))) }) }), imgVideoList.length > 1 && (jsxRuntime.jsx("div", { className: "flex justify-center items-center px-[6px] py-3 space-x-2 shrink-0", children: imgVideoList.length <= 4 ? (imgVideoList.map((file, idx) => (jsxRuntime.jsx(React.Fragment, { children: file.type === EmbedObjType.VIDEO ? (jsxRuntime.jsx("div", { className: clsx__default.default('rounded-md overflow-hidden h-10 object-cover cursor-pointer ease-linear duration-200 transition-[width] select-none', index === idx ? 'w-10' : 'w-7'), onClick: () => handleThumbnailClick(idx), children: jsxRuntime.jsx(MemorizedVideoOverview$1, { url: file.url, showPlayBtn: false, showRadius: false, showLoading: false }, file.url) })) : (jsxRuntime.jsx("img", { alt: "thumbnail image", src: file.url, className: clsx__default.default('rounded-md h-10 object-cover cursor-pointer ease-linear duration-200 transition-[width] select-none', index === idx ? 'w-10' : 'w-7'), onClick: () => handleThumbnailClick(idx) })) }, file.url)))) : (jsxRuntime.jsx("div", { className: "flex space-x-2", children: imgVideoList.map((file, idx) => (jsxRuntime.jsx("div", { className: clsx__default.default('rounded-full w-2 h-2', index === idx ? 'bg-white' : 'bg-[#FFFFFF33]'), onClick: () => handleThumbnailClick(idx) }, file.url))) })) }))] }));
}

var index$3 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: MobilePreview$1
});

function ImageItem$1({ imgObj, handleZoomIn, handleZoomOut, resetScaleValue, onClose }) {
    var _a, _b;
    const draggableRef = React.useRef(null);
    const [isDragging, setIsDragging] = React.useState(false);
    const [position, setPosition] = React.useState({ x: 0, y: 0 });
    const [offset, setOffset] = React.useState({ x: 0, y: 0 });
    const [loaded, setLoaded] = React.useState(false);
    const { width, height } = usehooksTs.useWindowSize();
    const timer = React.useRef(null);
    const [moved, setMoved] = React.useState(false);
    const handleLoaded = () => {
        setLoaded(true);
    };
    React.useEffect(() => {
        const imgRef = draggableRef.current;
        const handleMouseMove = (event) => {
            if (!isDragging)
                return;
            const newX = event.clientX - offset.x;
            const newY = event.clientY - offset.y;
            setPosition({ x: newX, y: newY });
            setMoved(true);
        };
        const handleMouseUp = () => {
            setIsDragging(false);
        };
        if (imgRef) {
            imgRef.addEventListener('load', handleLoaded, {
                once: true
            });
        }
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, offset]);
    const handleMouseDown = (event) => {
        if (event.button === 2) {
            return;
        }
        event.stopPropagation();
        setIsDragging(true);
        setMoved(false);
        setOffset({
            x: event.clientX - position.x,
            y: event.clientY - position.y
        });
    };
    const handleWheel = (event) => {
        if (event.deltaY === 0)
            return;
        if (event.deltaY < 0) {
            handleZoomIn();
        }
        else {
            handleZoomOut();
        }
    };
    function calculateImageSize(containerSize, imageSize) {
        let newWidth = imageSize.width;
        let newHeight = imageSize.height;
        if (imageSize.width === 0 || imageSize.height === 0) {
            return containerSize;
        }
        if (imageSize.width <= containerSize.width && imageSize.height <= containerSize.height) {
            return imageSize;
        }
        const widthRatio = containerSize.width / imageSize.width;
        const heightRatio = containerSize.height / imageSize.height;
        const ratio = Math.min(widthRatio, heightRatio);
        newWidth = imageSize.width * ratio;
        newHeight = imageSize.height * ratio;
        return {
            width: newWidth,
            height: newHeight
        };
    }
    const originDimension = React.useMemo(() => {
        var _a, _b, _c, _d;
        return calculateImageSize({ width, height: height - 80 }, { width: (_b = (_a = imgObj.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : 0, height: (_d = (_c = imgObj.mediaFileMetadata) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0 });
    }, [height, (_a = imgObj.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.height, (_b = imgObj.mediaFileMetadata) === null || _b === void 0 ? void 0 : _b.width, width]);
    const handleSingleClick = () => {
        if (moved) {
            setMoved(false);
            return;
        }
        if (timer.current) {
            clearTimeout(timer.current);
        }
        timer.current = setTimeout(() => {
            onClose();
        }, 200);
    };
    const handleDoubleClick = () => {
        if (timer.current) {
            clearTimeout(timer.current);
            resetScaleValue();
        }
    };
    return (jsxRuntime.jsxs("div", { className: clsx__default.default('w-full h-full relative flex justify-center items-center'), children: [!loaded && (jsxRuntime.jsx("div", { className: "absolute top-0 left-0 w-full h-full flex justify-center items-center z-10", children: jsxRuntime.jsx("div", { className: "flex justify-center items-center bg-[#00000033] backdrop-blur-2xl", style: Object.assign({}, originDimension), children: jsxRuntime.jsx("div", { className: "w-10 h-10 p-[6px] flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "md", speed: "slow", className: "text-white" }) }) }) })), jsxRuntime.jsx("div", { className: "image-item absolute w-full h-full top-0 left-0 z-[1]", onClick: onClose }), jsxRuntime.jsx("img", { ref: draggableRef, alt: "image", src: imgObj.url, width: originDimension.width || 9999, height: originDimension.height || 9999, draggable: true, className: clsx__default.default('object-scale-down z-20', isDragging ? 'cursor-grabbing' : 'cursor-grab'), style: {
                    transform: `translate(${position.x}px, ${position.y}px)`,
                    maxHeight: originDimension.height || '80vh'
                }, onMouseDown: handleMouseDown, onDragStart: e => e.preventDefault(), onWheel: handleWheel, onClick: handleSingleClick, onDoubleClick: handleDoubleClick })] }));
}

function SpeakerWaveIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    d: "M13.5 4.06c0-1.336-1.616-2.005-2.56-1.06l-4.5 4.5H4.508c-1.141 0-2.318.664-2.66 1.905A9.76 9.76 0 0 0 1.5 12c0 .898.121 1.768.35 2.595.341 1.24 1.518 1.905 2.659 1.905h1.93l4.5 4.5c.945.945 2.561.276 2.561-1.06V4.06ZM18.584 5.106a.75.75 0 0 1 1.06 0c3.808 3.807 3.808 9.98 0 13.788a.75.75 0 0 1-1.06-1.06 8.25 8.25 0 0 0 0-11.668.75.75 0 0 1 0-1.06Z"
  }), /*#__PURE__*/React__namespace.createElement("path", {
    d: "M15.932 7.757a.75.75 0 0 1 1.061 0 6 6 0 0 1 0 8.486.75.75 0 0 1-1.06-1.061 4.5 4.5 0 0 0 0-6.364.75.75 0 0 1 0-1.06Z"
  }));
}
const ForwardRef$1 = /*#__PURE__*/ React__namespace.forwardRef(SpeakerWaveIcon);

function SpeakerXMarkIcon({
  title,
  titleId,
  ...props
}, svgRef) {
  return /*#__PURE__*/React__namespace.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: svgRef,
    "aria-labelledby": titleId
  }, props), title ? /*#__PURE__*/React__namespace.createElement("title", {
    id: titleId
  }, title) : null, /*#__PURE__*/React__namespace.createElement("path", {
    d: "M13.5 4.06c0-1.336-1.616-2.005-2.56-1.06l-4.5 4.5H4.508c-1.141 0-2.318.664-2.66 1.905A9.76 9.76 0 0 0 1.5 12c0 .898.121 1.768.35 2.595.341 1.24 1.518 1.905 2.659 1.905h1.93l4.5 4.5c.945.945 2.561.276 2.561-1.06V4.06ZM17.78 9.22a.75.75 0 1 0-1.06 1.06L18.44 12l-1.72 1.72a.75.75 0 1 0 1.06 1.06l1.72-1.72 1.72 1.72a.75.75 0 1 0 1.06-1.06L20.56 12l1.72-1.72a.75.75 0 1 0-1.06-1.06l-1.72 1.72-1.72-1.72Z"
  }));
}
const ForwardRef = /*#__PURE__*/ React__namespace.forwardRef(SpeakerXMarkIcon);

function VideoPlayer$2({ videoObj, onClose, triggerPlay }) {
    var _a, _b, _c, _d;
    const videoRef = React.useRef(null);
    const [duration, setDuration] = React.useState(0);
    const [isPlaying, setIsPlaying] = React.useState(false);
    const [currentTime, setCurrentTime] = React.useState(0);
    const [videoHasError, setVideoHasError] = React.useState(false);
    const [muted, setMuted] = React.useState(false);
    const [volume, setVolume] = React.useState(0.5);
    const { isMobile } = useDevice();
    const [volumeBeforeMuted, setVolumeBeforeMuted] = React.useState(0.5);
    const [loaded, setLoaded] = React.useState(false);
    const { width, height } = usehooksTs.useWindowSize();
    const hoverRef = React.useRef(null);
    const isHover = usehooksTs.useHover(hoverRef);
    React.useEffect(() => {
        setIsPlaying(false);
        setCurrentTime(0);
        setDuration(0);
    }, [videoObj === null || videoObj === void 0 ? void 0 : videoObj.url]);
    usehooksTs.useEffectOnce(() => {
        const video = videoRef.current;
        if (video) {
            video.volume = 0.5;
        }
    });
    const handleVideoLoad = () => {
        const video = videoRef.current;
        setDuration(video.duration);
    };
    const handleVideoError = () => {
        setVideoHasError(true);
    };
    const handleVideoToggle = () => {
        const video = videoRef.current;
        if (video) {
            if (!video.paused) {
                video.pause();
                setIsPlaying(false);
            }
            else {
                video.play().catch(err => {
                    console.error(err, err === null || err === void 0 ? void 0 : err.stack);
                });
            }
        }
    };
    const handleVideoTimeUpdate = () => {
        const video = videoRef.current;
        if (video) {
            setCurrentTime(video.currentTime);
            if (!video.paused) {
                requestAnimationFrame(handleVideoTimeUpdate);
            }
        }
    };
    function afterPlayEnd() {
        if (videoRef.current) {
            videoRef.current.currentTime = 0;
            videoRef.current.pause();
            setIsPlaying(false);
        }
        setCurrentTime(0);
    }
    const handleVideoProgressChangeStart = () => {
        const video = videoRef.current;
        if (video) {
            if (!video.paused) {
                video.pause();
                setIsPlaying(false);
            }
        }
    };
    const handleVideoProgressChange = (newValue) => {
        const video = videoRef.current;
        if (video) {
            video.currentTime = newValue;
            setCurrentTime(video.currentTime);
        }
    };
    const handleVideoProgressChangeEnd = () => {
        const video = videoRef.current;
        if (video) {
            if (video.paused) {
                video.play().catch(err => {
                    console.error(err, err === null || err === void 0 ? void 0 : err.stack);
                });
            }
        }
    };
    const onVolumeChange = (value) => {
        const video = videoRef.current;
        if (video) {
            setVolume(value);
            video.volume = value;
            if (value === 0) {
                setMuted(true);
                setVolumeBeforeMuted(0);
            }
            else if (muted) {
                setMuted(false);
            }
        }
    };
    const toggleMuted = (state) => {
        setMuted(state);
        const video = videoRef.current;
        if (state) {
            if (video) {
                setVolumeBeforeMuted(volume);
                setVolume(0);
                video.volume = 0;
            }
        }
        if (!state) {
            if (volumeBeforeMuted !== 0) {
                if (video) {
                    setVolume(volumeBeforeMuted);
                    video.volume = volumeBeforeMuted;
                }
            }
            else if (video) {
                setVolume(0.1);
                video.volume = 0.1;
            }
        }
    };
    const handlePlay = () => {
        setIsPlaying(true);
    };
    const handleCanPlay = () => {
        handleVideoLoad();
        setLoaded(true);
    };
    React.useEffect(() => {
        const video = videoRef.current;
        video === null || video === void 0 ? void 0 : video.addEventListener('play', handlePlay);
        video === null || video === void 0 ? void 0 : video.addEventListener('canplay', handleCanPlay);
        video === null || video === void 0 ? void 0 : video.addEventListener('canplaythrough', handleCanPlay);
        if ((video === null || video === void 0 ? void 0 : video.readyState) && (video === null || video === void 0 ? void 0 : video.readyState) >= 2) {
            handleCanPlay();
        }
        return () => {
            video === null || video === void 0 ? void 0 : video.removeEventListener('play', handlePlay);
            video === null || video === void 0 ? void 0 : video.removeEventListener('canplay', handleCanPlay);
            video === null || video === void 0 ? void 0 : video.removeEventListener('canplaythrough', handleCanPlay);
        };
    }, []);
    React.useEffect(() => {
        const video = videoRef.current;
        if (video) {
            if (triggerPlay) {
                if (video.readyState >= 4) {
                    video.paused &&
                        video.play().catch(err => {
                            console.error(err, err === null || err === void 0 ? void 0 : err.stack);
                        });
                }
                else {
                    video.addEventListener('canplaythrough', () => {
                        video.paused &&
                            video.play().catch(err => {
                                console.error(err, err === null || err === void 0 ? void 0 : err.stack);
                            });
                    }, { once: true });
                }
            }
            else {
                video.pause();
                video.currentTime = 0;
                setCurrentTime(0);
            }
        }
    }, [triggerPlay]);
    function calculateMediaSize(containerSize, mediaSize) {
        let newWidth = mediaSize.width;
        let newHeight = mediaSize.height;
        if (mediaSize.width === 0 || mediaSize.height === 0) {
            return containerSize;
        }
        if (mediaSize.width <= containerSize.width && mediaSize.height <= containerSize.height) {
            return mediaSize;
        }
        const widthRatio = containerSize.width / mediaSize.width;
        const heightRatio = containerSize.height / mediaSize.height;
        const ratio = Math.min(widthRatio, heightRatio);
        newWidth = mediaSize.width * ratio;
        newHeight = mediaSize.height * ratio;
        return {
            width: newWidth,
            height: newHeight
        };
    }
    const originDimension = React.useMemo(() => {
        var _a, _b, _c, _d;
        return calculateMediaSize({ width, height: height - 80 }, { width: (_b = (_a = videoObj.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : 0, height: (_d = (_c = videoObj.mediaFileMetadata) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0 });
    }, [height, (_a = videoObj.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.height, (_b = videoObj.mediaFileMetadata) === null || _b === void 0 ? void 0 : _b.width, width]);
    return (jsxRuntime.jsxs("div", { className: "w-full h-full relative flex justify-center items-center", ref: hoverRef, children: [!loaded && (jsxRuntime.jsx("div", { className: "absolute top-0 left-0 w-full h-full flex justify-center items-center z-10", children: jsxRuntime.jsx("div", { className: "flex justify-center items-center bg-[#00000033] backdrop-blur-2xl", style: Object.assign({}, originDimension), children: jsxRuntime.jsx("div", { className: "w-10 h-10 p-[6px] flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "md", speed: "slow", className: "text-white" }) }) }) })), jsxRuntime.jsx("div", { className: "absolute w-full h-full top-0 left-0 z-[1]", onClick: onClose }), jsxRuntime.jsx("video", { src: videoObj.url, className: "object-scale-down", width: (_c = originDimension.width) !== null && _c !== void 0 ? _c : 9999, height: (_d = originDimension.height) !== null && _d !== void 0 ? _d : 9999, ref: videoRef, onEnded: afterPlayEnd, onTimeUpdate: handleVideoTimeUpdate, onError: handleVideoError, muted: muted, style: Object.assign({}, originDimension) }), isHover && loaded && (jsxRuntime.jsx("div", { className: "absolute bottom-9 w-full flex justify-center z-10", children: jsxRuntime.jsxs("div", { className: "w-[480px] h-[56px] flex space-x-2 justify-center items-center border border-default rounded-xl p-4 bg-surface-container-default text-default shadow-[0_0_2px_0_#0000001A]", children: [jsxRuntime.jsx(react.Button, { variant: "unstyled", onClick: handleVideoToggle, borderRadius: "full", "aria-label": "audio control button", isDisabled: !videoObj.url || !loaded, _disabled: {
                                opacity: 0.3,
                                cursor: 'not-allowed'
                            }, size: "sm", className: "!flex !items-center !justify-center text-default w-9 h-9", children: isPlaying ? jsxRuntime.jsx(ForwardRef$g, { className: "w-6 h-6" }) : jsxRuntime.jsx(ForwardRef$f, { className: "w-6 h-6" }) }), jsxRuntime.jsx("span", { className: "text-subtle text-xs shrink-0", children: durationFormatter(currentTime) }), jsxRuntime.jsxs(react.Slider, { min: 0, max: duration, value: currentTime, onChangeStart: handleVideoProgressChangeStart, onChange: (value) => handleVideoProgressChange(value), onChangeEnd: handleVideoProgressChangeEnd, focusThumbOnChange: false, isDisabled: !loaded, className: "flex items-center w-full h-6 cursor-pointer", children: [jsxRuntime.jsx(react.SliderTrack, { className: "bg-[#EDF0F5] dark:bg-[#22242E]", children: jsxRuntime.jsx(react.SliderFilledTrack, { className: "bg-surface-primary-default" }) }), jsxRuntime.jsx(react.SliderThumb, { className: "bg-surface-primary-default border-[2px] border-white" })] }), jsxRuntime.jsx("span", { className: "text-subtle text-xs shrink-0", children: durationFormatter(duration) }), jsxRuntime.jsxs(react.Popover, { placement: "top", trigger: isMobile ? 'click' : 'hover', offset: [0, 8], closeOnBlur: true, openDelay: 100, children: [jsxRuntime.jsx(react.PopoverTrigger, { children: jsxRuntime.jsx("div", { children: muted ? (jsxRuntime.jsx(ForwardRef, { className: "w-5 h-5 text-default cursor-pointer", onClick: () => toggleMuted(false) })) : (jsxRuntime.jsx(ForwardRef$1, { className: "w-5 h-5 text-default cursor-pointer", onClick: () => toggleMuted(true) })) }) }), jsxRuntime.jsx(react.PopoverContent, { className: "rounded-lg p-3 border border-default w-8 h-[121px] bg-surface-container-default text-default shadow-lg", children: jsxRuntime.jsx(react.PopoverBody, { className: "p-0 flex justify-center items-center", children: jsxRuntime.jsxs(react.Slider, { orientation: "vertical", min: 0, max: 1, step: 0.01, value: volume, onChange: onVolumeChange, focusThumbOnChange: false, className: "h-[97px]", children: [jsxRuntime.jsx(react.SliderTrack, { className: "bg-[#EDF0F5] dark:bg-[#22242E] w-[2px]", children: jsxRuntime.jsx(react.SliderFilledTrack, { className: "bg-surface-primary-default" }) }), jsxRuntime.jsx(react.SliderThumb, { className: "bg-surface-primary-default border-[2px] border-surface-container-default" })] }) }) })] })] }) }))] }));
}
const MemorizedVideoPlayer$2 = React.memo(VideoPlayer$2);

function Preview$1({ imgVideoList, activeIndex, publishing, onClose, publishGalleryHandle }) {
    const { message } = useDisplayContext();
    const { imgGenerator, entityInfo, type } = React.useContext(StaticContext);
    const { id, name } = entityInfo;
    const isGreeting = (message === null || message === void 0 ? void 0 : message.type) === 'GREETING';
    const [index, setIndex] = React.useState(activeIndex);
    const [scaleValue, setScaleValue] = React.useState(1);
    const scaleStep = 0.1;
    const chatT = nextIntl.useTranslations('chat');
    const sensors = useSensors();
    const { downloading, onDownload, onImageDownload } = useDownload();
    const flagUserFirstPublishGallery = useUserStore(state => state.flagUserFirstPublishGallery);
    const handleDownload = () => {
        var _a;
        console.log('aaaaaa2');
        const media_file_url = imgVideoList[index].url;
        if ((message === null || message === void 0 ? void 0 : message.type) === 'REPLY' || isGreeting) {
            onImageDownload(media_file_url, imgVideoList[index].title || `Myshell_${name}_${dayjs__default.default().format('YYMMDD_HHmmss')}`);
        }
        else {
            onDownload(media_file_url, imgVideoList[index].title || `Myshell_${name}_${dayjs__default.default().format('YYMMDD_HHmmss')}`);
        }
        if (sensors && sensors.track) {
            const imageModel = (_a = imgVideoList[index].mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.generateModel;
            if (imageModel) {
                sensors === null || sensors === void 0 ? void 0 : sensors.track('MessageAction', Object.assign(Object.assign({ action_type: 'Save Image', message_id: message === null || message === void 0 ? void 0 : message.id }, (type === 'widget'
                    ? {
                        widget_id: id,
                        widget_name: name
                    }
                    : {
                        bot_id: id,
                        bot_name: name
                    })), { image_model: imageModel }));
            }
            else {
                mediaFileMetadata({
                    media_file_url
                })
                    .then(res => {
                    var _a;
                    sensors === null || sensors === void 0 ? void 0 : sensors.track('MessageAction', Object.assign(Object.assign({ action_type: 'Save Image', message_id: message === null || message === void 0 ? void 0 : message.id }, (type === 'widget'
                        ? {
                            widget_id: id,
                            widget_name: name
                        }
                        : {
                            bot_id: id,
                            bot_name: name
                        })), { image_model: (_a = res === null || res === void 0 ? void 0 : res.meta) === null || _a === void 0 ? void 0 : _a.generateModel }));
                })
                    .catch(() => {
                    sensors === null || sensors === void 0 ? void 0 : sensors.track('MessageAction', Object.assign(Object.assign({ action_type: 'Save Image', message_id: message === null || message === void 0 ? void 0 : message.id }, (type === 'widget'
                        ? {
                            widget_id: id,
                            widget_name: name
                        }
                        : {
                            bot_id: id,
                            bot_name: name
                        })), { image_model: '' }));
                });
            }
        }
    };
    const selectedItem = React.useMemo(() => {
        return imgVideoList[index];
    }, [imgVideoList, index]);
    React.useEffect(() => {
        const handleKeyDown = (e) => {
            switch (e.key) {
                case 'ArrowLeft':
                    handleGoToPrev();
                    break;
                case 'ArrowRight':
                    handleGoToNext();
                    break;
                case 'ArrowUp':
                    handleZoomIn();
                    break;
                case 'ArrowDown':
                    handleZoomOut();
                    break;
            }
        };
        document.addEventListener('keydown', handleKeyDown);
        return () => {
            document.removeEventListener('keydown', handleKeyDown);
        };
    }, []);
    const resetScaleValue = () => {
        setScaleValue(1);
    };
    React.useEffect(() => {
        setScaleValue(1);
    }, [index]);
    const handleZoomIn = React.useCallback(() => {
        if (scaleValue >= 3) ;
        else {
            setScaleValue(scaleValue + scaleStep);
        }
    }, [scaleValue]);
    const handleZoomOut = React.useCallback(() => {
        if (scaleValue <= 0.5) ;
        else {
            setScaleValue(scaleValue - scaleStep);
        }
    }, [scaleValue]);
    const handleGoToPrev = React.useCallback(() => {
        setIndex(index < 1 ? imgVideoList.length - 1 : index - 1);
    }, [imgVideoList.length, index]);
    const handleGoToNext = React.useCallback(() => {
        setIndex(index === imgVideoList.length - 1 ? 0 : index + 1);
    }, [imgVideoList.length, index]);
    return (jsxRuntime.jsxs("div", { className: "w-full h-screen overflow-hidden flex flex-col", children: [jsxRuntime.jsxs("div", { className: "relative flex justify-center w-full", style: {
                    height: 'calc(100vh - 80px)'
                }, children: [jsxRuntime.jsx(IconButton, { icon: ForwardRef$j, size: "md", className: "flex justify-center items-center w-9 h-9 absolute top-6 right-6 z-50 cursor-pointer rounded-full border border-none text-static bg-beta-black-20 hover:bg-beta-black-40 active:bg-beta-black-40 shadow-none", onClick: onClose }), jsxRuntime.jsx("div", { className: "img-video-index absolute w-full h-full top-0 left-0 z-[1]" }), imgVideoList.length > 1 && (jsxRuntime.jsx("div", { onClick: handleGoToPrev, className: "flex justify-center items-center w-9 h-9 rounded-full absolute left-6 md:left-6 top-1/2 -translate-y-1/2 bg-surface-container-default cursor-pointer z-20 shadow-button-basic border border-default", children: jsxRuntime.jsx(ForwardRef$I, { className: "text-subtle w-6 h-6" }) })), jsxRuntime.jsx(framerMotion.AnimatePresence, { mode: "popLayout", children: imgVideoList.map((item, itemIndex) => (jsxRuntime.jsx(framerMotion.motion.div, { initial: { opacity: 0 }, animate: { opacity: itemIndex === index ? 1 : 0 }, exit: { opacity: 0 }, transition: { duration: 0.2 }, className: clsx__default.default(item.type === EmbedObjType.VIDEO
                                ? 'max-w-3/4 h-full overflow-hidden justify-center items-center relative z-10'
                                : 'absolute w-full h-full flex justify-center items-center z-10', itemIndex === index ? 'visible' : ' invisible w-0 h-0'), style: {
                                scale: scaleValue
                            }, children: item.type === EmbedObjType.VIDEO ? (jsxRuntime.jsx(MemorizedVideoPlayer$2, { videoObj: item, triggerPlay: itemIndex === index, onClose: onClose })) : (jsxRuntime.jsx(ImageItem$1, { imgObj: item, handleZoomIn: handleZoomIn, handleZoomOut: handleZoomOut, resetScaleValue: resetScaleValue, onClose: onClose })) }, item.url))) }), imgVideoList.length > 1 && (jsxRuntime.jsx("div", { onClick: handleGoToNext, className: "flex justify-center items-center w-9 h-9 rounded-full absolute right-6 md:right-11 top-1/2 -translate-y-1/2 bg-surface-container-default cursor-pointer z-20 shadow-button-basic border border-default", children: jsxRuntime.jsx(ForwardRef$H, { className: "text-subtle w-6 h-6" }) }))] }), jsxRuntime.jsxs("div", { className: "h-20 w-full px-6 py-3 flex justify-between items-center shrink-0 relative z-20", children: [jsxRuntime.jsx("div", { className: "absolute w-full h-full top-0 left-0 z-30", onClick: onClose }), selectedItem.type === EmbedObjType.IMAGE ? (jsxRuntime.jsx("div", { className: "flex justify-end items-center space-x-2", children: jsxRuntime.jsxs("div", { className: "rounded-xl bg-beta-black-20 px-3 flex space-x-[6px] items-center h-[38px] relative z-50", style: {
                                backdropFilter: 'blur(12px)'
                            }, children: [jsxRuntime.jsx(ForwardRef$u, { className: "w-5 h-5 text-beta-white-70 cursor-pointer", onClick: handleZoomOut }), jsxRuntime.jsxs(react.Slider, { width: "72px", value: scaleValue, min: 0.5, max: 3, step: scaleStep, onChange: (value) => {
                                        setScaleValue(value);
                                    }, focusThumbOnChange: false, children: [jsxRuntime.jsx(react.SliderTrack, { className: "bg-[#EDF0F5] dark:bg-[#22242E]", children: jsxRuntime.jsx(react.SliderFilledTrack, { className: "bg-surface-primary-default" }) }), jsxRuntime.jsx(react.SliderThumb, { className: "bg-surface-primary-default border-[2px] border-surface-container-default", zIndex: 0 })] }), jsxRuntime.jsx(ForwardRef$n, { className: "w-5 h-5 text-beta-white-70 cursor-pointer", onClick: handleZoomIn })] }) })) : (jsxRuntime.jsx("div", { className: "w-[150px]", onClick: onClose })), imgVideoList.length > 1 && (jsxRuntime.jsx("div", { className: "flex space-x-2 relative z-50", children: imgVideoList.map((file, idx) => (jsxRuntime.jsx(React.Fragment, { children: file.type === EmbedObjType.VIDEO ? (jsxRuntime.jsx("div", { className: clsx__default.default('rounded-md overflow-hidden h-14 object-cover cursor-pointer ease-linear duration-200 transition-[width] select-none', index === idx ? 'w-14' : 'w-7'), onClick: () => setIndex(idx), children: jsxRuntime.jsx(MemorizedVideoOverview$1, { url: file.url, showPlayBtn: false, showRadius: false, showLoading: false }, file.url) })) : (jsxRuntime.jsx("img", { alt: "thumbnail image", src: file.url, className: clsx__default.default('rounded-md h-14 object-cover cursor-pointer ease-linear duration-200 transition-[width] select-none', index === idx ? 'w-14' : 'w-7'), onClick: () => setIndex(idx) })) }, file.url))) })), jsxRuntime.jsxs("div", { className: "flex justify-end relative z-50", children: [imgGenerator && !isGreeting && (jsxRuntime.jsx(Tooltip, { open: !flagUserFirstPublishGallery ? true : undefined, description: flagUserFirstPublishGallery ? chatT('publish_to_gallery') : chatT('publish_battery'), variant: flagUserFirstPublishGallery ? 'default' : 'message', children: jsxRuntime.jsx(IconButton, { loading: publishing, onClick: e => {
                                        e.stopPropagation();
                                        e.preventDefault();
                                        publishGalleryHandle === null || publishGalleryHandle === void 0 ? void 0 : publishGalleryHandle(index);
                                    }, variant: "primary", color: "brand", size: "md", className: "relative z-30 bg-beta-black-20 hover:bg-beta-black-40 active:bg-beta-black-40 ml-2 shadow-none text-inherit", children: jsxRuntime.jsx(PhotoStackIcon, { className: "size-5.5 text-icon-static" }) }) })), jsxRuntime.jsx("div", { className: "absolute w-full h-full top-0 left-0", onClick: onClose }), jsxRuntime.jsx(IconButton, { variant: "primary", color: "brand", size: "md", "aria-label": "download file", loading: downloading, onClick: handleDownload, className: "relative z-30 bg-beta-black-20 hover:bg-beta-black-40 active:bg-beta-black-40 ml-2 shadow-none", icon: ForwardRef$T })] })] })] }));
}

var index$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: Preview$1
});

const CustomCheckbox = React.forwardRef((props, ref) => {
    const { name, setFormValue } = props;
    return (jsxRuntime.jsx(react.Checkbox, Object.assign({}, props, { ref: ref, colorScheme: "brand", className: "square-checkbox ml-2 text-default", size: "lg", isChecked: props.default, onChange: v => {
            const checked = v.target.checked;
            setFormValue(name, checked);
        }, children: props.name })));
});

const CustomNumberInput = React.forwardRef((props, ref) => {
    const { minLength, maxLength, value, name, setFormValue, errors, setError, type } = props;
    const isEmptyError = (errors === null || errors === void 0 ? void 0 : errors.type) === 'required';
    const chatT = nextIntl.useTranslations('chat');
    const [numberError, setNumberError] = React.useState('');
    const rest = {};
    if (minLength != undefined)
        rest.min = minLength;
    if (maxLength != undefined)
        rest.max = maxLength;
    React.useEffect(() => {
        var _a;
        (_a = document.getElementById(`component_bot_numberinput_${name}`)) === null || _a === void 0 ? void 0 : _a.blur();
    }, []);
    return (jsxRuntime.jsxs("div", { className: "w-full", children: [jsxRuntime.jsxs(react.NumberInput, Object.assign({}, rest, { precision: type === 'interInput' ? 0 : 2, step: type === 'interInput' ? 1 : 0.01, defaultValue: value, onFocus: false, onChange: value => {
                    const num = Number(value);
                    if (!isNaN(num) && typeof num === 'number') {
                        setFormValue(name, num);
                    }
                }, onBlur: value => {
                    const num = value;
                    if (minLength != undefined && num < minLength) {
                        setFormValue(name, minLength);
                        setNumberError(chatT('replicate.input_min_tip', {
                            num: minLength
                        }));
                    }
                    else if (maxLength != undefined && num > maxLength) {
                        setFormValue(name, maxLength);
                        setNumberError(chatT('replicate.input_max_tip', {
                            num: maxLength
                        }));
                    }
                    else if (!Number.isNaN(num)) {
                        setNumberError('');
                    }
                }, ref: ref, className: "w-full", children: [jsxRuntime.jsx(react.NumberInputField, { tabIndex: -1, id: `component_bot_numberinput_${name}`, className: "h-[44px] rounded-[12px] border-default hover:border-hovered focus:outline focus:outline-none focus-visible:border-pressed focus-visible:outline-offset-0 focus-visible:outline-utility-sky-blue-500 focus-visible:shadow-none" }), jsxRuntime.jsxs(react.NumberInputStepper, { className: "space-y-[2px] py-1 mr-2", children: [jsxRuntime.jsx(react.NumberIncrementStepper, { className: "text-default rounded-[6px] w-5 h-3 bg-[#EDEEEF] dark:bg-[#6D7175] border-none" }), jsxRuntime.jsx(react.NumberDecrementStepper, { className: "text-default rounded-[6px] w-5 h-3 bg-[#EDEEEF] dark:bg-[#6D7175] border-none" })] })] })), numberError != '' && jsxRuntime.jsx("p", { className: "text-[#D72C0D] text-[14px] mt-1.5", children: numberError }), isEmptyError && (jsxRuntime.jsx("p", { className: "text-[#D72C0D] text-[14px] mt-1.5", children: chatT('replicate.input_required_tip', { fieldName: name }) }))] }));
});

var __rest$2 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function Control(_a) {
    var { children } = _a, props = __rest$2(_a, ["children"]);
    const { className } = props, rest = __rest$2(props, ["className"]);
    const { selectProps } = props;
    const hasError = selectProps.errors;
    return (jsxRuntime.jsx(Select.components.Control, Object.assign({}, rest, { className: clsx__default.default('bg-surface-default rounded-xl shadow-none px-3 py-1', className, hasError ? 'border-[#D72C0D]' : 'border-default border-hovered'), children: children })));
}
function Menu(_a) {
    var { children } = _a, props = __rest$2(_a, ["children"]);
    return (jsxRuntime.jsx(Select.components.Menu, Object.assign({}, props, { className: "p-2 bg-surface-default overflow-hidden rounded-xl shadow-md z-[99] pb-4 dark:border dark:border-default", children: children })));
}
function MenuList(_a) {
    var { children } = _a, props = __rest$2(_a, ["children"]);
    return jsxRuntime.jsx(Select.components.MenuList, Object.assign({}, props, { children: children }));
}
function Option(_a) {
    var { children } = _a, props = __rest$2(_a, ["children"]);
    return jsxRuntime.jsx(Select.components.Option, Object.assign({}, props, { children: children }));
}
function ValueContainer(_a) {
    var { children } = _a, props = __rest$2(_a, ["children"]);
    return jsxRuntime.jsx(Select.components.ValueContainer, Object.assign({}, props, { children: children }));
}
function IndicatorSeparator(_a) {
    __rest$2(_a, []);
    return null;
}
function DropdownIndicator(_a) {
    var { children } = _a, props = __rest$2(_a, ["children"]);
    return (jsxRuntime.jsx(Select.components.DropdownIndicator, Object.assign({}, props, { className: "text-default", children: children })));
}
function SelectItem({ item, className }) {
    return (jsxRuntime.jsxs("div", { className: clsx__default.default('flex flex-row justify-start cursor-pointer', className), children: [(item === null || item === void 0 ? void 0 : item.iconUrl) ? (jsxRuntime.jsx("div", { className: "aspect-[24/24] w-6 h-6 relative bg-cover bg-no-repeat rounded-full overflow-hidden mr-2", style: Object.assign({}, ((item === null || item === void 0 ? void 0 : item.iconUrl) && { backgroundImage: `url('${item === null || item === void 0 ? void 0 : item.iconUrl}')` })) })) : null, jsxRuntime.jsx("span", { className: "text-[14px]", children: item === null || item === void 0 ? void 0 : item.label })] }));
}
const CustomSelect = React.forwardRef((props, ref) => {
    const { components = {}, options = [], name, setFormValue, value, type } = props, rest = __rest$2(props, ["components", "options", "name", "setFormValue", "value", "type"]);
    return (jsxRuntime.jsx(Select__default.default, Object.assign({}, rest, { ref: ref, options: options, menuPlacement: "auto", isSearchable: false, defaultValue: value, placeholder: value, onChange: (data) => {
            setFormValue(name, type === 'numberCheckbox' ? Number(data.value) : data.value);
        }, components: {
            Control: components.Control ? components.Control : Control,
            Menu,
            MenuList,
            ValueContainer,
            IndicatorSeparator,
            DropdownIndicator,
            Option: (_a) => {
                var props = __rest$2(_a, ["children"]);
                const { data } = props;
                return (jsxRuntime.jsx(Option, Object.assign({}, props, { children: jsxRuntime.jsx(SelectItem, { item: data, className: cn('option', (data === null || data === void 0 ? void 0 : data.value) === value ? 'text-static' : '') }) })));
            },
            Placeholder: (_a) => {
                var props = __rest$2(_a, ["children"]);
                const { options } = props;
                const item = options.find((opt) => `${opt.value}`.toLowerCase() == `${value}`.toLowerCase());
                return jsxRuntime.jsx(SelectItem, { item: item, className: "placeholder" });
            },
            SingleValue: (_a) => {
                var props = __rest$2(_a, ["children"]);
                const { data } = props;
                return jsxRuntime.jsx(SelectItem, { item: data, className: "single" });
            }
        }, classNames: {
            placeholder: () => 'text-default',
            valueContainer: () => 'p-0 flex',
            option: (data) => {
                return cn('relative cursor-pointer py-1.5 px-2 rounded-md mt-1', (data === null || data === void 0 ? void 0 : data.value) === value ? '' : 'hover:bg-surface-pressed');
            }
        }, menuPosition: "fixed", styles: {
            control: styles => (Object.assign(Object.assign({}, styles), { background: 'bg-surface-default' })),
            menu: provided => (Object.assign(Object.assign({}, provided), { zIndex: '999', marginBottom: '40px' })),
            option: (styles, { data, isDisabled, isFocused, isSelected }) => {
                const item = data;
                const isPrimary = isSelected || (item === null || item === void 0 ? void 0 : item.value) === value;
                return Object.assign(Object.assign({}, styles), { backgroundColor: isPrimary ? 'var(--surface-primary-default)' : 'var(--surface-default)', color: isPrimary && !isFocused ? 'white' : 'var(--text)' });
            }
        } })));
});

var __rest$1 = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const CustomTextarea = React.forwardRef((props, ref) => {
    const { className, value, setFormValue, name, errors, clearErrors } = props, rest = __rest$1(props, ["className", "value", "setFormValue", "name", "errors", "clearErrors"]);
    const isEmptyError = (errors === null || errors === void 0 ? void 0 : errors.type) === 'required';
    const chatT = nextIntl.useTranslations('chat');
    React.useEffect(() => {
        var _a;
        (_a = document.getElementById(`component_bot_textarea_${name}`)) === null || _a === void 0 ? void 0 : _a.blur();
    }, []);
    return (jsxRuntime.jsxs("div", { className: "w-full", children: [jsxRuntime.jsxs("div", { className: "w-full relative", children: [jsxRuntime.jsx(react.Textarea, Object.assign({}, rest, { id: `component_bot_textarea_${name}`, onFocus: false, defaultValue: value, tabIndex: -1, onChange: v => {
                            if (v.target.value != '') {
                                clearErrors(name);
                            }
                            setFormValue(name, v.target.value);
                        }, ref: ref, className: clsx__default.default('w-full', isEmptyError ? 'border-[#D72C0D]' : 'border-default hover:border-hovered') })), rest.maxLength ? (jsxRuntime.jsxs("span", { className: "absolute right-3 bottom-3 text-subtlest text-xs", children: [(value !== null && value !== void 0 ? value : '').length, "/", rest.maxLength] })) : null] }), isEmptyError && (jsxRuntime.jsx("p", { className: "text-[#D72C0D] text-[14px] mt-1.5", children: chatT('replicate.input_required_tip', { fieldName: name }) }))] }));
});

const AudioPlayer = (props) => {
    const audioRef = React.useRef(null);
    const [duration, setDuration] = React.useState(0);
    const [isPlaying, setIsPlaying] = React.useState(false);
    const [currentTime, setCurrentTime] = React.useState(0);
    const [audioHasError, setAudioHasError] = React.useState(false);
    const src = props.preview;
    const { status, file } = props.data;
    const isSuccess = status === 'completed';
    function afterPlayEnd() {
        if (audioRef.current) {
            audioRef.current.currentTime = 0;
        }
        setIsPlaying(false);
    }
    const AudioComponent = useAudioPlayer();
    const handleAudioLoad = () => {
        URL.revokeObjectURL(src);
        const audio = audioRef === null || audioRef === void 0 ? void 0 : audioRef.current;
        setDuration(audio.duration);
    };
    const handleAudioToggle = () => {
        var _a;
        if (audioRef.current) {
            if (audioRef.current.paused) {
                audioRef.current
                    .play()
                    .then(() => {
                    setIsPlaying(true);
                })
                    .catch(err => {
                    console.error(err, err === null || err === void 0 ? void 0 : err.stack);
                });
            }
            else {
                (_a = audioRef.current) === null || _a === void 0 ? void 0 : _a.pause();
                setIsPlaying(false);
            }
        }
    };
    const handleAudioTimeUpdate = () => {
        const audio = audioRef.current;
        if (audio) {
            setCurrentTime(audio.currentTime);
            if (!audio.paused) {
                requestAnimationFrame(handleAudioTimeUpdate);
            }
        }
    };
    const handleAudioError = () => {
        setAudioHasError(true);
    };
    const curDuration = duration;
    const UIDuration = !curDuration
        ? durationFormatter(0)
        : curDuration < 1
            ? durationFormatter(1)
            : durationFormatter(curDuration);
    return (jsxRuntime.jsxs("div", { className: clsx__default.default('audio-player flex flex-col justify-start items-start w-full'), children: [jsxRuntime.jsxs("div", { className: "w-full flex flex-col items-start justify-start space-y-3 text-xs", children: [isSuccess && (jsxRuntime.jsxs("div", { className: "flex", children: [jsxRuntime.jsx("button", { className: clsx__default.default('w-9 h-9 rounded-full flex justify-center items-center mr-3', isPlaying ? 'bg-surface-primary-default' : 'bg-surface-container-selected-hovered'), onClick: handleAudioToggle, children: isPlaying ? (jsxRuntime.jsx(AudioPlaying, {})) : (jsxRuntime.jsx(ForwardRef$f, { className: "ml-[2px] fill-surface-primary-default w-[16px] h-[16px]" })) }), jsxRuntime.jsxs("div", { className: "flex flex-col justify-center items-start space-y-1", children: [jsxRuntime.jsx("p", { className: "mr-5 text-[14px] font-semibold text-default", children: file === null || file === void 0 ? void 0 : file.name }), (file === null || file === void 0 ? void 0 : file.size) > 0 && (jsxRuntime.jsxs("p", { className: "text-[12px] text-subtle", children: [jsxRuntime.jsx("span", { className: "mr-1", children: UIDuration }), "(", Math.ceil(file.size / 1000), "KB)"] }))] })] })), jsxRuntime.jsxs("div", { className: "w-full flex justify-center items-center space-x-2", children: [jsxRuntime.jsxs("div", { className: "relative flex flex-col justify-center items-start h-[8px] w-full", children: [jsxRuntime.jsx("div", { className: "relative w-full h-[2px] bg-[#DADFE5] dark:bg-[#383C52]" }), jsxRuntime.jsxs("div", { className: "absolute w-full flex flex-row justify-start items-center", children: [jsxRuntime.jsx("div", { className: "bg-[var(--text)] h-[2px] w-full items-start", style: { width: `${getPercent(currentTime, curDuration) * 100}%` } }), jsxRuntime.jsx("div", { className: "w-[7px] h-[7px] rounded-full bg-[var(--text)]" })] })] }), jsxRuntime.jsx("div", { className: `text-default text-sm dark:text-brand text-right`, children: isPlaying ? durationFormatter(currentTime) : UIDuration })] })] }), jsxRuntime.jsx(AudioComponent, { ref: audioRef, src: src, onLoadedData: handleAudioLoad, onEnded: afterPlayEnd, onTimeUpdate: handleAudioTimeUpdate, onError: handleAudioError, autoPlay: false })] }));
};

const FileDisplay = ({ data, onDelete }) => {
    var _a, _b, _c;
    const { status, uiData } = data;
    const isSuccess = status === 'completed';
    const isFile = uiData.mimeType === 'application' || uiData.mimeType === 'text' || uiData.mimeType === 'other';
    const isImage = uiData.mimeType === 'image';
    const isAudio = uiData.mimeType === 'audio';
    const isVideo = uiData.mimeType === 'video';
    const { iconUrl } = uiData;
    const [viewModalVisible, setViewModalVisible] = React.useState(false);
    const previewUrl = React.useMemo(() => {
        if (data === null || data === void 0 ? void 0 : data.defaultUrl)
            return data === null || data === void 0 ? void 0 : data.defaultUrl;
        if (data.file) {
            return ['image', 'audio', 'video'].includes(uiData === null || uiData === void 0 ? void 0 : uiData.mimeType) ? URL.createObjectURL(data.file) : '';
        }
        return '';
    }, []);
    const handleDelete = (e) => {
        e.stopPropagation();
        e.preventDefault();
        const el = document.getElementById('mobileInput');
        if (el) {
            el.focus();
        }
        onDelete();
    };
    const { isMobile } = usePathLocale();
    const fileName = (_a = data === null || data === void 0 ? void 0 : data.file) === null || _a === void 0 ? void 0 : _a.name;
    let fileShowName = fileName;
    const arr = fileName.split('.');
    const len = isMobile ? 20 : 60;
    if (fileName.length > len && arr.length > 1) {
        const ex = arr[arr.length - 1];
        fileShowName = `${fileName.slice(0, len)}...${ex}`;
    }
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("div", { className: "relative cursor-default w-full flex justify-start items-center", onClick: e => {
                    e.preventDefault();
                    const el = document.getElementById('mobileInput');
                    if (el) {
                        el.focus();
                    }
                }, children: [isFile && (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [isSuccess && (jsxRuntime.jsx("div", { className: "flex-shrink-0 w-[60px] h-[60px] rounded-[8px] mr-3", children: jsxRuntime.jsx("img", { src: iconUrl, className: "w-[60px] h-[60px]" }) })), jsxRuntime.jsxs("div", { className: "w-full flex flex-col justify-center items-start space-y-1", children: [jsxRuntime.jsx("span", { className: "text-[14px] text-default line-clamp-1 break-all font-medium", children: data.file.name }), jsxRuntime.jsxs("span", { className: "text-[12px] text-subtle line-clamp-1 break-all", children: ["(", Math.ceil((data === null || data === void 0 ? void 0 : data.file.size) / 1000), "KB)"] })] })] })), isImage && (jsxRuntime.jsxs("div", { className: "w-full flex justify-start items-center cursor-pointer", onClick: () => {
                            setViewModalVisible(true);
                        }, children: [jsxRuntime.jsx("img", { src: previewUrl, className: "flex-shrink-0 w-[60px] h-[60px] object-cover rounded-[8px] overflow-hidden mr-2", onLoad: () => {
                                    URL.revokeObjectURL(previewUrl);
                                }, alt: "preview image" }), jsxRuntime.jsxs("div", { className: "flex flex-col justify-center items-start space-y-1", children: [jsxRuntime.jsx("p", { className: "mr-4 text-[14px] font-medium text-default", children: fileShowName }), ((_b = data === null || data === void 0 ? void 0 : data.file) === null || _b === void 0 ? void 0 : _b.size) > 0 && (jsxRuntime.jsxs("p", { className: "text-[12px] text-subtle", children: ["(", Math.ceil((data === null || data === void 0 ? void 0 : data.file.size) / 1000), "KB)"] }))] })] })), isVideo && (jsxRuntime.jsxs("div", { className: clsx__default.default('relative w-full flex overflow-hidden cursor-pointer'), onClick: () => {
                            setViewModalVisible(true);
                        }, children: [jsxRuntime.jsx("video", { src: (data === null || data === void 0 ? void 0 : data.url) || previewUrl, className: "flex-shrink-0 w-[60px] h-[60px] rounded-[8px] mr-2 object-fill overflow-hidden", onLoad: () => {
                                    URL.revokeObjectURL(previewUrl);
                                } }), jsxRuntime.jsxs("div", { className: "flex flex-col justify-center items-start space-y-1", children: [jsxRuntime.jsx("p", { className: "mr-4 text-[14px] font-medium text-default", children: fileShowName }), ((_c = data === null || data === void 0 ? void 0 : data.file) === null || _c === void 0 ? void 0 : _c.size) > 0 && (jsxRuntime.jsxs("p", { className: "text-[12px] text-subtle", children: ["(", Math.ceil((data === null || data === void 0 ? void 0 : data.file.size) / 1000), "KB)"] }))] })] })), isAudio && jsxRuntime.jsx(AudioPlayer, { data: data, preview: previewUrl }), jsxRuntime.jsx("button", { className: clsx__default.default('w-5 h-5 justify-center items-center', isAudio ? 'absolute z-[1] right-0 top-[10px]' : ''), onClick: e => handleDelete(e), children: jsxRuntime.jsx(ForwardRef$d, { className: "w-5 h-5 text-subtle" }) })] }), viewModalVisible && (jsxRuntime.jsx(ImgVideoPreview, { open: viewModalVisible, onClose: () => {
                    setViewModalVisible(false);
                }, imgVideoList: [
                    {
                        type: isVideo ? EmbedObjType.VIDEO : isImage ? EmbedObjType.IMAGE : EmbedObjType.DOC,
                        status: EmbedObjStatus.DONE,
                        iconUrl: '',
                        url: previewUrl,
                        title: '',
                        extensionName: ''
                    }
                ], activeIndex: 0 }))] }));
};

const defaultMaxSize = 50 * 1024 ** 2;
const enableMIME = {
    audio: {
        '.mp3': 'audio/mpeg',
        '.wav': 'audio/wav',
        '.ogg': 'audio/ogg',
        '.wma': 'audio/x-ms-wma',
        '.flac': 'audio/flac',
        '.ape': 'audio/ape'
    },
    video: {
        '.mp4': 'video/mp4',
        '.avi': 'video/x-msvideo',
        '.mov': 'video/quicktime',
        '.wmv': 'video/x-ms-wmv',
        '.flv': 'video/x-flv'
    },
    other: {
        '.rtf': 'application/rtf',
        '.md': 'text/markdown',
        '.markdown': 'text/markdown',
        '.pdf': 'application/pdf',
        '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        '.doc': 'application/msword',
        '.txt': 'text/plain',
        '.csv': 'text/csv'
    },
    image: {
        '.png': 'image/png',
        '.jpeg': 'image/jpeg',
        '.jpg': 'image/jpg'
    },
    all: {
        '*': '*/*'
    }
};
const ex2MIME = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, enableMIME.audio), enableMIME.video), enableMIME.other), enableMIME.image), enableMIME.all);
const fileUIData = {
    md: {
        icon: 'other',
        type: 'Markdown File',
        bg: '#6F8BB5',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/Other.svg'
    },
    markdown: {
        icon: 'other',
        type: 'Markdown File',
        bg: '#6F8BB5',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/Other.svg'
    },
    pdf: {
        icon: 'PDF',
        type: 'PDF',
        bg: '#EA3434',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/PDF.svg'
    },
    docx: {
        icon: 'W',
        type: 'Word File',
        bg: '#2684FF',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/Word.svg'
    },
    doc: {
        icon: 'W',
        type: 'Word File',
        bg: '#2684FF',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/Word.svg'
    },
    txt: {
        icon: 'T',
        type: 'TXT',
        bg: '#6F8BB5',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/TXT.svg'
    },
    csv: {
        icon: 'CSV',
        type: 'CSV',
        bg: '#079455',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2024053011/embed_icon/CSV.svg'
    },
    other: {
        icon: 'other',
        type: 'Rich Text File',
        bg: '#6F8BB5',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/Other.svg'
    },
    all: {
        icon: 'all',
        type: 'All File',
        bg: '#6F8BB5',
        iconUrl: 'https://www.myshellstatic.com/image/bot/icon/2023112610/embed_icon/Other.svg'
    }
};
const supportFiles = Object.values(enableMIME).flatMap(category => {
    return Object.keys(category);
});
const serverFileTypes = {
    audio: 'MESSAGE_METADATA_TYPE_AUDIO_FILE',
    image: 'MESSAGE_METADATA_TYPE_IMAGE_FILE',
    other: 'MESSAGE_METADATA_TYPE_TEXT_FILE',
    video: 'MESSAGE_METADATA_TYPE_VIDEO_FILE',
    all: 'MESSAGE_METADATA_TYPE_ALL_FILE'
};
const serverFileTypes2Local = Object.fromEntries(Object.entries(serverFileTypes).map(([key, value]) => [value, key]));
const getAcceptTypes = (serverTypes) => {
    const res = {};
    for (const type of serverTypes) {
        const localType = serverFileTypes2Local[type];
        if (localType) {
            const mimeMap = enableMIME[localType];
            const keys = Object.keys(mimeMap);
            for (const k of keys) {
                if (!res[mimeMap[k]]) {
                    res[mimeMap[k]] = [k];
                }
                else {
                    res[mimeMap[k]] = [...res[mimeMap[k]], k];
                }
            }
        }
    }
    return res;
};
const getUIFileData = (file) => {
    const arr = file.name.split('.');
    if (arr.length > 1) {
        const ex = arr[arr.length - 1];
        const e2MIME = `.${ex.toLowerCase()}`;
        const mimeType = file.type;
        const mt = (mimeType || ex2MIME[e2MIME]).split('/')[0];
        const fileUI = fileUIData[ex.toLowerCase()];
        const ui = ['text', 'application', 'other'].includes(mt) ? fileUI || fileUIData.other : {};
        const ct = ex.toUpperCase();
        return Object.assign({ mimeType: mt, orginnalMIMEType: mimeType, contentType: ContentTypeEnum[ct], name: file.name, ex, serverType: mt === 'text' ? serverFileTypes.other : serverFileTypes[mt] }, ui);
    }
};
const getObjectURL = (file) => URL.createObjectURL(file);
const loadImageDimensions = async (url) => {
    return new Promise((resolve, reject) => {
        const image = new Image();
        image.onload = () => {
            resolve({ width: image.width, height: image.height });
            URL.revokeObjectURL(url);
        };
        image.onerror = () => {
            reject(new Error('Failed to load image.'));
            URL.revokeObjectURL(url);
        };
        image.src = url;
    });
};
const loadVideoDimensions = async (url) => {
    return new Promise((resolve, reject) => {
        const video = document.createElement('video');
        video.onloadedmetadata = () => {
            resolve({ width: video.videoWidth, height: video.videoHeight });
            URL.revokeObjectURL(url);
        };
        video.onerror = () => {
            reject(new Error('Failed to load video.'));
            URL.revokeObjectURL(url);
        };
        video.src = url;
    });
};
const getMediaDimension = async (data) => {
    const url = getObjectURL(data.file);
    let dimensions = null;
    if (data.uiData.mimeType === 'image') {
        dimensions = await loadImageDimensions(url);
    }
    if (data.uiData.mimeType === 'video') {
        dimensions = await loadVideoDimensions(url);
    }
    return dimensions;
};
const processUploadFiles = async (botId, files) => {
    const fs = files.map(f => {
        return {
            file: f,
            status: 'pending',
            id: generateUUID(),
            botId,
            uiData: getUIFileData(f),
            cancelToken: {}
        };
    });
    const res = [];
    for (const file of fs) {
        try {
            const dimension = await getMediaDimension(file);
            res.push(Object.assign(Object.assign({}, file), { meta: Object.assign(Object.assign({}, (dimension || {})), { thumbnail: '' }) }));
        }
        catch (error) {
            console.error(error);
            res.push(file);
        }
    }
    return res;
};
const useDropFiles = ({ onFileChange, from, botId, isChoosingFile, types, setFile, fileMaxSize }) => {
    const showDragModal = useChatStore(state => state.showDragModal);
    const uploadedFilesLength = useChatStore(state => (state.fileUpload.filesMap[botId] || []).length);
    const { warning } = useNotification();
    const chatT = nextIntl.useTranslations('chat');
    const maxFiles = 1;
    const acceptTypes = React.useMemo(() => {
        const supportTypes = Array.isArray(types) ? types : ['MESSAGE_METADATA_TYPE_IMAGE_FILE'];
        return getAcceptTypes(supportTypes);
    }, []);
    const maxSize = fileMaxSize || defaultMaxSize;
    const { getRootProps, getInputProps } = reactDropzone.useDropzone({
        accept: acceptTypes,
        maxFiles: 1,
        noKeyboard: true,
        disabled: Object.keys(acceptTypes).length === 0,
        maxSize,
        onDragOver: e => {
            showDragModal(true);
        },
        onDragLeave: e => {
            showDragModal(false);
        },
        validator: (file) => {
            const arr = file.name ? file.name.split('.') : [];
            if (file.size > maxSize) {
                setFile({
                    status: 'error',
                    type: 'filesize'
                });
                return {
                    code: '401',
                    message: `Size is larger than ${maxSize}!`
                };
            }
            if (arr.length > 1) {
                const ex = arr[arr.length - 1];
                if (!supportFiles.includes(`.${ex.toLowerCase()}`) && !acceptTypes['*/*']) {
                    return {
                        code: '402',
                        message: `${ex} is not support yet!`
                    };
                }
                return null;
            }
            return {
                code: '402',
                message: `${file.type} is not support yet!`
            };
        },
        onDrop: acceptedFiles => {
            if (isChoosingFile) {
                isChoosingFile.current = false;
            }
            showDragModal(false);
            const nextLen = uploadedFilesLength + acceptedFiles.length;
            if (nextLen <= maxFiles) {
                onFileChange(acceptedFiles);
            }
            else {
                warning({ content: chatT('replicate.maxfiles') });
            }
        },
        onDropRejected: fileRejections => {
            const tooMany = fileRejections.every(file => {
                return file.errors[0].code === 'too-many-files';
            });
            const invalidfile = fileRejections.every(file => {
                return file.errors[0].code === 'file-invalid-type';
            });
            const filesize = fileRejections.every(file => {
                return file.errors[0].code === 'file-too-large';
            });
            if (tooMany) {
                setFile({
                    status: 'error',
                    type: 'maxfiles'
                });
            }
            else if (invalidfile) {
                setFile({
                    status: 'error',
                    type: 'invalid'
                });
            }
            else if (filesize) {
                setFile({
                    status: 'error',
                    type: 'filesize'
                });
            }
        }
    });
    return {
        getRootProps,
        getInputProps
    };
};

function FileUpload(props) {
    var _a, _b, _c, _d;
    const scrollerRef = React.useRef(null);
    const { botId, name = '', setFormValue, value, errors, clearErrors, supportedFileTypes, fileUploadSizeMaximum } = props;
    let fileName = props === null || props === void 0 ? void 0 : props[`x_ms_name_${name}`];
    if (!fileName) {
        const arr = value.split('/');
        const ex = (_a = arr[arr.length - 1]) === null || _a === void 0 ? void 0 : _a.split('.');
        fileName = ex[0];
    }
    let iconObj = fileUIData.other;
    let fileType = '';
    if (value) {
        const arr = value.split('.');
        if (arr.length > 1) {
            const ex = arr[arr.length - 1];
            const e2MIME = `.${ex.toLowerCase()}`;
            fileType = (_c = (_b = ex2MIME[e2MIME]) === null || _b === void 0 ? void 0 : _b.split('/')) === null || _c === void 0 ? void 0 : _c[0];
            iconObj = fileUIData[ex];
        }
    }
    const [file, setFile] = React.useState(value
        ? {
            status: 'completed',
            defaultUrl: value,
            file: {
                name: fileName,
                size: (_d = props === null || props === void 0 ? void 0 : props[`x_ms_size_${name}`]) !== null && _d !== void 0 ? _d : ''
            },
            uiData: {
                iconUrl: iconObj === null || iconObj === void 0 ? void 0 : iconObj.iconUrl,
                mimeType: fileType
            }
        }
        : undefined);
    const onDelete = () => {
        setFile(undefined);
        setFormValue(name, undefined);
        setFormValue(`x_ms_name_${name}`, undefined);
        setFormValue(`x_ms_size_${name}`, undefined);
    };
    const isChoosingFile = React.useRef(false);
    const { file: globalFile } = React.useContext(MessageContext);
    const uploadFiles = async (files, retry) => {
        var _a, _b;
        for (const file of files) {
            setFile(Object.assign(Object.assign({}, file), { status: 'pending' }));
            let res;
            if (typeof (globalFile === null || globalFile === void 0 ? void 0 : globalFile.overrideUploadFileToS3WithProgress) === 'function') {
                res = await globalFile.overrideUploadFileToS3WithProgress(file.file);
            }
            else {
                res = await uploadFileToS3WithProgress({
                    scenario: Scenario.SCENARIO_IM_CHAT,
                    contentType: file.uiData.contentType,
                    onProgress: value => {
                        setFile(Object.assign(Object.assign({}, file), { status: 'pending' }));
                    },
                    file: file.file,
                    cancelToken: (cancel) => {
                    }
                });
            }
            if (res.success) {
                setFile(Object.assign(Object.assign({}, file), { status: (res === null || res === void 0 ? void 0 : res.objectAccessUrl) ? 'completed' : 'error', url: res === null || res === void 0 ? void 0 : res.objectAccessUrl, defaultUrl: res === null || res === void 0 ? void 0 : res.objectAccessUrl }));
                setFormValue(name, res === null || res === void 0 ? void 0 : res.objectAccessUrl);
                setFormValue(`x_ms_name_${name}`, (_a = file.file) === null || _a === void 0 ? void 0 : _a.name);
                setFormValue(`x_ms_size_${name}`, (_b = file.file) === null || _b === void 0 ? void 0 : _b.size);
                clearErrors(name);
            }
            else {
                setFile({
                    status: 'error',
                    type: 'network'
                });
            }
        }
    };
    const onFileChange = React.useCallback(async (files) => {
        try {
            const res = await processUploadFiles(botId, files);
            uploadFiles(res);
        }
        catch (_a) {
            setFile({
                status: 'error',
                type: 'network'
            });
        }
    }, []);
    const { getRootProps, getInputProps } = useDropFiles({
        onFileChange,
        from: 'input',
        botId,
        isChoosingFile,
        types: supportedFileTypes,
        setFile,
        fileMaxSize: fileUploadSizeMaximum
    });
    const chatT = nextIntl.useTranslations('chat');
    const isError = file && (file === null || file === void 0 ? void 0 : file.status) === 'error' ? chatT('replicate.maxfiles') : '';
    const isEmptyError = (errors === null || errors === void 0 ? void 0 : errors.type) === 'required';
    return (jsxRuntime.jsxs("div", { className: "relative w-full overflow-hidden", children: [jsxRuntime.jsx("div", { className: clsx__default.default('w-full flex flex-col items-center justify-center p-3 border-[1px] bg-surface-default min-h-[96px] rounded-[12px]', isEmptyError || isError ? 'border-critical' : 'border-default'), ref: scrollerRef, style: {
                    boxShadow: '0px 1px 2px 0px rgba(0, 0, 0, 0.10)'
                }, children: file && !isError ? ((file === null || file === void 0 ? void 0 : file.status) === 'pending' ? (jsxRuntime.jsxs("div", { className: "flex flex-col justify-center items-center w-full", children: [jsxRuntime.jsx("div", { className: "w-10 h-10 px-2 rounded-[8px] bg-surface-container-hovered mb-2 flex flex-col items-center justify-center", children: jsxRuntime.jsx(Spinner, { size: "sm", className: "text-brand" }) }), jsxRuntime.jsx("p", { className: "text-default text-[16px] leading-[1] font-medium", children: chatT('replicate.uploading') })] })) : (jsxRuntime.jsx(FileDisplay, { data: file, onDelete: onDelete }))) : (jsxRuntime.jsxs("div", Object.assign({ className: clsx__default.default('w-full flex flex-col justify-center items-center cursor-pointer') }, getRootProps(), { children: [jsxRuntime.jsxs("div", { className: clsx__default.default('rounded-[8px] w-10 h-10 bg-surface-hovered mb-2'), children: [jsxRuntime.jsx("div", { className: "w-10 h-10 flex items-center justify-center rounded-lg", children: jsxRuntime.jsx(ForwardRef$N, { className: "w-6 h-6 storke-[var(--text)]" }) }), jsxRuntime.jsx("input", Object.assign({ name: "file-upload", className: "sr-only hidden", multiple: false }, getInputProps()))] }), jsxRuntime.jsx("p", { className: "text-subtle text-[14px]", children: chatT('replicate.tip') })] }))) }), isError ? (jsxRuntime.jsxs("p", { className: "text-critical text-[14px] mt-1.5", children: [file.type == 'maxfiles' && chatT('replicate.maxfiles'), file.type == 'filesize' &&
                        chatT('replicate.upload_filesize_tip', {
                            maxSize: `${Math.ceil((fileUploadSizeMaximum || 50 * 1024 ** 2) / 1024 ** 2)}M`
                        }), file.type == 'network' && chatT('replicate.upload_network_tip'), file.type == 'invalid' && chatT('replicate.invalid_tip')] })) : (isEmptyError && (jsxRuntime.jsx("p", { className: "text-critical text-[14px] mt-1.5", children: chatT('replicate.upload_required_tip', { fieldName: name }) })))] }));
}
var FileUpload$1 = React.memo(FileUpload);

const NumberSlider = React.forwardRef((props, ref) => {
    const { minLength, maxLength, value, name, type, setFormValue, errors } = props;
    const isEmptyError = (errors === null || errors === void 0 ? void 0 : errors.type) === 'required';
    const [numberError, setNumberError] = React.useState('');
    const [inputValue, setInputValue] = React.useState('');
    const chatT = nextIntl.useTranslations('chat');
    const rest = {};
    React.useEffect(() => {
        var _a;
        (_a = document.getElementById(`component_bot_sliderinput_${name}`)) === null || _a === void 0 ? void 0 : _a.blur();
    }, []);
    return (jsxRuntime.jsxs("div", { className: "w-full", children: [jsxRuntime.jsxs("div", { className: "flex w-full space-x-1.5", children: [jsxRuntime.jsx("div", { className: "w-full h-[36px] flex justify-center items-center rounded-[12px] border-[1px] border-default p-3", children: jsxRuntime.jsxs(react.Slider, { "aria-label": "slider-ex-1", max: maxLength, min: minLength, value: value, step: type === 'interSlider' ? 1 : 0.01, onChange: value => {
                                setInputValue(`${value}`);
                                setFormValue(name, Number(value));
                                setNumberError('');
                            }, ref: ref, focusThumbOnChange: false, children: [jsxRuntime.jsx(react.SliderTrack, { className: "bg-[#EDEEEF] h-[6px]", children: jsxRuntime.jsx(react.SliderFilledTrack, { className: "bg-surface-primary-default" }) }), jsxRuntime.jsx(react.SliderThumb, { className: "bg-surface-container-default border-brand border-[2px] z-0" })] }) }), jsxRuntime.jsx("div", { className: "flex-shrink-0 w-[60px] h-[36px] flex justify-center items-center rounded-[12px] border-[1px] border-default p-3", children: jsxRuntime.jsx(react.NumberInput, Object.assign({}, rest, { max: maxLength, min: minLength, value: inputValue || props.value, precision: type === 'interSlider' ? 0 : 2, step: type === 'interSlider' ? 1 : 0.01, onChange: value => {
                                setInputValue(value);
                                const num = Number(value);
                                if (!isNaN(num) && typeof num === 'number') {
                                    setFormValue(name, num);
                                }
                            }, onBlur: e => {
                                const num = e.currentTarget.value;
                                if (minLength != undefined && num < minLength) {
                                    setNumberError(chatT('replicate.input_min_tip', {
                                        num: minLength
                                    }));
                                    setFormValue(name, minLength);
                                    setInputValue(minLength);
                                }
                                else if (maxLength != undefined && num > maxLength) {
                                    setNumberError(chatT('replicate.input_max_tip', {
                                        num: maxLength
                                    }));
                                    setFormValue(name, maxLength);
                                    setInputValue(maxLength);
                                }
                                else if (!Number.isNaN(num)) {
                                    setNumberError('');
                                }
                            }, ref: ref, children: jsxRuntime.jsx(react.NumberInputField, { tabIndex: -1, id: `component_bot_sliderinput_${name}`, className: "text-center h-[44px] rounded-[12px] border-none hover:border-none focus:outline focus:outline-none focus-visible:border-none focus-visible:outline-offset-0 focus-visible:outline-none focus-visible:shadow-none px-0" }) })) })] }), numberError != '' && jsxRuntime.jsx("p", { className: "text-[#D72C0D] text-[14px] mt-1.5", children: numberError }), isEmptyError && (jsxRuntime.jsx("p", { className: "text-[#D72C0D] text-[14px] mt-1.5", children: chatT('replicate.input_required_tip', { fieldName: name }) }))] }));
});

function getJsonPathLine(jsonStr, query) {
    if (!jsonStr) {
        return -1;
    }
    try {
        const jsonData = JSON5__default.default.parse(jsonStr);
        const sourceMap = jsonSourceMap__default.default.stringify(jsonData, null, 2);
        const result = jsonpathPlus.JSONPath({ json: jsonData, path: query });
        if (result.length === 0) {
            return -1;
        }
        const pointer = jsonpathPlus.JSONPath({ json: jsonData, path: query, resultType: 'pointer' })[0];
        if (pointer in sourceMap.pointers) {
            const location = sourceMap.pointers[pointer];
            return (location.key ? location.key.line : location.value.line) + 1;
        }
    }
    catch (error) {
        console.error('Get Jsonpath Line Error:', error);
    }
    return -1;
}

const tryDo = (fn) => {
    try {
        return fn();
    }
    catch (e) {
        return undefined;
    }
};

Editor$1.loader.config({
    paths: {
        vs: '//myshellstatic.com/js/monaco-editor/min/vs'
    }
});
function CodeEditor({ disabled = false, value, onValueChange, language: lang, className, foldField = '', jsonPath = '', errorMsg }) {
    const [language, setLanguage] = React.useState(lang !== null && lang !== void 0 ? lang : 'json');
    const { resolvedTheme } = nextThemes.useTheme();
    const isDark = resolvedTheme === 'dark';
    const editorRef = React.useRef();
    const monaco = Editor$1.useMonaco();
    const [errLines, setErrorLines] = React.useState([]);
    React.useEffect(() => {
        const pathList = tryDo(() => JSON.parse(jsonPath || '[]')) || [];
        const jsonPathLines = pathList.map(path => getJsonPathLine(value, path));
        setErrorLines(jsonPathLines);
    }, [jsonPath, value]);
    const getLineNumberForField = (fieldName) => {
        const editor = editorRef.current;
        if (!editor)
            return -1;
        const model = editor.getModel();
        if (!model)
            return -1;
        const matches = model.findMatches(fieldName, false, true, false, null, true);
        if (matches.length > 0) {
            return matches[0].range.startLineNumber;
        }
        return -1;
    };
    React.useEffect(() => {
        if (monaco && editorRef.current) {
            const editor = editorRef.current;
            monaco.languages.json.jsonDefaults.setDiagnosticsOptions({
                validate: true,
                schemas: [],
                enableSchemaRequest: true,
                comments: 'ignore'
            });
            const model = editor.getModel();
            if (model) {
                if (errLines.length > 0) {
                    if (errLines[0] > 0) {
                        editor.revealLineInCenter(errLines[0]);
                    }
                    const markers = errLines.map(line => ({
                        startLineNumber: line,
                        startColumn: 1,
                        endLineNumber: line,
                        endColumn: 99999,
                        message: (errorMsg === null || errorMsg === void 0 ? void 0 : errorMsg.msg) || '',
                        severity: monaco.MarkerSeverity.Error
                    }));
                    monaco.editor.setModelMarkers(model, 'proconfig', markers);
                }
                else {
                    monaco.editor.setModelMarkers(model, 'proconfig', []);
                }
            }
        }
    }, [errLines, monaco, errorMsg]);
    const handleEditorValidation = (markers) => {
        markers.forEach(marker => console.log('onValidate:', marker.message));
    };
    const handleEditorDidMount = (editor, monaco) => {
        editorRef.current = editor;
        if (foldField) {
            const line = getLineNumberForField(foldField || '');
            const editorText = editor.getValue();
            let jsonData = {};
            try {
                jsonData = JSON.parse(editorText || '{}');
            }
            catch (_a) { }
            if (line > 0) {
                if (lodashEs.isArray(jsonData === null || jsonData === void 0 ? void 0 : jsonData[foldField]) && !(jsonData === null || jsonData === void 0 ? void 0 : jsonData[foldField].length)) {
                    return;
                }
                editor.setSelection({
                    startLineNumber: line,
                    startColumn: 1,
                    endLineNumber: line,
                    endColumn: 1
                });
                editor.trigger('fold', 'editor.fold', {
                    selectionLines: [line]
                });
            }
        }
        monaco.languages.json.jsonDefaults.setDiagnosticsOptions({
            comments: 'ignore'
        });
    };
    const handleValueChange = lodashEs.debounce((value, ev) => {
        requestAnimationFrame(() => onValueChange(value));
    }, 500);
    return (jsxRuntime.jsx(Editor__default.default, { language: language, theme: isDark ? 'vs-dark' : 'light', value: value, onChange: handleValueChange, onValidate: handleEditorValidation, onMount: handleEditorDidMount, className: className, options: {
            lineNumbersMinChars: 6,
            readOnly: disabled,
            minimap: {
                enabled: false
            },
            contextmenu: false,
            fontSize: 16,
            fontWeight: '500'
        } }));
}

function CopyBtn({ code }) {
    const t = nextIntl.useTranslations('common');
    const { onCopy } = useCopyClipboard(JSON.stringify(code !== null && code !== void 0 ? code : ''));
    const onClick = (e) => {
        e.preventDefault();
        onCopy();
    };
    return (jsxRuntime.jsx(Button$1, { variant: "outline", size: "md", disabled: !code, onClick: onClick, children: t('copy') }));
}
var CopyBtn$1 = React.memo(CopyBtn);

function CustomCodeEditor(props) {
    const { name, setFormValue, value } = props;
    const onValueChange = (v) => {
        setFormValue(name, v);
    };
    return (jsxRuntime.jsxs("div", { className: "w-full flex flex-col", children: [jsxRuntime.jsx("div", { className: "shrink-0 flex items-center p-4 space-x-4", children: jsxRuntime.jsx("div", { className: "grow flex justify-end", children: jsxRuntime.jsx(CopyBtn$1, { code: value }) }) }), jsxRuntime.jsx("div", { className: "w-full h-[200px]", children: jsxRuntime.jsx(CodeEditor, { language: "javascript", value: value, onValueChange: onValueChange }) })] }));
}

var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
function RenderForm(props) {
    var _a, _b;
    const { formEle, control, setFormValue, errors, register, defaultValues, clearErrors } = props;
    let Com = null;
    if (formEle.type === 'textarea') {
        Com = CustomTextarea;
    }
    if (formEle.type === 'input') {
        Com = react.Input;
    }
    if (formEle.type === 'select' || formEle.type === 'numberSelect') {
        Com = CustomSelect;
    }
    if (formEle.type === 'numberSlider' || formEle.type === 'interSlider') {
        Com = NumberSlider;
    }
    if (formEle.type === 'numberInput' || formEle.type === 'interInput') {
        Com = CustomNumberInput;
    }
    if (formEle.type === 'checkbox') {
        Com = CustomCheckbox;
    }
    if (formEle.type === 'upload') {
        Com = FileUpload$1;
    }
    if (formEle.type === 'codeEditor') {
        Com = CustomCodeEditor;
    }
    const handleValueChange = (value) => {
        if (setFormValue) {
            setFormValue(formEle.fieldName, value);
        }
    };
    if (Com) {
        const options = (formEle.type === 'select' || formEle.type === 'numberSelect') && formEle.options
            ? { options: formEle.options }
            : {};
        const extFiledName = {};
        if (formEle.type === 'upload') {
            const filedName = formEle.id;
            extFiledName[`x_ms_name_${filedName}`] = (_a = defaultValues === null || defaultValues === void 0 ? void 0 : defaultValues[`x_ms_name_${filedName}`]) !== null && _a !== void 0 ? _a : '';
            extFiledName[`x_ms_size_${filedName}`] = (_b = defaultValues === null || defaultValues === void 0 ? void 0 : defaultValues[`x_ms_size_${filedName}`]) !== null && _b !== void 0 ? _b : '';
        }
        return (jsxRuntime.jsxs(react.FormControl, { className: clsx__default.default('relative', formEle.wrapperClass), children: [formEle.name && (jsxRuntime.jsxs(react.FormLabel, { htmlFor: formEle.id, className: "mb-1.5 text-[14px]", children: [formEle.isRequired && jsxRuntime.jsx("span", { className: "text-[#EC2F0D] mr-[2px]", children: "*" }), formEle.name] })), formEle.description && (jsxRuntime.jsx(react.FormLabel, { htmlFor: formEle.id, className: "mb-1.5 text-[14px] text-subtle", children: formEle.description })), jsxRuntime.jsx("div", { className: clsx__default.default('flex flex-row justify-between items-center'), children: jsxRuntime.jsx(reactHookForm.Controller, { name: formEle.id, control: control, rules: formEle.rules, render: ({ field }) => {
                            const { ref, onChange } = field, rest = __rest(field, ["ref", "onChange"]);
                            const onValueChange = (v) => {
                                let value = v;
                                if (formEle.type === 'checkbox') {
                                    value = v.target.checked;
                                }
                                else if (v.target) {
                                    value = v.target.value;
                                }
                                onChange(value);
                                handleValueChange(value);
                                if (formEle.onChange) {
                                    formEle.onChange(value);
                                }
                            };
                            return (jsxRuntime.jsx(Com, Object.assign({}, rest, ((formEle === null || formEle === void 0 ? void 0 : formEle.props) || {}), options, extFiledName, { type: formEle.type, supportedFileTypes: formEle.supportedFileTypes, fileUploadSizeMaximum: (formEle === null || formEle === void 0 ? void 0 : formEle.fileUploadSizeMaximum) || 5 * 1024 ** 2, ref: ref, onChange: (data) => {
                                    onValueChange(data);
                                }, setFormValue: setFormValue, errors: errors, clearErrors: clearErrors, isInvalid: !!errors }, register(formEle.fieldName, { required: formEle.isRequired }), { className: clsx__default.default(formEle.type !== 'checkbox' &&
                                    'w-full border-default hover:border-hovered focus:outline focus:outline-none focus-visible:border-pressed focus-visible:outline-offset-0 focus-visible:outline-utility-sky-blue-500 focus-visible:shadow-none rounded-[12px]', formEle.class) })));
                        } }) })] }, formEle.id));
    }
    return null;
}

var LUIRenderForm = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: RenderForm
});

function LoginDialog({ open }) {
    const t = nextIntl.useTranslations('chat');
    const profileT = nextIntl.useTranslations('profile');
    const toggleLoginModal = useGlobalStore(state => state.toggleLoginModal);
    const go2Login = () => {
        toggleLoginModal(true);
    };
    return (jsxRuntime.jsx(Modal, { open: open, hideClose: true, overlayClassName: "z-[111]", contentClassName: "md:w-[500px] z-[112]", children: jsxRuntime.jsxs("div", { className: "px-5 py-[30px] flex flex-col items-center gap-10", children: [jsxRuntime.jsx(Text, { weight: "semibold", children: t('login_popup_tips') }), jsxRuntime.jsxs("div", { className: "w-full flex justify-evenly", children: [jsxRuntime.jsxs("div", { className: "flex w-full mt-3 rounded-xl overflow-hidden flex-col justify-center items-center gap-[10px]", children: [jsxRuntime.jsx(Image__default.default, { alt: "circle", src: "/images/free_premuium_membership.png", width: 90, height: 90, className: "size-[90px]" }), jsxRuntime.jsx(Text, { size: "sm", weight: "regular", className: "min-w-[45px] md:min-w-[60px]", children: t('free_premium_membership_card') })] }), jsxRuntime.jsxs("div", { className: "flex flex-col justify-center items-center gap-[10px] w-full mt-3 rounded-xl overflow-hidden", children: [jsxRuntime.jsx(Image__default.default, { alt: "circle", src: "/images/rewards.png", width: 90, height: 90, className: "size-[90px]" }), jsxRuntime.jsx(Text, { size: "sm", weight: "regular", className: "min-w-[45px] md:min-w-[60px]", children: t('more_conversations') })] }), jsxRuntime.jsxs("div", { className: "w-full mt-3 rounded-xl overflow-hidden flex flex-col justify-center items-center gap-[10px]", children: [jsxRuntime.jsx(Image__default.default, { alt: "circle", src: "/images/gpt4.png", width: 90, height: 90, className: "size-[90px]" }), jsxRuntime.jsx(Text, { size: "sm", weight: "regular", className: "min-w-[45px] md:min-w-[60px]", children: t('chat_with_gpt4') })] })] }), jsxRuntime.jsxs(Button$1, { variant: "primary", color: "brand", size: "lg", className: "w-fit", onClick: go2Login, children: [jsxRuntime.jsx(Text, { className: "text-inherit", children: profileT('login_sign_up') }), jsxRuntime.jsx(ForwardRef$H, { className: "size-5" })] })] }) }));
}

var LoginDialog$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: LoginDialog
});

function PinchZoomImage({ imgObj, onPinchStart, onPinchEnd }) {
    var _a, _b, _c, _d;
    const containerRef = React.useRef(null);
    const [scaleValue, setScaleValue] = React.useState(1);
    const prevScale = React.useRef(1);
    const imageRef = React.useRef(null);
    const [loaded, setLoaded] = React.useState(false);
    const handleLoaded = () => {
        setLoaded(true);
    };
    usehooksTs.useEffectOnce(() => {
        const image = imageRef.current;
        if (image) {
            image.addEventListener('load', handleLoaded, {
                once: true
            });
        }
    });
    React.useEffect(() => {
        if (containerRef.current) {
            const hammer = new Hammer__default.default(containerRef.current);
            hammer.get('pinch').set({ enable: true });
            hammer.on('pinchstart', () => {
                onPinchStart();
            });
            hammer.on('pinch', e => {
                e.srcEvent.stopPropagation();
                const newScale = Math.min(3, Math.max(0.5, prevScale.current * e.scale));
                setScaleValue(newScale);
            });
            hammer.on('pinchend', e => {
                onPinchEnd();
                prevScale.current *= e.scale;
            });
            return () => {
                hammer.destroy();
            };
        }
    }, []);
    return (jsxRuntime.jsxs("div", { style: {
            scale: scaleValue
        }, ref: containerRef, className: "w-full h-full relative flex justify-center items-center", children: [!loaded && (jsxRuntime.jsx("div", { className: "absolute top-0 left-0 w-full h-full flex justify-center items-center z-10 bg-[#00000033] backdrop-blur-2xl", children: jsxRuntime.jsx("div", { className: "w-10 h-10 p-[6px] flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "md", speed: "slow", className: "text-white" }) }) })), jsxRuntime.jsx("img", { ref: imageRef, alt: "image", src: imgObj.url, width: ((_a = imgObj.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.width) || 9999, height: ((_b = imgObj.mediaFileMetadata) === null || _b === void 0 ? void 0 : _b.height) || 9999, className: clsx__default.default('h-auto max-w-full max-h-full object-scale-down touch-none z-20', ((_c = imgObj.mediaFileMetadata) === null || _c === void 0 ? void 0 : _c.width) ? `w-[${imgObj.mediaFileMetadata.width}px]` : 'w-auto', ((_d = imgObj.mediaFileMetadata) === null || _d === void 0 ? void 0 : _d.height) ? `h-[${imgObj.mediaFileMetadata.height}px]` : 'h-auto') })] }));
}

function VideoPlayer$1({ src, triggerPlay }) {
    return (jsxRuntime.jsx("div", { className: "w-full h-full flex justify-center items-center", children: jsxRuntime.jsx("video", { src: src, className: "w-auto h-auto max-w-full max-h-full object-scale-down", disablePictureInPicture: true, controls: true, controlsList: "nodownload", autoPlay: triggerPlay }) }));
}
const MemorizedVideoPlayer$1 = React.memo(VideoPlayer$1);

function VideoOverview({ url, onViewVideo, customClass, showPlayBtn = true, showRadius = true, showLoading = true }) {
    const videoRef = React.useRef(null);
    const [loaded, setLoaded] = React.useState(false);
    const handleLoaded = () => {
        setLoaded(true);
    };
    usehooksTs.useEffectOnce(() => {
        const video = videoRef.current;
        if (video) {
            video.addEventListener('loadedmetadata', handleLoaded, {
                once: true
            });
        }
    });
    return (jsxRuntime.jsxs("div", { className: clsx__default.default('relative w-full h-full', customClass, showRadius ? 'rounded-md overflow-hidden' : ''), children: [!loaded && showLoading && (jsxRuntime.jsx("div", { className: "absolute top-0 left-0 w-full h-full flex justify-center items-center z-[1] bg-[#00000033] backdrop-blur-2xl", children: jsxRuntime.jsx("div", { className: "w-10 h-10 p-[6px] flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "md", speed: "slow", className: "text-white" }) }) })), jsxRuntime.jsxs("div", { className: "relative w-full h-full min-h-[240px]", children: [jsxRuntime.jsx("video", { ref: videoRef, src: url, muted: true, playsInline: true, disablePictureInPicture: true, className: "w-full h-full object-cover", preload: "metadata" }), showPlayBtn && (jsxRuntime.jsx("div", { className: "w-full h-full absolute top-0 left-0 flex justify-center items-center bg-[#00000033]", children: jsxRuntime.jsx(ForwardRef$f, { className: "w-10 h-10 text-white cursor-pointer", onClick: () => onViewVideo && onViewVideo() }) }))] })] }));
}
const MemorizedVideoOverview = React.memo(VideoOverview);

function MobilePreview({ imgVideoList, activeIndex, publishing, isGreeting, onClose, publishGalleryHandle }) {
    const [index, setIndex] = React.useState(activeIndex);
    const [zooming, setZooming] = React.useState(false);
    const { downloading, onImageDownload } = useDownload();
    const [touchStartY, setTouchStartY] = React.useState(null);
    const [translateY, setTranslateY] = React.useState(0);
    const swiperRef = React.useRef(null);
    const sensors = useSensors();
    nextIntl.useTranslations('common');
    useNotification();
    const { msgId, selectedBot, widgetInfo } = React.useContext(LUIButtonInteractionContext$1);
    const handleThumbnailClick = (idx) => {
        const swiper = swiperRef.current;
        if (swiper) {
            swiper.slideTo(idx);
        }
        setIndex(idx);
    };
    const handleDownload = () => {
        var _a, _b;
        console.log('aaaaaa3');
        onImageDownload(imgVideoList[index].url, imgVideoList[index].title || `Myshell_${selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.name}_${dayjs__default.default().format('YYMMDD_HHmmss')}`);
        if (sensors && sensors.track) {
            sensors === null || sensors === void 0 ? void 0 : sensors.track('MessageAction', Object.assign(Object.assign({ action_type: 'Save Image', message_id: msgId }, ((widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id)
                ? {
                    widget_id: widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id,
                    widget_name: widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.name
                }
                : {
                    bot_id: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.id,
                    bot_name: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.name
                })), { image_model: (_b = (_a = imgVideoList[index]) === null || _a === void 0 ? void 0 : _a.mediaFileMetadata) === null || _b === void 0 ? void 0 : _b.generateModel }));
        }
    };
    const handleIndexChange = (index) => {
        setIndex(index);
    };
    const onPinchStart = () => {
        setZooming(true);
    };
    const onPinchEnd = () => {
        setZooming(false);
    };
    const handleTouchStart = (event) => {
        event.stopPropagation();
        if (event.touches.length > 1)
            return;
        setTouchStartY(event.touches[0].clientY);
    };
    const handleTouchMove = (event) => {
        event.stopPropagation();
        if (touchStartY === null)
            return;
        const currentY = event.touches[0].clientY;
        const deltaY = currentY - touchStartY;
        setTranslateY(deltaY);
    };
    const handleTouchEnd = () => {
        if (translateY > 100) {
            onClose();
        }
        setTranslateY(0);
    };
    return (jsxRuntime.jsxs("div", { className: "flex flex-col w-full h-[100svh] bg-black overflow-hidden ease-in-out", style: {
            transform: `translateY(${translateY > 0 ? translateY : 0}px)`
        }, children: [jsxRuntime.jsxs("div", { className: "flex px-4 md:px-[6px] py-4 justify-between shrink-0", onTouchStart: handleTouchStart, onTouchMove: handleTouchMove, onTouchEnd: handleTouchEnd, children: [jsxRuntime.jsxs("div", { className: "flex justify-start", children: [jsxRuntime.jsx(IconButton, { icon: ForwardRef$T, variant: "ghost", color: "static", "aria-label": "download file", loading: downloading, onClick: handleDownload, size: "md", className: "min-w-fit w-9 h-9 rounded-full flex justify-center items-center data-[loading]:text-white", children: jsxRuntime.jsx(ForwardRef$T, { className: "w-6 h-6 text-white" }) }), (selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.isImageGenerator) && !isGreeting && (selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.status) === BotStatusEnum.Public && (jsxRuntime.jsx(IconButton, { icon: PhotoStackIcon, variant: "ghost", color: "static", "aria-label": "download file", loading: publishing, onClick: e => {
                                    e.stopPropagation();
                                    e.preventDefault();
                                    publishGalleryHandle === null || publishGalleryHandle === void 0 ? void 0 : publishGalleryHandle(index);
                                }, size: "md", className: "min-w-fit w-9 h-9 rounded-full flex justify-center items-center data-[loading]:text-white" }))] }), jsxRuntime.jsx(IconButton, { variant: "primary", size: "md", "aria-label": "close modal", icon: ForwardRef$j, onClick: onClose, className: "min-w-fit w-9 h-9 rounded-full flex justify-center items-center border-none text-static bg-beta-black-20 hover:bg-beta-black-40 active:bg-beta-black-40 shadow-none" })] }), jsxRuntime.jsx("div", { style: {
                    height: imgVideoList.length > 1 ? 'calc(100% - 120px)' : 'calc(100% - 56px)'
                }, children: jsxRuntime.jsx(Swiper, { spaceBetween: 100, slidesPerView: 1, initialSlide: activeIndex, onSwiper: swiper => {
                        swiperRef.current = swiper;
                    }, onSlideChange: swiper => {
                        handleIndexChange(swiper.realIndex);
                    }, className: "grow w-full h-full", enabled: !zooming, loop: imgVideoList.length > 1, children: imgVideoList.map((item, itemIndex) => (jsxRuntime.jsx(SwiperSlide, { children: jsxRuntime.jsx("div", { className: clsx__default.default('touch-none', item.type === EmbedObjType.VIDEO
                                ? 'w-full h-full overflow-hidden justify-center items-center relative z-10'
                                : 'absolute w-full h-full flex justify-center items-center z-10', itemIndex === index ? 'visible' : ' invisible w-0 h-0'), children: item.type === EmbedObjType.VIDEO ? (jsxRuntime.jsx(MemorizedVideoPlayer$1, { src: item.url, triggerPlay: itemIndex === index })) : (jsxRuntime.jsx(PinchZoomImage, { imgObj: item, onPinchStart: onPinchStart, onPinchEnd: onPinchEnd })) }) }, item.url))) }) }), imgVideoList.length > 1 && (jsxRuntime.jsx("div", { className: "flex justify-center items-center px-[6px] py-3 space-x-2 shrink-0", children: imgVideoList.length <= 4 ? (imgVideoList.map((file, idx) => (jsxRuntime.jsx(React.Fragment, { children: file.type === EmbedObjType.VIDEO ? (jsxRuntime.jsx("div", { className: clsx__default.default('rounded-md overflow-hidden h-10 object-cover cursor-pointer ease-linear duration-200 transition-[width] select-none', index === idx ? 'w-10' : 'w-7'), onClick: () => handleThumbnailClick(idx), children: jsxRuntime.jsx(MemorizedVideoOverview, { url: file.url, showPlayBtn: false, showRadius: false, showLoading: false }, file.url) })) : (jsxRuntime.jsx("img", { alt: "thumbnail image", src: file.url, width: 56, height: 56, className: clsx__default.default('rounded-md h-10 object-cover cursor-pointer ease-linear duration-200 transition-[width] select-none', index === idx ? 'w-10' : 'w-7'), onClick: () => handleThumbnailClick(idx) })) }, file.url)))) : (jsxRuntime.jsx("div", { className: "flex space-x-2", children: imgVideoList.map((file, idx) => (jsxRuntime.jsx("div", { className: clsx__default.default('rounded-full w-2 h-2', index === idx ? 'bg-white' : 'bg-[#FFFFFF33]'), onClick: () => handleThumbnailClick(idx) }, file.url))) })) }))] }));
}

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: MobilePreview
});

function ImageItem({ imgObj, handleZoomIn, handleZoomOut, resetScaleValue, onClose }) {
    var _a, _b;
    const draggableRef = React.useRef(null);
    const [isDragging, setIsDragging] = React.useState(false);
    const [position, setPosition] = React.useState({ x: 0, y: 0 });
    const [offset, setOffset] = React.useState({ x: 0, y: 0 });
    const [loaded, setLoaded] = React.useState(false);
    const { width, height } = usehooksTs.useWindowSize();
    const timer = React.useRef(null);
    const [moved, setMoved] = React.useState(false);
    const handleLoaded = () => {
        setLoaded(true);
    };
    React.useEffect(() => {
        const imgRef = draggableRef.current;
        const handleMouseMove = (event) => {
            if (!isDragging)
                return;
            const newX = event.clientX - offset.x;
            const newY = event.clientY - offset.y;
            setPosition({ x: newX, y: newY });
            setMoved(true);
        };
        const handleMouseUp = () => {
            setIsDragging(false);
        };
        if (imgRef) {
            imgRef.addEventListener('load', handleLoaded, {
                once: true
            });
        }
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);
        return () => {
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        };
    }, [isDragging, offset]);
    const handleMouseDown = (event) => {
        if (event.button === 2) {
            return;
        }
        event.stopPropagation();
        setIsDragging(true);
        setMoved(false);
        setOffset({
            x: event.clientX - position.x,
            y: event.clientY - position.y
        });
    };
    const handleWheel = (event) => {
        if (event.deltaY === 0)
            return;
        if (event.deltaY < 0) {
            handleZoomIn();
        }
        else {
            handleZoomOut();
        }
    };
    function calculateImageSize(containerSize, imageSize) {
        let newWidth = imageSize.width;
        let newHeight = imageSize.height;
        if (imageSize.width === 0 || imageSize.height === 0) {
            return containerSize;
        }
        if (imageSize.width <= containerSize.width && imageSize.height <= containerSize.height) {
            return imageSize;
        }
        const widthRatio = containerSize.width / imageSize.width;
        const heightRatio = containerSize.height / imageSize.height;
        const ratio = Math.min(widthRatio, heightRatio);
        newWidth = imageSize.width * ratio;
        newHeight = imageSize.height * ratio;
        return {
            width: newWidth,
            height: newHeight
        };
    }
    const originDimension = React.useMemo(() => {
        var _a, _b, _c, _d;
        return calculateImageSize({ width, height: height - 80 }, { width: (_b = (_a = imgObj.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : 0, height: (_d = (_c = imgObj.mediaFileMetadata) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0 });
    }, [height, (_a = imgObj.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.height, (_b = imgObj.mediaFileMetadata) === null || _b === void 0 ? void 0 : _b.width, width]);
    const handleSingleClick = () => {
        if (moved) {
            setMoved(false);
            return;
        }
        if (timer.current) {
            clearTimeout(timer.current);
        }
        timer.current = setTimeout(() => {
            onClose();
        }, 200);
    };
    const handleDoubleClick = () => {
        if (timer.current) {
            clearTimeout(timer.current);
            resetScaleValue();
        }
    };
    return (jsxRuntime.jsxs("div", { className: clsx__default.default('w-full h-full relative flex justify-center items-center'), children: [!loaded && (jsxRuntime.jsx("div", { className: "absolute top-0 left-0 w-full h-full flex justify-center items-center z-10", children: jsxRuntime.jsx("div", { className: "flex justify-center items-center bg-[#00000033] backdrop-blur-2xl", style: Object.assign({}, originDimension), children: jsxRuntime.jsx("div", { className: "w-10 h-10 p-[6px] flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "md", speed: "slow", className: "text-white" }) }) }) })), jsxRuntime.jsx("div", { className: "image-item absolute w-full h-full top-0 left-0 z-[1]", onClick: onClose }), jsxRuntime.jsx("img", { ref: draggableRef, alt: "image", src: imgObj.url, width: originDimension.width || 9999, height: originDimension.height || 9999, draggable: true, className: clsx__default.default('object-scale-down z-20', isDragging ? 'cursor-grabbing' : 'cursor-grab'), style: {
                    transform: `translate(${position.x}px, ${position.y}px)`,
                    maxHeight: originDimension.height || '80vh'
                }, onMouseDown: handleMouseDown, onDragStart: e => e.preventDefault(), onWheel: handleWheel, onClick: handleSingleClick, onDoubleClick: handleDoubleClick })] }));
}

function VideoPlayer({ videoObj, onClose, triggerPlay }) {
    var _a, _b, _c, _d;
    const videoRef = React.useRef(null);
    const [duration, setDuration] = React.useState(0);
    const [isPlaying, setIsPlaying] = React.useState(false);
    const [currentTime, setCurrentTime] = React.useState(0);
    const [videoHasError, setVideoHasError] = React.useState(false);
    const [muted, setMuted] = React.useState(false);
    const [volume, setVolume] = React.useState(0.5);
    const { isMobile } = useDevice();
    const [volumeBeforeMuted, setVolumeBeforeMuted] = React.useState(0.5);
    const [loaded, setLoaded] = React.useState(false);
    const { width, height } = usehooksTs.useWindowSize();
    const hoverRef = React.useRef(null);
    const isHover = usehooksTs.useHover(hoverRef);
    React.useEffect(() => {
        setIsPlaying(false);
        setCurrentTime(0);
        setDuration(0);
    }, [videoObj === null || videoObj === void 0 ? void 0 : videoObj.url]);
    usehooksTs.useEffectOnce(() => {
        const video = videoRef.current;
        if (video) {
            video.volume = 0.5;
        }
    });
    const handleVideoLoad = () => {
        const video = videoRef.current;
        setDuration(video.duration);
    };
    const handleVideoError = () => {
        setVideoHasError(true);
    };
    const handleVideoToggle = () => {
        const video = videoRef.current;
        if (video) {
            if (!video.paused) {
                video.pause();
                setIsPlaying(false);
            }
            else {
                video.play().catch(err => {
                    console.error(err, err === null || err === void 0 ? void 0 : err.stack);
                });
            }
        }
    };
    const handleVideoTimeUpdate = () => {
        const video = videoRef.current;
        if (video) {
            setCurrentTime(video.currentTime);
            if (!video.paused) {
                requestAnimationFrame(handleVideoTimeUpdate);
            }
        }
    };
    function afterPlayEnd() {
        if (videoRef.current) {
            videoRef.current.currentTime = 0;
            videoRef.current.pause();
            setIsPlaying(false);
        }
        setCurrentTime(0);
    }
    const handleVideoProgressChangeStart = () => {
        const video = videoRef.current;
        if (video) {
            if (!video.paused) {
                video.pause();
                setIsPlaying(false);
            }
        }
    };
    const handleVideoProgressChange = (newValue) => {
        const video = videoRef.current;
        if (video) {
            video.currentTime = newValue;
            setCurrentTime(video.currentTime);
        }
    };
    const handleVideoProgressChangeEnd = () => {
        const video = videoRef.current;
        if (video) {
            if (video.paused) {
                video.play().catch(err => {
                    console.error(err, err === null || err === void 0 ? void 0 : err.stack);
                });
            }
        }
    };
    const onVolumeChange = (value) => {
        const video = videoRef.current;
        if (video) {
            setVolume(value);
            video.volume = value;
            if (value === 0) {
                setMuted(true);
                setVolumeBeforeMuted(0);
            }
            else if (muted) {
                setMuted(false);
            }
        }
    };
    const toggleMuted = (state) => {
        setMuted(state);
        const video = videoRef.current;
        if (state) {
            if (video) {
                setVolumeBeforeMuted(volume);
                setVolume(0);
                video.volume = 0;
            }
        }
        if (!state) {
            if (volumeBeforeMuted !== 0) {
                if (video) {
                    setVolume(volumeBeforeMuted);
                    video.volume = volumeBeforeMuted;
                }
            }
            else if (video) {
                setVolume(0.1);
                video.volume = 0.1;
            }
        }
    };
    const handlePlay = () => {
        setIsPlaying(true);
    };
    const handleCanPlay = () => {
        handleVideoLoad();
        setLoaded(true);
    };
    React.useEffect(() => {
        const video = videoRef.current;
        video === null || video === void 0 ? void 0 : video.addEventListener('play', handlePlay);
        video === null || video === void 0 ? void 0 : video.addEventListener('canplay', handleCanPlay);
        video === null || video === void 0 ? void 0 : video.addEventListener('canplaythrough', handleCanPlay);
        if ((video === null || video === void 0 ? void 0 : video.readyState) && (video === null || video === void 0 ? void 0 : video.readyState) >= 2) {
            handleCanPlay();
        }
        return () => {
            video === null || video === void 0 ? void 0 : video.removeEventListener('play', handlePlay);
            video === null || video === void 0 ? void 0 : video.removeEventListener('canplay', handleCanPlay);
            video === null || video === void 0 ? void 0 : video.removeEventListener('canplaythrough', handleCanPlay);
        };
    }, []);
    React.useEffect(() => {
        const video = videoRef.current;
        if (video) {
            if (triggerPlay) {
                if (video.readyState >= 4) {
                    video.paused &&
                        video.play().catch(err => {
                            console.error(err, err === null || err === void 0 ? void 0 : err.stack);
                        });
                }
                else {
                    video.addEventListener('canplaythrough', () => {
                        video.paused &&
                            video.play().catch(err => {
                                console.error(err, err === null || err === void 0 ? void 0 : err.stack);
                            });
                    }, { once: true });
                }
            }
            else {
                video.pause();
                video.currentTime = 0;
                setCurrentTime(0);
            }
        }
    }, [triggerPlay]);
    function calculateMediaSize(containerSize, mediaSize) {
        let newWidth = mediaSize.width;
        let newHeight = mediaSize.height;
        if (mediaSize.width === 0 || mediaSize.height === 0) {
            return containerSize;
        }
        if (mediaSize.width <= containerSize.width && mediaSize.height <= containerSize.height) {
            return mediaSize;
        }
        const widthRatio = containerSize.width / mediaSize.width;
        const heightRatio = containerSize.height / mediaSize.height;
        const ratio = Math.min(widthRatio, heightRatio);
        newWidth = mediaSize.width * ratio;
        newHeight = mediaSize.height * ratio;
        return {
            width: newWidth,
            height: newHeight
        };
    }
    const originDimension = React.useMemo(() => {
        var _a, _b, _c, _d;
        return calculateMediaSize({ width, height: height - 80 }, { width: (_b = (_a = videoObj.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : 0, height: (_d = (_c = videoObj.mediaFileMetadata) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : 0 });
    }, [height, (_a = videoObj.mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.height, (_b = videoObj.mediaFileMetadata) === null || _b === void 0 ? void 0 : _b.width, width]);
    return (jsxRuntime.jsxs("div", { className: "w-full h-full relative flex justify-center items-center", ref: hoverRef, children: [!loaded && (jsxRuntime.jsx("div", { className: "absolute top-0 left-0 w-full h-full flex justify-center items-center z-10", children: jsxRuntime.jsx("div", { className: "flex justify-center items-center bg-[#00000033] backdrop-blur-2xl", style: Object.assign({}, originDimension), children: jsxRuntime.jsx("div", { className: "w-10 h-10 p-[6px] flex justify-center items-center", children: jsxRuntime.jsx(Spinner, { size: "md", speed: "slow", className: "text-white" }) }) }) })), jsxRuntime.jsx("div", { className: "absolute w-full h-full top-0 left-0 z-[1]", onClick: onClose }), jsxRuntime.jsx("video", { src: videoObj.url, className: "object-scale-down", width: (_c = originDimension.width) !== null && _c !== void 0 ? _c : 9999, height: (_d = originDimension.height) !== null && _d !== void 0 ? _d : 9999, ref: videoRef, onEnded: afterPlayEnd, onTimeUpdate: handleVideoTimeUpdate, onError: handleVideoError, muted: muted, style: Object.assign({}, originDimension) }), isHover && loaded && (jsxRuntime.jsx("div", { className: "absolute bottom-9 w-full flex justify-center z-10", children: jsxRuntime.jsxs("div", { className: "w-[480px] h-[56px] flex space-x-2 justify-center items-center border border-default rounded-xl p-4 bg-surface-container-default text-default shadow-[0_0_2px_0_#0000001A]", children: [jsxRuntime.jsx(react.Button, { variant: "unstyled", onClick: handleVideoToggle, borderRadius: "full", "aria-label": "audio control button", isDisabled: !videoObj.url || !loaded, _disabled: {
                                opacity: 0.3,
                                cursor: 'not-allowed'
                            }, size: "sm", className: "!flex !items-center !justify-center text-default w-9 h-9", children: isPlaying ? jsxRuntime.jsx(ForwardRef$g, { className: "w-6 h-6" }) : jsxRuntime.jsx(ForwardRef$f, { className: "w-6 h-6" }) }), jsxRuntime.jsx("span", { className: "text-subtle text-xs shrink-0", children: durationFormatter(currentTime) }), jsxRuntime.jsxs(react.Slider, { min: 0, max: duration, value: currentTime, onChangeStart: handleVideoProgressChangeStart, onChange: (value) => handleVideoProgressChange(value), onChangeEnd: handleVideoProgressChangeEnd, focusThumbOnChange: false, isDisabled: !loaded, className: "flex items-center w-full h-6 cursor-pointer", children: [jsxRuntime.jsx(react.SliderTrack, { className: "bg-[#EDF0F5] dark:bg-[#22242E]", children: jsxRuntime.jsx(react.SliderFilledTrack, { className: "bg-surface-primary-default" }) }), jsxRuntime.jsx(react.SliderThumb, { className: "bg-surface-primary-default border-[2px] border-white" })] }), jsxRuntime.jsx("span", { className: "text-subtle text-xs shrink-0", children: durationFormatter(duration) }), jsxRuntime.jsxs(react.Popover, { placement: "top", trigger: isMobile ? 'click' : 'hover', offset: [0, 8], closeOnBlur: true, openDelay: 100, children: [jsxRuntime.jsx(react.PopoverTrigger, { children: jsxRuntime.jsx("div", { children: muted ? (jsxRuntime.jsx(ForwardRef, { className: "w-5 h-5 text-default cursor-pointer", onClick: () => toggleMuted(false) })) : (jsxRuntime.jsx(ForwardRef$1, { className: "w-5 h-5 text-default cursor-pointer", onClick: () => toggleMuted(true) })) }) }), jsxRuntime.jsx(react.PopoverContent, { className: "rounded-lg p-3 border border-default w-8 h-[121px] bg-surface-container-default text-default shadow-lg", children: jsxRuntime.jsx(react.PopoverBody, { className: "p-0 flex justify-center items-center", children: jsxRuntime.jsxs(react.Slider, { orientation: "vertical", min: 0, max: 1, step: 0.01, value: volume, onChange: onVolumeChange, focusThumbOnChange: false, className: "h-[97px]", children: [jsxRuntime.jsx(react.SliderTrack, { className: "bg-[#EDF0F5] dark:bg-[#22242E] w-[2px]", children: jsxRuntime.jsx(react.SliderFilledTrack, { className: "bg-surface-primary-default" }) }), jsxRuntime.jsx(react.SliderThumb, { className: "bg-surface-primary-default border-[2px] border-surface-container-default" })] }) }) })] })] }) }))] }));
}
const MemorizedVideoPlayer = React.memo(VideoPlayer);

function Preview({ imgVideoList, activeIndex, publishing, isGreeting, onClose, publishGalleryHandle }) {
    const [index, setIndex] = React.useState(activeIndex);
    const [scaleValue, setScaleValue] = React.useState(1);
    const scaleStep = 0.1;
    nextIntl.useTranslations('common');
    const chatT = nextIntl.useTranslations('chat');
    const sensors = useSensors();
    const { downloading, onImageDownload } = useDownload();
    useNotification();
    const { msgId, selectedBot, widgetInfo } = React.useContext(LUIButtonInteractionContext$1);
    const flagUserFirstPublishGallery = useUserStore(state => state.flagUserFirstPublishGallery);
    const handleDownload = () => {
        var _a;
        console.log('aaaaaa4');
        const media_file_url = imgVideoList[index].url;
        onImageDownload(media_file_url, imgVideoList[index].title || `Myshell_${(selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.name) || (widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.name)}_${dayjs__default.default().format('YYMMDD_HHmmss')}`);
        if (sensors && sensors.track) {
            const imageModel = (_a = imgVideoList[index].mediaFileMetadata) === null || _a === void 0 ? void 0 : _a.generateModel;
            if (imageModel) {
                sensors === null || sensors === void 0 ? void 0 : sensors.track('MessageAction', Object.assign(Object.assign({ action_type: 'Save Image', message_id: msgId }, ((widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id)
                    ? {
                        widget_id: widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id,
                        widget_name: widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.name
                    }
                    : {
                        bot_id: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.id,
                        bot_name: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.name
                    })), { image_model: imageModel }));
            }
            else {
                mediaFileMetadata({
                    media_file_url
                })
                    .then(res => {
                    var _a;
                    sensors === null || sensors === void 0 ? void 0 : sensors.track('MessageAction', Object.assign(Object.assign({ action_type: 'Save Image', message_id: msgId }, ((widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id)
                        ? {
                            widget_id: widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id,
                            widget_name: widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.name
                        }
                        : {
                            bot_id: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.id,
                            bot_name: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.name
                        })), { image_model: (_a = res === null || res === void 0 ? void 0 : res.meta) === null || _a === void 0 ? void 0 : _a.generateModel }));
                })
                    .catch(() => {
                    sensors === null || sensors === void 0 ? void 0 : sensors.track('MessageAction', Object.assign(Object.assign({ action_type: 'Save Image', message_id: msgId }, ((widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id)
                        ? {
                            widget_id: widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.id,
                            widget_name: widgetInfo === null || widgetInfo === void 0 ? void 0 : widgetInfo.name
                        }
                        : {
                            bot_id: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.id,
                            bot_name: selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.name
                        })), { image_model: '' }));
                });
            }
        }
    };
    const selectedItem = React.useMemo(() => {
        return imgVideoList[index];
    }, [imgVideoList, index]);
    React.useEffect(() => {
        const handleKeyDown = (e) => {
            switch (e.key) {
                case 'ArrowLeft':
                    handleGoToPrev();
                    break;
                case 'ArrowRight':
                    handleGoToNext();
                    break;
                case 'ArrowUp':
                    handleZoomIn();
                    break;
                case 'ArrowDown':
                    handleZoomOut();
                    break;
            }
        };
        document.addEventListener('keydown', handleKeyDown);
        return () => {
            document.removeEventListener('keydown', handleKeyDown);
        };
    }, []);
    const resetScaleValue = () => {
        setScaleValue(1);
    };
    React.useEffect(() => {
        setScaleValue(1);
    }, [index]);
    const handleZoomIn = React.useCallback(() => {
        if (scaleValue >= 3) ;
        else {
            setScaleValue(scaleValue + scaleStep);
        }
    }, [scaleValue]);
    const handleZoomOut = React.useCallback(() => {
        if (scaleValue <= 0.5) ;
        else {
            setScaleValue(scaleValue - scaleStep);
        }
    }, [scaleValue]);
    const handleGoToPrev = React.useCallback((e) => {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        e === null || e === void 0 ? void 0 : e.stopPropagation();
        setIndex(index < 1 ? imgVideoList.length - 1 : index - 1);
    }, [imgVideoList.length, index]);
    const handleGoToNext = React.useCallback((e) => {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        e === null || e === void 0 ? void 0 : e.stopPropagation();
        setIndex(index === imgVideoList.length - 1 ? 0 : index + 1);
    }, [imgVideoList.length, index]);
    return (jsxRuntime.jsxs("div", { className: "w-full h-screen overflow-hidden flex flex-col", children: [jsxRuntime.jsxs("div", { className: "relative flex justify-center w-full", style: {
                    height: 'calc(100vh - 80px)'
                }, children: [jsxRuntime.jsx(IconButton, { icon: ForwardRef$j, size: "md", className: "flex justify-center items-center w-9 h-9 absolute top-6 right-6 z-50 cursor-pointer rounded-full border border-none text-static bg-beta-black-20 hover:bg-beta-black-40 active:bg-beta-black-40 shadow-none", onClick: onClose }), jsxRuntime.jsx("div", { className: "img-video-index absolute w-full h-full top-0 left-0 z-[1]", onClick: onClose }), imgVideoList.length > 1 && (jsxRuntime.jsx(IconButton, { onClick: handleGoToPrev, variant: "primary", color: "brand", size: "md", "aria-label": "go to prev", className: "absolute left-6 md:left-6 top-1/2 -translate-y-1/2 z-30 bg-beta-black-20 hover:bg-beta-black-40 active:bg-beta-black-40 ml-2 shadow-none", icon: ForwardRef$I })), jsxRuntime.jsx(framerMotion.AnimatePresence, { mode: "popLayout", children: imgVideoList.map((item, itemIndex) => (jsxRuntime.jsx(framerMotion.motion.div, { initial: { opacity: 0 }, animate: { opacity: itemIndex === index ? 1 : 0 }, exit: { opacity: 0 }, transition: { duration: 0.2 }, className: clsx__default.default(item.type === EmbedObjType.VIDEO
                                ? 'max-w-3/4 h-full overflow-hidden justify-center items-center relative z-10'
                                : 'absolute w-full h-full flex justify-center items-center z-10', itemIndex === index ? 'visible' : ' invisible w-0 h-0'), style: {
                                scale: scaleValue
                            }, children: item.type === EmbedObjType.VIDEO ? (jsxRuntime.jsx(MemorizedVideoPlayer, { videoObj: item, triggerPlay: itemIndex === index, onClose: onClose })) : (jsxRuntime.jsx(ImageItem, { imgObj: item, handleZoomIn: handleZoomIn, handleZoomOut: handleZoomOut, resetScaleValue: resetScaleValue, onClose: onClose })) }, item.url))) }), imgVideoList.length > 1 && (jsxRuntime.jsx(IconButton, { onClick: handleGoToNext, variant: "primary", color: "brand", size: "md", "aria-label": "go to next", className: "absolute right-6 md:right-11 top-1/2 -translate-y-1/2 z-30 bg-beta-black-20 hover:bg-beta-black-40 active:bg-beta-black-40 ml-2 shadow-none", icon: ForwardRef$H }))] }), jsxRuntime.jsxs("div", { className: "h-20 w-full px-6 py-3 flex justify-between items-center shrink-0 relative z-20", children: [jsxRuntime.jsx("div", { className: "absolute w-full h-full top-0 left-0 z-30", onClick: onClose }), selectedItem.type === EmbedObjType.IMAGE ? (jsxRuntime.jsx("div", { className: "flex justify-end items-center space-x-2", children: jsxRuntime.jsxs("div", { className: "rounded-xl bg-beta-black-20 px-3 flex space-x-[6px] items-center h-[38px] relative z-50", style: {
                                backdropFilter: 'blur(12px)'
                            }, children: [jsxRuntime.jsx(ForwardRef$u, { className: "w-5 h-5 text-beta-white-70 cursor-pointer", onClick: handleZoomOut }), jsxRuntime.jsxs(react.Slider, { width: "72px", value: scaleValue, min: 0.5, max: 3, step: scaleStep, onChange: (value) => {
                                        setScaleValue(value);
                                    }, focusThumbOnChange: false, children: [jsxRuntime.jsx(react.SliderTrack, { className: "bg-[#EDF0F5] dark:bg-[#22242E]", children: jsxRuntime.jsx(react.SliderFilledTrack, { className: "bg-surface-primary-default" }) }), jsxRuntime.jsx(react.SliderThumb, { className: "bg-surface-primary-default border-[2px] border-surface-container-default", zIndex: 0 })] }), jsxRuntime.jsx(ForwardRef$n, { className: "w-5 h-5 text-beta-white-70 cursor-pointer", onClick: handleZoomIn })] }) })) : (jsxRuntime.jsx("div", { className: "w-[150px]", onClick: onClose })), imgVideoList.length > 1 && (jsxRuntime.jsx("div", { className: "flex space-x-2 relative z-50", children: imgVideoList.map((file, idx) => (jsxRuntime.jsx(React.Fragment, { children: file.type === EmbedObjType.VIDEO ? (jsxRuntime.jsx("div", { className: clsx__default.default('rounded-md overflow-hidden h-14 object-cover cursor-pointer ease-linear duration-200 transition-[width] select-none', index === idx ? 'w-14' : 'w-7'), onClick: () => setIndex(idx), children: jsxRuntime.jsx(MemorizedVideoOverview, { url: file.url, showPlayBtn: false, showRadius: false, showLoading: false }, file.url) })) : (jsxRuntime.jsx("img", { alt: "thumbnail image", src: file.url, className: clsx__default.default('rounded-md h-14 object-cover cursor-pointer ease-linear duration-200 transition-[width] select-none', index === idx ? 'w-14' : 'w-7'), onClick: () => setIndex(idx) })) }, file.url))) })), jsxRuntime.jsxs("div", { className: "min-w-[150px] flex justify-end relative z-50", children: [(selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.isImageGenerator) && !isGreeting && (selectedBot === null || selectedBot === void 0 ? void 0 : selectedBot.status) === BotStatusEnum.Public && (jsxRuntime.jsx(Tooltip, { open: !flagUserFirstPublishGallery ? true : undefined, description: flagUserFirstPublishGallery ? chatT('publish_to_gallery') : chatT('publish_battery'), variant: flagUserFirstPublishGallery ? 'default' : 'message', children: jsxRuntime.jsx(IconButton, { icon: PhotoStackIcon, loading: publishing, onClick: e => {
                                        e.stopPropagation();
                                        e.preventDefault();
                                        publishGalleryHandle === null || publishGalleryHandle === void 0 ? void 0 : publishGalleryHandle(index);
                                    }, variant: "primary", color: "brand", size: "md", className: "relative z-30 bg-beta-black-20 hover:bg-beta-black-40 active:bg-beta-black-40 ml-2 shadow-none" }) })), jsxRuntime.jsx("div", { className: "absolute w-full h-full top-0 left-0", onClick: onClose }), jsxRuntime.jsx(IconButton, { variant: "primary", color: "brand", size: "md", "aria-label": "download file", loading: downloading, onClick: handleDownload, className: "relative z-30 bg-beta-black-20 hover:bg-beta-black-40 active:bg-beta-black-40 ml-2 shadow-none", icon: ForwardRef$T })] })] })] }));
}

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    default: Preview
});

exports.ChatModule = ChatModule;
exports.ChatStoreProvider = ChatStoreProvider;
exports.GlobalStoreProvider = GlobalStoreProvider;
exports.MessageContext = MessageContext;
exports.MessageToDisplayParser = MessageToDisplayParser;
exports.RunningError = RunningError$1;
exports.StaticContext = StaticContext;
exports.UserStoreProvider = UserStoreProvider;
exports.useAtBottom = useAtBottom;
exports.useChatLayout = useChatLayout;
exports.useEditorMode = useEditorMode;
exports.useMessageParams = useMessageParams;
exports.useUploadFiles = useUploadFiles;
exports.useVirtuosoMessageListApi = useVirtuosoMessageListApi;
